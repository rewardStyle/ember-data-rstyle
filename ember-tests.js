var JSHINTRC = {
    "predef": [
        "console",
        "requireModule",
        "Ember",
        "DS",
        "Handlebars",
        "Metamorph",
        "ember_assert",
        "ember_warn",
        "ember_deprecate",
        "ember_deprecateFunc",
        "require",
        "setupStore",
        "equal",
        "asyncEqual",
        "notEqual",
        "asyncTest",
        "test",
        "raises",
        "deepEqual",
        "start",
        "stop",
        "ok",
        "strictEqual",
        "module",
        "expect",
        "minispade",
        "async",
        "invokeAsync",
        "jQuery",
        "expectAssertion"
    ],

    "node" : false,
    "es5" : true,
    "browser" : true,

    "boss" : true,
    "curly": false,
    "debug": false,
    "devel": false,
    "eqeqeq": true,
    "evil": true,
    "forin": false,
    "immed": false,
    "laxbreak": false,
    "newcap": true,
    "noarg": true,
    "noempty": false,
    "nonew": false,
    "nomen": false,
    "onevar": false,
    "plusplus": false,
    "regexp": false,
    "undef": true,
    "sub": true,
    "strict": false,
    "white": false,
    "eqnull": true
}
;

minispade.register('ember-data/~tests/integration/adapter/find_all_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar Person, adapter, store, allRecords;\n\nmodule(\"integration/adapter/find_all - Finding All Records of a Type\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n    allRecords = null;\n  },\n\n  teardown: function() {\n    if (allRecords) { allRecords.destroy(); }\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"When all records for a type are requested, the store should call the adapter's `findAll` method.\", function() {\n  expect(5);\n\n  adapter.findAll = function(store, type, since) {\n    // this will get called twice\n    ok(true, \"the adapter's findAll method should be invoked\");\n\n    return Ember.RSVP.resolve([{ id: 1, name: \"Braaaahm Dale\" }]);\n  };\n\n  var allRecords;\n\n  store.find(Person).then(async(function(all) {\n    allRecords = all;\n    equal(get(all, 'length'), 1, \"the record array's length is 1 after a record is loaded into it\");\n    equal(all.objectAt(0).get('name'), \"Braaaahm Dale\", \"the first item in the record array is Braaaahm Dale\");\n  }));\n\n  store.find(Person).then(async(function(all) {\n    // Only one record array per type should ever be created (identity map)\n    strictEqual(allRecords, all, \"the same record array is returned every time all records of a type are requested\");\n  }));\n});\n\ntest(\"When all records for a type are requested, a rejection should reject the promise\", function() {\n  expect(5);\n\n  var count = 0;\n  adapter.findAll = function(store, type, since) {\n    // this will get called twice\n    ok(true, \"the adapter's findAll method should be invoked\");\n\n    if (count++ === 0) {\n      return Ember.RSVP.reject();\n    } else {\n      return Ember.RSVP.resolve([{ id: 1, name: \"Braaaahm Dale\" }]);\n    }\n  };\n\n  var allRecords;\n\n  store.find(Person).then(null, async(function() {\n    ok(true, \"The rejection should get here\");\n    return store.find(Person);\n  })).then(async(function(all) {\n    allRecords = all;\n    equal(get(all, 'length'), 1, \"the record array's length is 1 after a record is loaded into it\");\n    equal(all.objectAt(0).get('name'), \"Braaaahm Dale\", \"the first item in the record array is Braaaahm Dale\");\n  }));\n});\n\ntest(\"When all records for a type are requested, records that are already loaded should be returned immediately.\", function() {\n  expect(3);\n\n  // Load a record from the server\n  store.push(Person, { id: 1, name: \"Jeremy Ashkenas\" });\n\n  // Create a new, unsaved record in the store\n  store.createRecord(Person, { name: \"Alex MacCaw\" });\n\n  allRecords = store.all(Person);\n\n  equal(get(allRecords, 'length'), 2, \"the record array's length is 2\");\n  equal(allRecords.objectAt(0).get('name'), \"Jeremy Ashkenas\", \"the first item in the record array is Jeremy Ashkenas\");\n  equal(allRecords.objectAt(1).get('name'), \"Alex MacCaw\", \"the second item in the record array is Alex MacCaw\");\n});\n\ntest(\"When all records for a type are requested, records that are created on the client should be added to the record array.\", function() {\n  expect(3);\n\n  allRecords = store.all(Person);\n\n  equal(get(allRecords, 'length'), 0, \"precond - the record array's length is zero before any records are loaded\");\n\n  store.createRecord(Person, { name: \"Carsten Nielsen\" });\n\n  equal(get(allRecords, 'length'), 1, \"the record array's length is 1\");\n  equal(allRecords.objectAt(0).get('name'), \"Carsten Nielsen\", \"the first item in the record array is Carsten Nielsen\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/find_all_test");minispade.register('ember-data/~tests/integration/adapter/find_test', "(function() {var get = Ember.get, set = Ember.set;\nvar Person, store, adapter;\n\nmodule(\"integration/adapter/find - Finding Records\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"When a single record is requested, the adapter's find method should be called unless it's loaded.\", function() {\n  expect(2);\n\n  var count = 0;\n\n  adapter.find = function(store, type, id) {\n    equal(type, Person, \"the find method is called with the correct type\");\n    equal(count, 0, \"the find method is only called once\");\n\n    count++;\n    return { id: 1, name: \"Braaaahm Dale\" };\n  };\n\n  store.find(Person, 1);\n  store.find(Person, 1);\n});\n\ntest(\"When a single record is requested, and the promise is rejected, .find() is rejected.\", function() {\n  var count = 0;\n\n  adapter.find = function(store, type, id) {\n    return Ember.RSVP.reject();\n  };\n\n  store.find(Person, 1).then(null, async(function(reason) {\n    ok(true, \"The rejection handler was called\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/find_test");minispade.register('ember-data/~tests/integration/adapter/fixture_adapter_test', "(function() {var get = Ember.get, set = Ember.set;\nvar env, Person, Phone, App;\n\nmodule(\"integration/adapter/fixture_adapter - DS.FixtureAdapter\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string'),\n\n      height: DS.attr('number'),\n\n      phones: DS.hasMany('phone', { async: true })\n    });\n\n    Phone = DS.Model.extend({\n      person: DS.belongsTo('person')\n    });\n\n    env = setupStore({ person: Person, phone: Phone, adapter: DS.FixtureAdapter });\n    env.adapter.simulateRemoteResponse = true;\n\n    // Enable setTimeout.\n    Ember.testing = false;\n\n    Person.FIXTURES = [];\n    Phone.FIXTURES = [];\n  },\n  teardown: function() {\n    Ember.testing = true;\n\n    env.container.destroy();\n  }\n});\n\ntest(\"should load data for a type asynchronously when it is requested\", function() {\n  Person.FIXTURES = [{\n    id: 'wycats',\n    firstName: \"Yehuda\",\n    lastName: \"Katz\",\n\n    height: 65\n  },\n\n  {\n    id: 'ebryn',\n    firstName: \"Erik\",\n    lastName: \"Brynjolffsosysdfon\",\n\n    height: 70,\n    phones: [1, 2]\n  }];\n\n  Phone.FIXTURES = [{\n    id: 1,\n    person: 'ebryn'\n  }, {\n    id: 2,\n    person: 'ebryn'\n  }];\n\n  env.store.find('person', 'ebryn').then(async(function(ebryn) {\n    equal(get(ebryn, 'isLoaded'), true, \"data loads asynchronously\");\n    equal(get(ebryn, 'height'), 70, \"data from fixtures is loaded correctly\");\n\n    return Ember.RSVP.hash({ ebryn: ebryn, wycats: env.store.find('person', 'wycats') });\n  }, 1000)).then(async(function(records) {\n    equal(get(records.wycats, 'isLoaded'), true, \"subsequent requests for records are returned asynchronously\");\n    equal(get(records.wycats, 'height'), 65, \"subsequent requested records contain correct information\");\n\n    return get(records.ebryn, 'phones');\n  }, 1000)).then(async(function(phones) {\n    equal(get(phones, 'length'), 2, \"relationships from fixtures is loaded correctly\");\n  }, 1000));\n});\n\ntest(\"should load data asynchronously at the end of the runloop when simulateRemoteResponse is false\", function() {\n  Person.FIXTURES = [{\n    id: 'wycats',\n    firstName: \"Yehuda\"\n  }];\n\n  env.adapter.simulateRemoteResponse = false;\n\n  var wycats;\n\n  Ember.run(function() {\n    env.store.find('person', 'wycats').then(function(person) {\n      wycats = person;\n    });\n  });\n\n  ok(get(wycats, 'isLoaded'), 'isLoaded is true after runloop finishes');\n  equal(get(wycats, 'firstName'), 'Yehuda', 'record properties are defined after runloop finishes');\n});\n\ntest(\"should create record asynchronously when it is committed\", function() {\n  equal(Person.FIXTURES.length, 0, \"Fixtures is empty\");\n\n  var paul = env.store.createRecord('person', {firstName: 'Paul', lastName: 'Chavard', height: 70});\n\n  paul.on('didCreate', async(function() {\n    equal(get(paul, 'isNew'), false, \"data loads asynchronously\");\n    equal(get(paul, 'isDirty'), false, \"data loads asynchronously\");\n    equal(get(paul, 'height'), 70, \"data from fixtures is saved correctly\");\n\n    equal(Person.FIXTURES.length, 1, \"Record added to FIXTURES\");\n\n    var fixture = Person.FIXTURES[0];\n\n    ok(typeof fixture.id === 'string', \"The fixture has an ID generated for it\");\n    equal(fixture.firstName, 'Paul');\n    equal(fixture.lastName, 'Chavard');\n    equal(fixture.height, 70);\n  }));\n\n  paul.save();\n});\n\ntest(\"should update record asynchronously when it is committed\", function() {\n  equal(Person.FIXTURES.length, 0, \"Fixtures is empty\");\n\n  var paul = env.store.push('person', { id: 1, firstName: 'Paul', lastName: 'Chavard', height: 70});\n\n  paul.set('height', 80);\n\n  paul.on('didUpdate', async(function() {\n    equal(get(paul, 'isDirty'), false, \"data loads asynchronously\");\n    equal(get(paul, 'height'), 80, \"data from fixtures is saved correctly\");\n\n    equal(Person.FIXTURES.length, 1, \"Record FIXTURES updated\");\n\n    var fixture = Person.FIXTURES[0];\n\n    equal(fixture.firstName, 'Paul');\n    equal(fixture.lastName, 'Chavard');\n    equal(fixture.height, 80);\n  }, 1000));\n\n  paul.save();\n});\n\ntest(\"should delete record asynchronously when it is committed\", function() {\n  stop();\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n\n  equal(Person.FIXTURES.length, 0, \"Fixtures empty\");\n\n  var paul = env.store.push('person', { id: 'paul', firstName: 'Paul', lastName: 'Chavard', height: 70 });\n\n  paul.deleteRecord();\n\n  paul.on('didDelete', function() {\n    clearTimeout(timer);\n    start();\n\n    equal(get(paul, 'isDeleted'), true, \"data deleted asynchronously\");\n    equal(get(paul, 'isDirty'), false, \"data deleted asynchronously\");\n\n    equal(Person.FIXTURES.length, 0, \"Record removed from FIXTURES\");\n  });\n\n  paul.save();\n});\n\ntest(\"should follow isUpdating semantics\", function() {\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n\n  stop();\n\n  Person.FIXTURES = [{\n    id: \"twinturbo\",\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  var result = env.store.findAll('person');\n\n  result.then(function(all) {\n    clearTimeout(timer);\n    start();\n    equal(get(all, 'isUpdating'), false, \"isUpdating is set when it shouldn't be\");\n  });\n});\n\ntest(\"should coerce integer ids into string\", function() {\n  Person.FIXTURES = [{\n    id: 1,\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  env.store.find('person', 1).then(async(function(result) {\n    strictEqual(get(result, 'id'), \"1\", \"should load integer model id as string\");\n  }));\n});\n\ntest(\"should coerce belongsTo ids into string\", function() {\n  Person.FIXTURES = [{\n    id: 1,\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n\n    phones: [1]\n  }];\n\n  Phone.FIXTURES = [{\n    id: 1,\n    person: 1\n  }];\n\n  env.store.find('phone', 1).then(async(function(result) {\n    var person = get(result, 'person');\n    person.one('didLoad', async(function() {\n      strictEqual(get(result, 'person.id'), \"1\", \"should load integer belongsTo id as string\");\n      strictEqual(get(result, 'person.firstName'), \"Adam\", \"resolved relationship with an integer belongsTo id\");\n    }));\n  }));\n});\n\ntest(\"only coerce belongsTo ids to string if id is defined and not null\", function() {\n  Person.FIXTURES = [];\n\n  Phone.FIXTURES = [{\n    id: 1\n  }];\n\n  env.store.find('phone', 1).then(async(function(phone) {\n    equal(phone.get('person'), null);\n  }));\n});\n\ntest(\"should throw if ids are not defined in the FIXTURES\", function() {\n  Person.FIXTURES = [{\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  raises(function(){\n    env.store.find('person', 1);\n  }, /the id property must be defined as a number or string for fixture/);\n\n  Person.FIXTURES = [{\n    id: 0\n  }];\n\n  env.store.find('person', 0).then(async(function() {\n    ok(true, \"0 is an acceptable ID, so no exception was thrown\");\n  }), function() {\n    ok(false, \"should not get here\");\n  });\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/fixture_adapter_test");minispade.register('ember-data/~tests/integration/adapter/queries_test', "(function() {var get = Ember.get, set = Ember.set;\nvar Person, env, store, adapter;\n\nmodule(\"integration/adapter/queries - Queries\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    env = setupStore({ person: Person });\n    store = env.store;\n    adapter = env.adapter;\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"When a query is made, the adapter should receive a record array it can populate with the results of the query.\", function() {\n  adapter.findQuery = function(store, type, query, recordArray) {\n    equal(type, Person, \"the find method is called with the correct type\");\n\n    return Ember.RSVP.resolve([{ id: 1, name: \"Peter Wagenet\" }, { id: 2, name: \"Brohuda Katz\" }]);\n  };\n\n  store.find('person', { page: 1 }).then(async(function(queryResults) {\n    equal(get(queryResults, 'length'), 2, \"the record array has a length of 2 after the results are loaded\");\n    equal(get(queryResults, 'isLoaded'), true, \"the record array's `isLoaded` property should be true\");\n\n    equal(queryResults.objectAt(0).get('name'), \"Peter Wagenet\", \"the first record is 'Peter Wagenet'\");\n    equal(queryResults.objectAt(1).get('name'), \"Brohuda Katz\", \"the second record is 'Brohuda Katz'\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/queries_test");minispade.register('ember-data/~tests/integration/adapter/record_persistence_test', "(function() {var get = Ember.get, set = Ember.set, attr = DS.attr;\nvar Person, env, store;\n\nvar all = Ember.RSVP.all, hash = Ember.RSVP.hash, resolve = Ember.RSVP.resolve;\n\nfunction assertClean(promise) {\n  return promise.then(async(function(record) {\n    equal(record.get('isDirty'), false, \"The record is now clean\");\n    return record;\n  }));\n}\n\n\nmodule(\"integration/adapter/record_persistence - Persisting Records\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: attr('string'),\n      name: attr('string'),\n      firstName: attr('string'),\n      lastName: attr('string')\n    });\n    Person.toString = function() { return \"Person\"; };\n\n    env = setupStore({ person: Person });\n    store = env.store;\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"When a store is committed, the adapter's `commit` method should be called with records that have been changed.\", function() {\n  expect(2);\n\n  env.adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n    equal(record, tom, \"the record is correct\");\n\n    return Ember.RSVP.resolve();\n  };\n\n  env.store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n\n  var tom;\n\n  env.store.find('person', 1).then(async(function(person) {\n    tom = person;\n    set(tom, \"name\", \"Tom Dale\");\n    tom.save();\n  }));\n});\n\ntest(\"When a store is committed, the adapter's `commit` method should be called with records that have been created.\", function() {\n  expect(2);\n\n  env.adapter.createRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n    equal(record, tom, \"the record is correct\");\n\n    return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\" });\n  };\n\n  var tom = env.store.createRecord('person', { name: \"Tom Dale\" });\n  tom.save();\n});\n\ntest(\"After a created record has been assigned an ID, finding a record by that ID returns the original record.\", function() {\n  expect(1);\n\n  env.adapter.createRecord = function(store, type, record) {\n    return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\" });\n  };\n\n  var tom = env.store.createRecord('person', { name: \"Tom Dale\" });\n  tom.save();\n\n  asyncEqual(tom, env.store.find('person', 1), \"the retrieved record is the same as the created record\");\n});\n\ntest(\"when a store is committed, the adapter's `commit` method should be called with records that have been deleted.\", function() {\n  env.adapter.deleteRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n    equal(record, tom, \"the record is correct\");\n\n    return Ember.RSVP.resolve();\n  };\n\n  var tom;\n\n  env.store.push('person', { id: 1, name: \"Tom Dale\" });\n  env.store.find('person', 1).then(async(function(person) {\n    tom = person;\n    tom.deleteRecord();\n    return tom.save();\n  })).then(async(function(tom) {\n    equal(get(tom, 'isDeleted'), true, \"record is marked as deleted\");\n  }));\n});\n\ntest(\"An adapter can notify the store that records were updated by calling `didSaveRecords`.\", function() {\n  expect(6);\n\n  var tom, yehuda;\n\n  env.adapter.updateRecord = function(store, type, record) {\n    return Ember.RSVP.resolve();\n  };\n\n  env.store.push('person', { id: 1 });\n  env.store.push('person', { id: 2 });\n\n  all([ env.store.find('person', 1), env.store.find('person', 2)  ])\n    .then(async(function(array) {\n      tom = array[0];\n      yehuda = array[1];\n\n      tom.set('name', \"Michael Phelps\");\n      yehuda.set('name', \"Usain Bolt\");\n\n      ok(tom.get('isDirty'), \"tom is dirty\");\n      ok(yehuda.get('isDirty'), \"yehuda is dirty\");\n\n      assertClean(tom.save()).then(async(function(record) {\n        equal(record, tom, \"The record is correct\");\n      }));\n\n      assertClean(yehuda.save()).then(async(function(record) {\n        equal(record, yehuda, \"The record is correct\");\n      }));\n    }));\n});\n\ntest(\"An adapter can notify the store that records were updated and provide new data by calling `didSaveRecords`.\", function() {\n  var tom, yehuda;\n\n  env.adapter.updateRecord = function(store, type, record) {\n    if (record.get('id') === \"1\") {\n      return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", updatedAt: \"now\" });\n    } else if (record.get('id') === \"2\") {\n      return Ember.RSVP.resolve({ id: 2, name: \"Yehuda Katz\", updatedAt: \"now!\" });\n    }\n  };\n\n  env.store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n  env.store.push('person', { id: 2, name: \"Gentile Katz\" });\n\n  hash({ tom: env.store.find('person', 1), yehuda: env.store.find('person', 2) }).then(async(function(people) {\n    people.tom.set('name', \"Draaaaaahm Dale\");\n    people.yehuda.set('name', \"Goy Katz\");\n\n    return hash({ tom: people.tom.save(), yehuda: people.yehuda.save() });\n  })).then(async(function(people) {\n    equal(people.tom.get('name'), \"Tom Dale\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(people.tom.get('updatedAt'), \"now\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n    equal(people.yehuda.get('name'), \"Yehuda Katz\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(people.yehuda.get('updatedAt'), \"now!\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n  }));\n});\n\ntest(\"An adapter can notify the store that a record was updated by calling `didSaveRecord`.\", function() {\n  env.adapter.updateRecord = function(store, type, record) {\n    return Ember.RSVP.resolve();\n  };\n\n  store.push('person', { id: 1 });\n  store.push('person', { id: 2 });\n\n  hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(people) {\n    people.tom.set('name', \"Tom Dale\");\n    people.yehuda.set('name', \"Yehuda Katz\");\n\n    ok(people.tom.get('isDirty'), \"tom is dirty\");\n    ok(people.yehuda.get('isDirty'), \"yehuda is dirty\");\n\n    assertClean(people.tom.save());\n    assertClean(people.yehuda.save());\n  }));\n\n});\n\ntest(\"An adapter can notify the store that a record was updated and provide new data by calling `didSaveRecord`.\", function() {\n  env.adapter.updateRecord = function(store, type, record) {\n    switch (record.get('id')) {\n      case \"1\":\n        return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", updatedAt: \"now\" });\n      case \"2\":\n        return Ember.RSVP.resolve({ id: 2, name: \"Yehuda Katz\", updatedAt: \"now!\" });\n    }\n  };\n\n  env.store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n  env.store.push('person', { id: 2, name: \"Gentile Katz\" });\n\n\n  hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(people) {\n    people.tom.set('name', \"Draaaaaahm Dale\");\n    people.yehuda.set('name', \"Goy Katz\");\n\n    return hash({ tom: people.tom.save(), yehuda: people.yehuda.save() });\n  })).then(async(function(people) {\n    equal(people.tom.get('name'), \"Tom Dale\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(people.tom.get('updatedAt'), \"now\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n    equal(people.yehuda.get('name'), \"Yehuda Katz\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(people.yehuda.get('updatedAt'), \"now!\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n  }));\n\n});\n\ntest(\"An adapter can notify the store that records were deleted by calling `didSaveRecords`.\", function() {\n  env.adapter.deleteRecord = function(store, type, record) {\n    return Ember.RSVP.resolve();\n  };\n\n  env.store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n  env.store.push('person', { id: 2, name: \"Gentile Katz\" });\n\n  hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(people) {\n    people.tom.deleteRecord();\n    people.yehuda.deleteRecord();\n\n    assertClean(people.tom.save());\n    assertClean(people.yehuda.save());\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/record_persistence_test");minispade.register('ember-data/~tests/integration/adapter/rest_adapter_test', "(function() {var env, store, adapter, Post, Person, Comment;\nvar originalAjax, passedUrl, passedVerb, passedHash;\n\nmodule(\"integration/adapter/rest_adapter - REST Adapter\", {\n  setup: function() {\n    Post = DS.Model.extend({\n      name: DS.attr(\"string\")\n    });\n\n    Post.toString = function() {\n      return \"Post\";\n    };\n\n    Comment = DS.Model.extend({\n      name: DS.attr(\"string\")\n    });\n\n    env = setupStore({\n      post: Post,\n      comment: Comment,\n      adapter: DS.RESTAdapter\n    });\n\n    store = env.store;\n    adapter = env.adapter;\n\n    passedUrl = passedVerb = passedHash = null;\n  }\n});\n\nfunction ajaxResponse(value) {\n  adapter.ajax = function(url, verb, hash) {\n    passedUrl = url;\n    passedVerb = verb;\n    passedHash = hash;\n\n    return Ember.RSVP.resolve(value);\n  };\n}\n\ntest(\"find - basic payload\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\n\ntest(\"find - basic payload (with legacy singular name)\", function() {\n  ajaxResponse({ post: { id: 1, name: \"Rails is omakase\" } });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\ntest(\"find - payload with sideloaded records of the same type\", function() {\n  var count = 0;\n\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n\n    var post2 = store.getById('post', 2);\n    equal(post2.get('id'), \"2\");\n    equal(post2.get('name'), \"The Parley Letter\");\n  }));\n});\n\ntest(\"find - payload with sideloaded records of a different type\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('id'), \"1\");\n    equal(comment.get('name'), \"FIRST\");\n  }));\n});\n\ntest(\"find - payload with an serializer-specified primary key\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_'\n  }));\n\n  ajaxResponse({ posts: [{ \"_ID_\": 1, name: \"Rails is omakase\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\n\ntest(\"find - payload with a serializer-specified attribute mapping\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    attrs: {\n      'name': '_NAME_'\n    }\n  }));\n\n  ajaxResponse({ posts: [{ id: 1, _NAME_: \"Rails is omakase\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\n\ntest(\"create - an empty payload is a basic success if an id was specified\", function() {\n  ajaxResponse();\n\n  var post = store.createRecord('post', { id: \"some-uuid\", name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { id: \"some-uuid\", name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"The Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"create - a payload with a new ID and data applies the updates\", function() {\n  ajaxResponse({ posts: [{ id: \"1\", name: \"Dat Parley Letter\" }] });\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('id'), \"1\", \"the post has the updated ID\");\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"create - a payload with a new ID and data applies the updates (with legacy singular name)\", function() {\n  ajaxResponse({ post: { id: \"1\", name: \"Dat Parley Letter\" } });\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('id'), \"1\", \"the post has the updated ID\");\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"create - a serializer's primary key and attributes are consulted when building the payload\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_id_',\n\n    attrs: {\n      name: '_name_'\n    }\n  }));\n\n  ajaxResponse();\n\n  var post = store.createRecord('post', { id: \"some-uuid\", name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    deepEqual(passedHash.data, { post: { _id_: 'some-uuid', '_name_': \"The Parley Letter\" } });\n  }));\n});\n\ntest(\"create - a serializer's attributes are consulted when building the payload if no id is pre-defined\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primarykey: '_id_',\n\n    attrs: {\n      name: '_name_'\n    }\n  }));\n\n  ajaxResponse();\n\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    deepEqual(passedHash.data, { post: { '_name_': \"The Parley Letter\" } });\n  }));\n});\n\ntest(\"update - an empty payload is a basic success\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse();\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"The Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"update - a payload with updates applies the updates\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ posts: [{ id: 1, name: \"Dat Parley Letter\" }] });\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"update - a payload with updates applies the updates (with legacy singular name)\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ post: { id: 1, name: \"Dat Parley Letter\" } });\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"update - a payload with sideloaded updates pushes the updates\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Dat Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('id'), \"1\", \"the post has the updated ID\");\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('name'), \"FIRST\", \"The comment was sideloaded\");\n  }));\n});\n\n\ntest(\"update - a payload with sideloaded updates pushes the updates\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ posts: [{ id: 1, name: \"Dat Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('name'), \"FIRST\", \"The comment was sideloaded\");\n  }));\n});\n\ntest(\"update - a serializer's primary key and attributes are consulted when building the payload\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_id_',\n\n    attrs: {\n      name: '_name_'\n    }\n  }));\n\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n  ajaxResponse();\n\n  store.find('post', 1).then(async(function(post) {\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    deepEqual(passedHash.data, { post: { '_name_': \"The Parley Letter\" } });\n  }));\n});\n\ntest(\"delete - an empty payload is a basic success\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse();\n\n    post.deleteRecord();\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"DELETE\");\n    equal(passedHash, undefined);\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('isDeleted'), true, \"the post is now deleted\");\n  }));\n});\n\ntest(\"delete - a payload with sideloaded updates pushes the updates\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }] });\n\n    post.deleteRecord();\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"DELETE\");\n    equal(passedHash, undefined);\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('isDeleted'), true, \"the post is now deleted\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('name'), \"FIRST\", \"The comment was sideloaded\");\n  }));\n});\n\ntest(\"findAll - returning an array populates the array\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }] });\n\n  store.findAll('post').then(async(function(posts) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findAll - returning sideloaded data loads the data\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n  store.findAll('post').then(async(function(posts) {\n    var comment = store.getById('comment', 1);\n\n    deepEqual(comment.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n  }));\n});\n\ntest(\"findAll - data is normalized through custom serializers\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  ajaxResponse({ posts: [{ _ID_: 1, _NAME_: \"Rails is omakase\" }, { _ID_: 2, _NAME_: \"The Parley Letter\" }] });\n\n  store.findAll('post').then(async(function(posts) {\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findQuery - returning an array populates the array\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }] });\n\n  store.findQuery('post', { page: 1 }).then(async(function(posts) {\n    equal(passedUrl, '/posts');\n    equal(passedVerb, 'GET');\n    deepEqual(passedHash, { page: 1 });\n\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findQuery - returning sideloaded data loads the data\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n  store.findQuery('post', { page: 1 }).then(async(function(posts) {\n    var comment = store.getById('comment', 1);\n\n    deepEqual(comment.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n  }));\n});\n\ntest(\"findQuery - data is normalized through custom serializers\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  ajaxResponse({ posts: [{ _ID_: 1, _NAME_: \"Rails is omakase\" }, { _ID_: 2, _NAME_: \"The Parley Letter\" }] });\n\n  store.findQuery('post', { page: 1 }).then(async(function(posts) {\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findMany - returning an array populates the array\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [ 1, 2, 3 ] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findMany - returning sideloaded data loads the data\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [ 1, 2, 3 ] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }, { id: 4, name: \"Unrelated comment\" }], posts: [{ id: 2, name: \"The Parley Letter\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3),\n        comment4 = store.getById('comment', 4),\n        post2    = store.getById('post', 2);\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n\n    deepEqual(comment4.getProperties('id', 'name'), { id: \"4\", name: \"Unrelated comment\" });\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" });\n  }));\n});\n\ntest(\"findMany - a custom serializer is used if present\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  env.container.register('serializer:comment', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [ 1, 2, 3 ] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ _ID_: 1, _NAME_: \"FIRST\" }, { _ID_: 2, _NAME_: \"Rails is unagi\" }, { _ID_: 3, _NAME_: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findHasMany - returning an array populates the array\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", links: { comments: '/posts/1/comments' } });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    equal(passedUrl, '/posts/1/comments');\n    equal(passedVerb, 'GET');\n    equal(passedHash, undefined);\n\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findMany - returning sideloaded data loads the data\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", links: { comments: '/posts/1/comments' } });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }], posts: [{ id: 2, name: \"The Parley Letter\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3),\n        post2    = store.getById('post', 2);\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" });\n  }));\n});\n\ntest(\"findMany - a custom serializer is used if present\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  env.container.register('serializer:comment', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", links: { comments: '/posts/1/comments' } });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ _ID_: 1, _NAME_: \"FIRST\" }, { _ID_: 2, _NAME_: \"Rails is unagi\" }, { _ID_: 3, _NAME_: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\n//test(\"creating a record with a 422 error marks the records as invalid\", function(){\n  //expect(1);\n\n  //var mockXHR = {\n    //status:       422,\n    //responseText: JSON.stringify({ errors: { name: [\"can't be blank\"]} })\n  //};\n\n  //jQuery.ajax = function(hash) {\n    //hash.error.call(hash.context, mockXHR, \"Unprocessable Entity\");\n  //};\n\n  //var post = store.createRecord(Post, { name: \"\" });\n\n  //post.on(\"becameInvalid\", function() {\n    //ok(true, \"becameInvalid is called\");\n  //});\n\n  //post.on(\"becameError\", function() {\n    //ok(false, \"becameError is not called\");\n  //});\n\n  //post.save();\n//});\n\n//test(\"changing A=>null=>A should clean up the record\", function() {\n  //var store = DS.Store.create({\n    //adapter: DS.RESTAdapter\n  //});\n  //var Kidney = DS.Model.extend();\n  //var Person = DS.Model.extend();\n\n  //Kidney.reopen({\n    //person: DS.belongsTo(Person)\n  //});\n  //Kidney.toString = function() { return \"Kidney\"; };\n\n  //Person.reopen({\n    //name: DS.attr('string'),\n    //kidneys: DS.hasMany(Kidney)\n  //});\n  //Person.toString = function() { return \"Person\"; };\n\n  //store.load(Person, { id: 1, kidneys: [1, 2] });\n  //store.load(Kidney, { id: 1, person: 1 });\n  //store.load(Kidney, { id: 2, person: 1 });\n\n  //var person = store.find(Person, 1);\n  //var kidney1 = store.find(Kidney, 1);\n  //var kidney2 = store.find(Kidney, 2);\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney1, kidney2], \"precond - person should have both kidneys\");\n  //equal(kidney1.get('person'), person, \"precond - first kidney should be in the person\");\n\n  //person.get('kidneys').removeObject(kidney1);\n\n  //ok(person.get('isDirty'), \"precond - person should be dirty after operation\");\n  //ok(kidney1.get('isDirty'), \"precond - first kidney should be dirty after operation\");\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney2], \"precond - person should have only the second kidney\");\n  //equal(kidney1.get('person'), null, \"precond - first kidney should be on the operating table\");\n\n  //person.get('kidneys').addObject(kidney1);\n\n  //ok(!person.get('isDirty'), \"person should be clean after restoration\");\n  //ok(!kidney1.get('isDirty'), \"first kidney should be clean after restoration\");\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney2, kidney1], \"person should have both kidneys again\");\n  //equal(kidney1.get('person'), person, \"first kidney should be in the person again\");\n//});\n\n//test(\"changing A=>B=>A should clean up the record\", function() {\n  //var store = DS.Store.create({\n    //adapter: DS.RESTAdapter\n  //});\n  //var Kidney = DS.Model.extend();\n  //var Person = DS.Model.extend();\n\n  //Kidney.reopen({\n    //person: DS.belongsTo(Person)\n  //});\n  //Kidney.toString = function() { return \"Kidney\"; };\n\n  //Person.reopen({\n    //name: DS.attr('string'),\n    //kidneys: DS.hasMany(Kidney)\n  //});\n  //Person.toString = function() { return \"Person\"; };\n\n  //store.load(Person, { person: { id: 1, name: \"John Doe\", kidneys: [1, 2] }});\n  //store.load(Person, { person: { id: 2, name: \"Jane Doe\", kidneys: [3]} });\n  //store.load(Kidney, { kidney: { id: 1, person_id: 1 } });\n  //store.load(Kidney, { kidney: { id: 2, person_id: 1 } });\n  //store.load(Kidney, { kidney: { id: 3, person_id: 2 } });\n\n  //var john = store.find(Person, 1);\n  //var jane = store.find(Person, 2);\n  //var kidney1 = store.find(Kidney, 1);\n  //var kidney2 = store.find(Kidney, 2);\n  //var kidney3 = store.find(Kidney, 3);\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1, kidney2], \"precond - john should have the first two kidneys\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3], \"precond - jane should have the third kidney\");\n  //equal(kidney2.get('person'), john, \"precond - second kidney should be in john\");\n\n  //kidney2.set('person', jane);\n\n  //ok(john.get('isDirty'), \"precond - john should be dirty after operation\");\n  //ok(jane.get('isDirty'), \"precond - jane should be dirty after operation\");\n  //ok(kidney2.get('isDirty'), \"precond - second kidney should be dirty after operation\");\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1], \"precond - john should have only the first kidney\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3, kidney2], \"precond - jane should have the other two kidneys\");\n  //equal(kidney2.get('person'), jane, \"precond - second kidney should be in jane\");\n\n  //kidney2.set('person', john);\n\n  //ok(!john.get('isDirty'), \"john should be clean after restoration\");\n  //ok(!jane.get('isDirty'), \"jane should be clean after restoration\");\n  //ok(!kidney2.get('isDirty'), \"second kidney should be clean after restoration\");\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1, kidney2], \"john should have the first two kidneys again\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3], \"jane should have the third kidney again\");\n  //equal(kidney2.get('person'), john, \"second kidney should be in john again\");\n//});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/rest_adapter_test");minispade.register('ember-data/~tests/integration/adapter/store_adapter_test', "(function() {/**\n This is an integration test that tests the communication between a store\n and its adapter.\n\n Typically, when a method is invoked on the store, it calls a related\n method on its adapter. The adapter notifies the store that it has\n completed the assigned task, either synchronously or asynchronously,\n by calling a method on the store.\n\n These tests ensure that the proper methods get called, and, if applicable,\n the given record orrecord arrayay changes state appropriately.\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar Person, Dog, env, store, adapter;\n\nmodule(\"integration/adapter/store_adapter - DS.Store and DS.Adapter integration test\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    Dog = DS.Model.extend({\n      name: DS.attr('string')\n    });\n\n    env = setupStore({ person: Person, dog: Dog });\n    store = env.store;\n    adapter = env.adapter;\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\n\ntest(\"Records loaded multiple times and retrieved in recordArray are ready to send state events\", function() {\n  adapter.findQuery = function(store, type, query, recordArray) {\n    return Ember.RSVP.resolve([{\n      id: 1,\n      name: \"Mickael Ramírez\"\n    }, {\n      id: 2,\n      name: \"Johny Fontana\"\n    }]);\n  };\n\n  store.findQuery('person', {q: 'bla'}).then(async(function(people) {\n    var people2 = store.findQuery('person', { q: 'bla2' });\n\n    return Ember.RSVP.hash({ people: people, people2: people2 });\n  })).then(async(function(results) {\n    equal(results.people2.get('length'), 2, 'return the elements' );\n    ok( results.people2.get('isLoaded'), 'array is loaded' );\n\n    var person = results.people.objectAt(0);\n    ok(person.get('isLoaded'), 'record is loaded');\n\n    // delete record will not throw exception\n    person.deleteRecord();\n  }));\n\n});\n\ntest(\"by default, createRecords calls createRecord once per record\", function() {\n  var count = 1;\n\n  adapter.createRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 1) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 2) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not have invoked more than 2 times\");\n    }\n\n    var hash = get(record, 'data');\n    hash.id = count;\n    hash.updatedAt = \"now\";\n\n    count++;\n    return Ember.RSVP.resolve(hash);\n  };\n\n  var tom = store.createRecord('person', { name: \"Tom Dale\" });\n  var yehuda = store.createRecord('person', { name: \"Yehuda Katz\" });\n\n  Ember.RSVP.hash({ tom: tom.save(), yehuda: yehuda.save() }).then(async(function(records) {\n    tom = records.tom;\n    yehuda = records.yehuda;\n\n    asyncEqual(tom, store.find('person', 1), \"Once an ID is in, find returns the same object\");\n    asyncEqual(yehuda, store.find('person', 2), \"Once an ID is in, find returns the same object\");\n    equal(get(tom, 'updatedAt'), \"now\", \"The new information is received\");\n    equal(get(yehuda, 'updatedAt'), \"now\", \"The new information is received\");\n  }));\n});\n\ntest(\"by default, updateRecords calls updateRecord once per record\", function() {\n  var count = 0;\n\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n\n    equal(record.get('isSaving'), true, \"record is saving\");\n\n    return Ember.RSVP.resolve();\n  };\n\n  store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n  store.push('person', { id: 2, name: \"Brohuda Katz\" });\n\n  Ember.RSVP.hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    set(tom, \"name\", \"Tom Dale\");\n    set(yehuda, \"name\", \"Yehuda Katz\");\n\n    return Ember.RSVP.hash({ tom: tom.save(), yehuda: yehuda.save() });\n  })).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    equal(tom.get('isSaving'), false, \"record is no longer saving\");\n    equal(tom.get('isLoaded'), true, \"record is loaded\");\n\n    equal(yehuda.get('isSaving'), false, \"record is no longer saving\");\n    equal(yehuda.get('isLoaded'), true, \"record is loaded\");\n  }));\n});\n\ntest(\"calling store.didSaveRecord can provide an optional hash\", function() {\n  var count = 0;\n\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    count++;\n    if (count === 1) {\n      equal(get(record, 'name'), \"Tom Dale\");\n      return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", updatedAt: \"now\" });\n    } else if (count === 2) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n      return Ember.RSVP.resolve({ id: 2, name: \"Yehuda Katz\", updatedAt: \"now!\" });\n    } else {\n      ok(false, \"should not get here\");\n    }\n  };\n\n  store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n  store.push('person', { id: 2, name: \"Brohuda Katz\" });\n\n  Ember.RSVP.hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    set(tom, \"name\", \"Tom Dale\");\n    set(yehuda, \"name\", \"Yehuda Katz\");\n\n    return Ember.RSVP.hash({ tom: tom.save(), yehuda: yehuda.save() });\n  })).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    equal(get(tom, 'isDirty'), false, \"the record should not be dirty\");\n    equal(get(tom, 'updatedAt'), \"now\", \"the hash was updated\");\n\n    equal(get(yehuda, 'isDirty'), false, \"the record should not be dirty\");\n    equal(get(yehuda, 'updatedAt'), \"now!\", \"the hash was updated\");\n  }));\n});\n\ntest(\"by default, deleteRecords calls deleteRecord once per record\", function() {\n  expect(4);\n\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n\n    return Ember.RSVP.resolve();\n  };\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n  store.push('person', { id: 2, name: \"Yehuda Katz\" });\n\n  Ember.RSVP.hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    tom.deleteRecord();\n    yehuda.deleteRecord();\n\n    tom.save();\n    yehuda.save();\n  }));\n});\n\ntest(\"if an existing model is edited then deleted, deleteRecord is called on the adapter\", function() {\n  expect(5);\n\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    count++;\n    equal(get(record, 'id'), 'deleted-record', \"should pass correct record to deleteRecord\");\n    equal(count, 1, \"should only call deleteRecord method of adapter once\");\n\n    return Ember.RSVP.resolve();\n  };\n\n  adapter.updateRecord = function() {\n    ok(false, \"should not have called updateRecord method of adapter\");\n  };\n\n  // Load data for a record into the store.\n  store.push('person', { id: 'deleted-record', name: \"Tom Dale\" });\n\n  // Retrieve that loaded record and edit it so it becomes dirty\n  store.find('person', 'deleted-record').then(async(function(tom) {\n    tom.set('name', \"Tom Mothereffin' Dale\");\n\n    equal(get(tom, 'isDirty'), true, \"precond - record should be dirty after editing\");\n\n    tom.deleteRecord();\n    return tom.save();\n  })).then(async(function(tom) {\n    equal(get(tom, 'isDirty'), false, \"record should not be dirty\");\n    equal(get(tom, 'isDeleted'), true, \"record should be considered deleted\");\n  }));\n});\n\ntest(\"if a created record is marked as invalid by the server, it enters an error state\", function() {\n  adapter.createRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (get(record, 'name').indexOf('Bro') === -1) {\n      return Ember.RSVP.reject(new DS.InvalidError({ name: ['common... name requires a \"bro\"'] }));\n    } else {\n      return Ember.RSVP.resolve();\n    }\n  };\n\n  var yehuda = store.createRecord('person', { id: 1, name: \"Yehuda Katz\" });\n\n  // Wrap this in an Ember.run so that all chained async behavior is set up\n  // before flushing any scheduled behavior.\n  Ember.run(function() {\n    yehuda.save().then(null, async(function(error) {\n      equal(get(yehuda, 'isValid'), false, \"the record is invalid\");\n      ok(get(yehuda, 'errors.name'), \"The errors.name property exists\");\n\n      set(yehuda, 'updatedAt', true);\n      equal(get(yehuda, 'isValid'), false, \"the record is still invalid\");\n\n      // This tests that we handle undefined values without blowing up\n      var errors = get(yehuda, 'errors');\n      set(errors, 'other_bound_property', undefined);\n      set(yehuda, 'errors', errors);\n      set(yehuda, 'name', \"Brohuda Brokatz\");\n\n      equal(get(yehuda, 'isValid'), true, \"the record is no longer invalid after changing\");\n      equal(get(yehuda, 'isDirty'), true, \"the record has outstanding changes\");\n\n      equal(get(yehuda, 'isNew'), true, \"precond - record is still new\");\n\n      return yehuda.save();\n    })).then(async(function(person) {\n      strictEqual(person, yehuda, \"The promise resolves with the saved record\");\n\n      equal(get(yehuda, 'isValid'), true, \"record remains valid after committing\");\n      equal(get(yehuda, 'isNew'), false, \"record is no longer new\");\n    }));\n  });\n});\n\ntest(\"if a created record is marked as erred by the server, it enters an error state\", function() {\n  adapter.createRecord = function(store, type, record) {\n    return Ember.RSVP.reject();\n  };\n\n  Ember.run(function() {\n    var person = store.createRecord('person', { id: 1, name: \"John Doe\" });\n\n    person.save().then(null, async(function() {\n      ok(get(person, 'isError'), \"the record is in the error state\");\n    }));\n  });\n});\n\ntest(\"if an updated record is marked as invalid by the server, it enters an error state\", function() {\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (get(record, 'name').indexOf('Bro') === -1) {\n      return Ember.RSVP.reject(new DS.InvalidError({ name: ['common... name requires a \"bro\"'] }));\n    } else {\n      return Ember.RSVP.resolve();\n    }\n  };\n\n  var yehuda = store.push('person', { id: 1, name: \"Brohuda Brokatz\" });\n\n  Ember.run(function() {\n    store.find('person', 1).then(async(function(person) {\n      equal(person, yehuda, \"The same object is passed through\");\n\n      equal(get(yehuda, 'isValid'), true, \"precond - the record is valid\");\n      set(yehuda, 'name', \"Yehuda Katz\");\n      equal(get(yehuda, 'isValid'), true, \"precond - the record is still valid as far as we know\");\n\n      equal(get(yehuda, 'isDirty'), true, \"the record is dirty\");\n\n      return yehuda.save();\n    })).then(null, async(function(reason) {\n      equal(get(yehuda, 'isDirty'), true, \"the record is still dirty\");\n      equal(get(yehuda, 'isValid'), false, \"the record is invalid\");\n\n      set(yehuda, 'updatedAt', true);\n      equal(get(yehuda, 'isValid'), false, \"the record is still invalid\");\n\n      set(yehuda, 'name', \"Brohuda Brokatz\");\n      equal(get(yehuda, 'isValid'), true, \"the record is no longer invalid after changing\");\n      equal(get(yehuda, 'isDirty'), true, \"the record has outstanding changes\");\n\n      return yehuda.save();\n    })).then(async(function(yehuda) {\n      equal(get(yehuda, 'isValid'), true, \"record remains valid after committing\");\n      equal(get(yehuda, 'isDirty'), false, \"record is no longer new\");\n    }));\n  });\n});\n\ntest(\"if a updated record is marked as erred by the server, it enters an error state\", function() {\n  adapter.updateRecord = function(store, type, record) {\n    return Ember.RSVP.reject();\n  };\n\n  var person = store.push(Person, { id: 1, name: \"John Doe\" });\n\n  store.find('person', 1).then(async(function(record) {\n    equal(record, person, \"The person was resolved\");\n    person.set('name', \"Jonathan Doe\");\n    return person.save();\n  })).then(null, async(function(reason) {\n    ok(get(person, 'isError'), \"the record is in the error state\");\n  }));\n});\n\ntest(\"can be created after the DS.Store\", function() {\n  expect(1);\n\n  adapter.find = function(store, type) {\n    equal(type, Person, \"the type is correct\");\n    return Ember.RSVP.resolve({ id: 1 });\n  };\n\n  store.find('person', 1);\n});\n\ntest(\"the filter method can optionally take a server query as well\", function() {\n  adapter.findQuery = function(store, type, query, array) {\n    return Ember.RSVP.resolve([\n      { id: 1, name: \"Yehuda Katz\" },\n      { id: 2, name: \"Tom Dale\" }\n    ]);\n  };\n\n  var asyncFilter = store.filter('person', { page: 1 }, function(data) {\n    return data.get('name') === \"Tom Dale\";\n  });\n\n  var loadedFilter;\n\n  asyncFilter.then(async(function(filter) {\n    loadedFilter = filter;\n    return store.find('person', 2);\n  })).then(async(function(tom) {\n    equal(get(loadedFilter, 'length'), 1, \"The filter has an item in it\");\n    deepEqual(loadedFilter.toArray(), [ tom ], \"The filter has a single entry in it\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/store_adapter_test");minispade.register('ember-data/~tests/integration/application_test', "(function() {var app, container;\n\n/**\n  These tests ensure that Ember Data works with Ember.js' application\n  initialization and dependency injection APIs.\n*/\n\nmodule(\"integration/application - Injecting a Custom Store\", {\n  setup: function() {\n    Ember.run(function() {\n      app = Ember.Application.create({\n        Store: DS.Store.extend({ isCustom: true }),\n        FooController: Ember.Controller.extend(),\n        ApplicationView: Ember.View.extend(),\n        BazController: {},\n        ApplicationController: Ember.View.extend()\n      });\n    });\n\n    container = app.__container__;\n  },\n\n  teardown: function() {\n    app.destroy();\n    Ember.BOOTED = false;\n  }\n});\n\ntest(\"If a Store property exists on an Ember.Application, it should be instantiated.\", function() {\n  ok(container.lookup('store:main').get('isCustom'), \"the custom store was instantiated\");\n});\n\ntest(\"If a store is instantiated, it should be made available to each controller.\", function() {\n  var fooController = container.lookup('controller:foo');\n  ok(fooController.get('store.isCustom'), \"the custom store was injected\");\n});\n\nmodule(\"integration/application - Injecting the Default Store\", {\n  setup: function() {\n    Ember.run(function() {\n      app = Ember.Application.create({\n        FooController: Ember.Controller.extend(),\n        ApplicationView: Ember.View.extend(),\n        BazController: {},\n        ApplicationController: Ember.View.extend()\n      });\n    });\n\n    container = app.__container__;\n  },\n\n  teardown: function() {\n    app.destroy();\n    Ember.BOOTED = false;\n  }\n});\n\ntest(\"If a Store property exists on an Ember.Application, it should be instantiated.\", function() {\n  ok(container.lookup('store:main') instanceof DS.Store, \"the store was instantiated\");\n});\n\ntest(\"If a store is instantiated, it should be made available to each controller.\", function() {\n  var fooController = container.lookup('controller:foo');\n  ok(fooController.get('store') instanceof DS.Store, \"the store was injected\");\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/application_test");minispade.register('ember-data/~tests/integration/client_id_generation_test', "(function() {var get = Ember.get, set = Ember.set;\nvar serializer, adapter, store;\nvar Post, Comment, env;\n\nmodule(\"integration/client_id_generation - Client-side ID Generation\", {\n  setup: function() {\n    Comment = DS.Model.extend({\n      post: DS.belongsTo('post')\n    });\n\n    Post = DS.Model.extend({\n      comments: DS.hasMany('comment')\n    });\n\n    env = setupStore({\n      post: Post,\n      comment: Comment\n    });\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"If an adapter implements the `generateIdForRecord` method, the store should be able to assign IDs without saving to the persistence layer.\", function() {\n  expect(6);\n\n  var idCount = 1;\n\n  env.adapter.generateIdForRecord = function(passedStore, record) {\n    equal(env.store, passedStore, \"store is the first parameter\");\n\n    return \"id-\" + idCount++;\n  };\n\n  env.adapter.createRecord = function(store, type, record) {\n    if (type === Comment) {\n      equal(get(record, 'id'), 'id-1', \"Comment passed to `createRecord` has 'id-1' assigned\");\n      return Ember.RSVP.resolve();\n    } else {\n      equal(get(record, 'id'), 'id-2', \"Post passed to `createRecord` has 'id-2' assigned\");\n      return Ember.RSVP.resolve();\n    }\n  };\n\n  var comment = env.store.createRecord('comment');\n  var post = env.store.createRecord('post');\n\n  equal(get(comment, 'id'), 'id-1', \"comment is assigned id 'id-1'\");\n  equal(get(post, 'id'), 'id-2', \"post is assigned id 'id-2'\");\n\n  // Despite client-generated IDs, calling commit() on the store should still\n  // invoke the adapter's `createRecord` method.\n  comment.save();\n  post.save();\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/client_id_generation_test");minispade.register('ember-data/~tests/integration/debug_adapter_test', "(function() {var App, store, debugAdapter, get = Ember.get;\n\nmodule(\"DS.DebugAdapter\", {\n  setup: function() {\n    Ember.run(function() {\n      App = Ember.Application.create({\n        toString: function() { return 'App'; }\n      });\n\n      App.Store = DS.Store.extend({\n        adapter: DS.Adapter.create()\n      });\n\n      App.Post = DS.Model.extend({\n        title: DS.attr('string')\n      });\n\n      App.advanceReadiness();\n    });\n\n    store = App.__container__.lookup('store:main');\n    debugAdapter = App.__container__.lookup('dataAdapter:main');\n\n    debugAdapter.reopen({\n      getModelTypes: function() {\n        return [App.Post];\n      }\n    });\n  },\n  teardown: function() {\n    App.destroy();\n  }\n});\n\ntest(\"Watching Model Types\", function() {\n  expect(5);\n\n  var added = function(types) {\n    equal(types.length, 1);\n    equal(types[0].name, 'App.Post');\n    equal(types[0].count, 0);\n    strictEqual(types[0].object, App.Post);\n  };\n\n  var updated = function(types) {\n    equal(types[0].count, 1);\n  };\n\n  debugAdapter.watchModelTypes(added, updated);\n\n  store.push('post', {id: 1, title: 'Post Title'});\n});\n\ntest(\"Watching Records\", function() {\n  var post, args, record;\n\n  Ember.run(function() {\n    store.push('post', { id: '1', title: 'Clean Post'});\n  });\n\n  var callback = function() {\n    args = arguments;\n  };\n\n  debugAdapter.watchRecords(App.Post, callback, callback, callback);\n\n  equal(get(args[0], 'length'), 1);\n  record = args[0][0];\n  deepEqual(record.columnValues, { id: '1', title: 'Clean Post'} );\n  deepEqual(record.filterValues, { isNew: false, isModified: false, isClean: true } );\n  deepEqual(record.searchKeywords, ['1', 'Clean Post'] );\n  deepEqual(record.color, 'black' );\n\n  Ember.run(function() {\n    post = store.find('post', 1);\n  });\n\n  Ember.run(function() {\n    post.set('title', 'Modified Post');\n  });\n\n  record = args[0][0];\n  deepEqual(record.columnValues, { id: '1', title: 'Modified Post'});\n  deepEqual(record.filterValues, { isNew: false, isModified: true, isClean: false });\n  deepEqual(record.searchKeywords, ['1', 'Modified Post'] );\n  deepEqual(record.color, 'blue' );\n\n  post = store.createRecord('post', { id: '2', title: 'New Post' });\n  record = args[0][0];\n  deepEqual(record.columnValues, { id: '2', title: 'New Post'});\n  deepEqual(record.filterValues, { isNew: true, isModified: false, isClean: false });\n  deepEqual(record.searchKeywords, ['2', 'New Post'] );\n  deepEqual(record.color, 'green' );\n\n  Ember.run(post, 'deleteRecord');\n\n  var index = args[0];\n  var count = args[1];\n  equal(index, 1);\n  equal(count, 1);\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/debug_adapter_test");minispade.register('ember-data/~tests/integration/filter_test', "(function() {var get = Ember.get, set = Ember.set;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar indexOf = Ember.EnumerableUtils.indexOf;\n\nvar Person, store, env, array, recordArray;\n\nvar shouldContain = function(array, item) {\n  ok(indexOf(array, item) !== -1, \"array should contain \"+item.get('name'));\n};\n\nvar shouldNotContain = function(array, item) {\n  ok(indexOf(array, item) === -1, \"array should not contain \"+item.get('name'));\n};\n\nmodule(\"integration/filter - DS.Model updating\", {\n  setup: function() {\n    array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n    Person = DS.Model.extend({ name: DS.attr('string') });\n\n    env = setupStore({ person: Person });\n    store = env.store;\n  },\n  teardown: function() {\n    store.destroy();\n    Person = null;\n    array = null;\n  }\n});\n\ntest(\"when a DS.Model updates its attributes, its changes affect its filtered Array membership\", function() {\n  store.pushMany('person', array);\n\n  var people = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Katz$/)) { return true; }\n  });\n\n  equal(get(people, 'length'), 1, \"precond - one item is in the RecordArray\");\n\n  var person = people.objectAt(0);\n\n  equal(get(person, 'name'), \"Scumbag Katz\", \"precond - the item is correct\");\n\n  set(person, 'name', \"Yehuda Katz\");\n\n  equal(get(people, 'length'), 1, \"there is still one item\");\n  equal(get(person, 'name'), \"Yehuda Katz\", \"it has the updated item\");\n\n  set(person, 'name', \"Yehuda Katz-Foo\");\n\n  equal(get(people, 'length'), 0, \"there are now no items\");\n});\n\ntest(\"a record array can have a filter on it\", function() {\n  store.pushMany('person', array);\n\n  var recordArray = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array should have the filtered objects on it\");\n\n  store.push('person', { id: 4, name: \"Scumbag Koz\" });\n\n  equal(get(recordArray, 'length'), 3, \"The Record Array should be updated as new items are added to the store\");\n\n  store.push('person', { id: 1, name: \"Scumbag Tom\" });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array should be updated as existing members are updated\");\n});\n\ntest(\"a filtered record array includes created elements\", function() {\n  store.pushMany('person', array);\n\n  var recordArray = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 2, \"precond - The Record Array should have the filtered objects on it\");\n\n  store.createRecord('person', { name: \"Scumbag Koz\" });\n\n  equal(get(recordArray, 'length'), 3, \"The record array has the new object on it\");\n});\n\ntest(\"a Record Array can update its filter\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    deleteRecord: function(store, type, record) {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  store.pushMany('person', array);\n\n  var dickens = store.createRecord('person', { id: 4, name: \"Scumbag Dickens\" });\n  dickens.deleteRecord();\n\n  var asyncDale = store.find('person', 1);\n  var asyncKatz = store.find('person', 2);\n  var asyncBryn = store.find('person', 3);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  Ember.RSVP.hash({ dale: asyncDale, katz: asyncKatz, bryn: asyncBryn }).then(async(function(records) {\n    shouldContain(recordArray, records.dale);\n    shouldContain(recordArray, records.katz);\n    shouldNotContain(recordArray, records.bryn);\n    shouldNotContain(recordArray, dickens);\n\n    recordArray.set('filterFunction', function(hash) {\n      if (hash.get('name').match(/Katz/)) { return true; }\n    });\n\n    equal(get(recordArray, 'length'), 1, \"The Record Array should have one object on it\");\n\n    Ember.run(function() {\n      store.push('person', { id: 5, name: \"Other Katz\" });\n    });\n\n    equal(get(recordArray, 'length'), 2, \"The Record Array now has the new object matching the filter\");\n\n    Ember.run(function() {\n      store.push('person', { id: 6, name: \"Scumbag Demon\" });\n    });\n\n    equal(get(recordArray, 'length'), 2, \"The Record Array doesn't have objects matching the old filter\");\n  }));\n});\n\ntest(\"a Record Array can update its filter and notify array observers\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    deleteRecord: function(store, type, record) {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  store.pushMany('person', array);\n\n  var dickens = store.createRecord('person', { id: 4, name: \"Scumbag Dickens\" });\n  dickens.deleteRecord();\n\n  var asyncDale = store.find('person', 1);\n  var asyncKatz = store.find('person', 2);\n  var asyncBryn = store.find('person', 3);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  var didChangeIdx, didChangeRemoved = 0, didChangeAdded = 0;\n\n  var arrayObserver = {\n    arrayWillChange: Ember.K,\n\n    arrayDidChange: function(array, idx, removed, added) {\n      didChangeIdx = idx;\n      didChangeRemoved += removed;\n      didChangeAdded += added;\n    }\n  };\n\n  recordArray.addArrayObserver(arrayObserver);\n\n  recordArray.set('filterFunction', function(hash) {\n    if (hash.get('name').match(/Katz/)) { return true; }\n  });\n\n  Ember.RSVP.all([ asyncDale, asyncKatz, asyncBryn ]).then(async(function() {\n    equal(didChangeRemoved, 1, \"removed one item from array\");\n    didChangeRemoved = 0;\n\n    Ember.run(function() {\n      store.push('person', { id: 5, name: \"Other Katz\" });\n    });\n\n    equal(didChangeAdded, 1, \"one item was added\");\n    didChangeAdded = 0;\n\n    equal(recordArray.objectAt(didChangeIdx).get('name'), \"Other Katz\");\n\n    Ember.run(function() {\n      store.push('person', { id: 6, name: \"Scumbag Demon\" });\n    });\n\n    equal(didChangeAdded, 0, \"did not get called when an object that doesn't match is added\");\n\n    Ember.run(function() {\n      recordArray.set('filterFunction', function(hash) {\n        if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n      });\n    });\n\n    equal(didChangeAdded, 2, \"one item is added when going back\");\n    equal(recordArray.objectAt(didChangeIdx).get('name'), \"Scumbag Demon\");\n    equal(recordArray.objectAt(didChangeIdx-1).get('name'), \"Scumbag Dale\");\n  }));\n});\n\ntest(\"it is possible to filter by computed properties\", function() {\n  Person.reopen({\n    name: DS.attr('string'),\n    upperName: Ember.computed(function() {\n      return this.get('name').toUpperCase();\n    }).property('name')\n  });\n\n  var filter = store.filter('person', function(person) {\n    return person.get('upperName') === \"TOM DALE\";\n  });\n\n  equal(filter.get('length'), 0, \"precond - the filter starts empty\");\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  equal(filter.get('length'), 1, \"the filter now has a record in it\");\n\n  store.find('person', 1).then(async(function(person) {\n    Ember.run(function() {\n      person.set('name', \"Yehuda Katz\");\n    });\n\n    equal(filter.get('length'), 0, \"the filter is empty again\");\n  }));\n});\n\ntest(\"a filter created after a record is already loaded works\", function() {\n  Person.reopen({\n    name: DS.attr('string'),\n    upperName: Ember.computed(function() {\n      return this.get('name').toUpperCase();\n    }).property('name')\n  });\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  var filter = store.filter('person', function(person) {\n    return person.get('upperName') === \"TOM DALE\";\n  });\n\n  equal(filter.get('length'), 1, \"the filter now has a record in it\");\n  asyncEqual(filter.objectAt(0), store.find('person', 1));\n});\n\ntest(\"it is possible to filter by state flags\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    find: function(store, type, id) {\n      return Ember.RSVP.resolve({ id: id, name: \"Tom Dale\" });\n    }\n  }));\n\n  var filter = store.filter(Person, function(person) {\n    return person.get('isLoaded');\n  });\n\n  equal(filter.get('length'), 0, \"precond - there are no records yet\");\n\n  Ember.run(function() {\n    var asyncPerson = store.find('person', 1);\n\n    // Ember.run will block `find` from being synchronously\n    // resolved in test mode\n\n    equal(filter.get('length'), 0, \"the unloaded record isn't in the filter\");\n\n    asyncPerson.then(async(function(person) {\n      equal(filter.get('length'), 1, \"the now-loaded record is in the filter\");\n      asyncEqual(filter.objectAt(0), store.find('person', 1));\n    }));\n  });\n});\n\ntest(\"it is possible to filter loaded records by dirtiness\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    updateRecord: function() {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  var filter = store.filter('person', function(person) {\n    return !person.get('isDirty');\n  });\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(filter.get('length'), 1, \"the clean record is in the filter\");\n\n    // Force synchronous update of the filter, even though\n    // we're already inside a run loop\n    Ember.run(function() {\n      person.set('name', \"Yehuda Katz\");\n    });\n\n    equal(filter.get('length'), 0, \"the now-dirty record is not in the filter\");\n\n    return person.save();\n  })).then(async(function(person) {\n    equal(filter.get('length'), 1, \"the clean record is back in the filter\");\n  }));\n});\n\ntest(\"it is possible to filter created records by dirtiness\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    createRecord: function() {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  var filter = store.filter('person', function(person) {\n    return !person.get('isDirty');\n  });\n\n  var person = store.createRecord('person', {\n    id: 1,\n    name: \"Tom Dale\"\n  });\n\n  equal(filter.get('length'), 0, \"the dirty record is not in the filter\");\n\n  person.save().then(async(function(person) {\n    equal(filter.get('length'), 1, \"the clean record is in the filter\");\n  }));\n});\n\n\n// SERVER SIDE TESTS\nvar edited;\n\nvar clientEdits = function(ids) {\n  edited = [];\n\n  forEach(ids, function(id) {\n    // wrap in an Ember.run to guarantee coalescence of the\n    // iterated `set` calls and promise resolution.\n    Ember.run(function() {\n      store.find('person', id).then(function(person) {\n        edited.push(person);\n        person.set('name', 'Client-side ' + id );\n      });\n    });\n  });\n};\n\nvar clientCreates = function(names) {\n  edited = [];\n\n  // wrap in an Ember.run to guarantee coalescence of the\n  // iterated `set` calls.\n  Ember.run( function() {\n    forEach(names, function( name ) {\n      edited.push(store.createRecord('person', { name: 'Client-side ' + name }));\n    });\n  });\n};\n\nvar serverResponds = function(){\n  edited.forEach(function(person) { person.save(); });\n};\n\nvar setup = function(serverCallbacks) {\n  set(store, 'adapter', DS.Adapter.create(serverCallbacks));\n\n  store.pushMany('person', array);\n\n  recordArray = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Scumbag/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 3, \"The filter function should work\");\n};\n\ntest(\"a Record Array can update its filter after server-side updates one record\", function() {\n  setup({\n    updateRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({id: 1, name: \"Scumbag Server-side Dale\"});\n    }\n  });\n\n  clientEdits([1]);\n  equal(get(recordArray, 'length'), 2, \"The record array updates when the client changes records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 3, \"The record array updates when the server changes one record\");\n});\n\ntest(\"a Record Array can update its filter after server-side updates multiple records\", function() {\n  setup({\n    updateRecord: function(store, type, record) {\n      switch (record.get('id')) {\n        case \"1\":\n          return Ember.RSVP.resolve({ id: 1, name: \"Scumbag Server-side Dale\" });\n        case \"2\":\n          return Ember.RSVP.resolve({ id: 2, name: \"Scumbag Server-side Katz\" });\n      }\n    }\n  });\n\n  clientEdits([1,2]);\n  equal(get(recordArray, 'length'), 1, \"The record array updates when the client changes records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 3, \"The record array updates when the server changes multiple records\");\n});\n\ntest(\"a Record Array can update its filter after server-side creates one record\", function() {\n  setup({\n    createRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({id: 4, name: \"Scumbag Server-side Tim\"});\n    }\n  });\n\n  clientCreates([\"Tim\"]);\n  equal(get(recordArray, 'length'), 3, \"The record array does not include non-matching records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 4, \"The record array updates when the server creates a record\");\n});\n\ntest(\"a Record Array can update its filter after server-side creates multiple records\", function() {\n  setup({\n    createRecord: function(store, type, record) {\n      switch (record.get('name')) {\n        case \"Client-side Mike\":\n          return Ember.RSVP.resolve({id: 4, name: \"Scumbag Server-side Mike\"});\n        case \"Client-side David\":\n          return Ember.RSVP.resolve({id: 5, name: \"Scumbag Server-side David\"});\n      }\n    }\n  });\n\n  clientCreates([\"Mike\", \"David\"]);\n  equal(get(recordArray, 'length'), 3, \"The record array does not include non-matching records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 5, \"The record array updates when the server creates multiple records\");\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/filter_test");minispade.register('ember-data/~tests/integration/lifecycle_hooks_test', "(function() {var Person, env;\nvar attr = DS.attr;\nvar resolve = Ember.RSVP.resolve;\n\nmodule(\"integration/lifecycle_hooks - Lifecycle Hooks\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      name: attr('string')\n    });\n\n    env = setupStore({\n      person: Person\n    });\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\nasyncTest(\"When the adapter acknowledges that a record has been created, a `didCreate` event is triggered.\", function() {\n  expect(3);\n\n  env.adapter.createRecord = function(store, type, record) {\n    return resolve({ id: 99, name: \"Yehuda Katz\" });\n  };\n\n  var person = env.store.createRecord(Person, { name: \"Yehuda Katz\" });\n\n  person.on('didCreate', function() {\n    equal(this, person, \"this is bound to the record\");\n    equal(this.get('id'), \"99\", \"the ID has been assigned\");\n    equal(this.get('name'), \"Yehuda Katz\", \"the attribute has been assigned\");\n    start();\n  });\n\n  person.save();\n});\n\ntest(\"When the adapter acknowledges that a record has been created without a new data payload, a `didCreate` event is triggered.\", function() {\n  expect(3);\n\n  env.adapter.createRecord = function(store, type, record) {\n    return Ember.RSVP.resolve();\n  };\n\n  var person = env.store.createRecord(Person, { id: 99, name: \"Yehuda Katz\" });\n\n  person.on('didCreate', function() {\n    equal(this, person, \"this is bound to the record\");\n    equal(this.get('id'), \"99\", \"the ID has been assigned\");\n    equal(this.get('name'), \"Yehuda Katz\", \"the attribute has been assigned\");\n  });\n\n  person.save();\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/lifecycle_hooks_test");minispade.register('ember-data/~tests/integration/records/reload_test', "(function() {var get = Ember.get, set = Ember.set;\nvar attr = DS.attr;\nvar Person, env;\n\nmodule(\"integration/reload - Reloading Records\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: attr('string'),\n      name: attr('string'),\n      firstName: attr('string'),\n      lastName: attr('string')\n    });\n\n    Person.toString = function() { return \"Person\"; };\n\n    env = setupStore({ person: Person });\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"When a single record is requested, the adapter's find method should be called unless it's loaded.\", function() {\n  var count = 0;\n\n  env.adapter.find = function(store, type, id) {\n    if (count === 0) {\n      count++;\n      return Ember.RSVP.resolve({ id: id, name: \"Tom Dale\" });\n    } else if (count === 1) {\n      count++;\n      return Ember.RSVP.resolve({ id: id, name: \"Braaaahm Dale\" });\n    } else {\n      ok(false, \"Should not get here\");\n    }\n  };\n\n  env.store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is loaded with the right name\");\n    equal(get(person, 'isLoaded'), true, \"The person is now loaded\");\n    var promise = person.reload();\n    equal(get(person, 'isReloading'), true, \"The person is now reloading\");\n    return promise;\n  })).then(async(function(person) {\n    equal(get(person, 'isReloading'), false, \"The person is no longer reloading\");\n    equal(get(person, 'name'), \"Braaaahm Dale\", \"The person is now updated with the right name\");\n  }));\n});\n\ntest(\"When a record is reloaded and fails, it can try again\", function() {\n  var tom = env.store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  var count = 0;\n  env.adapter.find = function(store, type, id) {\n    if (count++ === 0) {\n      return Ember.RSVP.reject();\n    } else {\n      return Ember.RSVP.resolve({ id: 1, name: \"Thomas Dale\" });\n    }\n  };\n\n  tom.reload().then(null, async(function() {\n    equal(tom.get('isError'), true, \"Tom is now errored\");\n    return tom.reload();\n  })).then(async(function(person) {\n    equal(person, tom, \"The resolved value is the record\");\n    equal(tom.get('isError'), false, \"Tom is no longer errored\");\n    equal(tom.get('name'), \"Thomas Dale\", \"the updates apply\");\n  }));\n});\n\ntest(\"When a record is loaded a second time, isLoaded stays true\", function() {\n  env.store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  env.store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'isLoaded'), true, \"The person is loaded\");\n    person.addObserver('isLoaded', isLoadedDidChange);\n\n    // Reload the record\n    env.store.push('person', { id: 1, name: \"Tom Dale\" });\n    equal(get(person, 'isLoaded'), true, \"The person is still loaded after load\");\n\n    person.removeObserver('isLoaded', isLoadedDidChange);\n  }));\n\n  function isLoadedDidChange() {\n    // This shouldn't be hit\n    equal(get(this, 'isLoaded'), true, \"The person is still loaded after change\");\n  }\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/records/reload_test");minispade.register('ember-data/~tests/integration/records/save_test', "(function() {var Comment, Post, env;\n\nmodule(\"integration/records/save - Save Record\", {\n  setup: function() {\n    var Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    Post.toString = function() { return \"Post\"; };\n\n    env = setupStore({ post: Post });\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"Will resolve save on success\", function() {\n  expect(1);\n  var post = env.store.createRecord('post', {title: 'toto'});\n\n  env.adapter.createRecord = function(store, type, record) {\n    return Ember.RSVP.resolve({ id: 123 });\n  };\n\n  post.save().then(async(function() {\n    ok(true, 'save operation was resolved');\n  }));\n});\n\ntest(\"Will reject save on error\", function() {\n  var post = env.store.createRecord('post', {title: 'toto'});\n\n  env.adapter.createRecord = function(store, type, record) {\n    return Ember.RSVP.reject();\n  };\n\n  post.save().then(function() {}, async(function() {\n    ok(true, 'save operation was rejected');\n  }));\n});\n\ntest(\"Retry is allowed in a failure handler\", function() {\n  var post = env.store.createRecord('post', {title: 'toto'});\n\n  var count = 0;\n\n  env.adapter.createRecord = function(store, type, record) {\n    if (count++ === 0) {\n      return Ember.RSVP.reject();\n    } else {\n      return Ember.RSVP.resolve({ id: 123 });\n    }\n  };\n\n  post.save().then(function() {}, async(function() {\n    return post.save();\n  })).then(async(function(post) {\n    equal(post.get('id'), '123', \"The post ID made it through\");\n  }));\n});\n\ntest(\"Will reject save on invalid\", function() {\n  expect(1);\n  var post = env.store.createRecord('post', {title: 'toto'});\n\n  env.adapter.createRecord = function(store, type, record) {\n    return Ember.RSVP.reject({ title: 'invalid' });\n  };\n\n  post.save().then(function() {}, async(function() {\n    ok(true, 'save operation was rejected');\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/records/save_test");minispade.register('ember-data/~tests/integration/relationships/belongs_to_test', "(function() {var env, store, User, Message, Post, Comment;\nvar get = Ember.get, set = Ember.set;\n\nvar attr = DS.attr, hasMany = DS.hasMany, belongsTo = DS.belongsTo;\nvar resolve = Ember.RSVP.resolve, hash = Ember.RSVP.hash;\n\nfunction stringify(string) {\n  return function() { return string; };\n}\n\nmodule(\"integration/relationship/belongs_to Belongs-To Relationships\", {\n  setup: function() {\n    User = DS.Model.extend({\n      name: attr('string'),\n      messages: hasMany('message', {polymorphic: true}),\n      favouriteMessage: belongsTo('message', {polymorphic: true})\n    });\n    User.toString = stringify('User');\n\n    Message = DS.Model.extend({\n      user: belongsTo('user'),\n      created_at: attr('date')\n    });\n    Message.toString = stringify('Message');\n\n    Post = Message.extend({\n      title: attr('string'),\n      comments: hasMany('comment')\n    });\n    Post.toString = stringify('Post');\n\n    Comment = Message.extend({\n      body: DS.attr('string'),\n      message: DS.belongsTo('message', { polymorphic: true })\n    });\n    Comment.toString = stringify('Comment');\n\n    env = setupStore({\n      user: User,\n      post: Post,\n      comment: Comment,\n      message: Message\n    });\n\n    env.container.register('serializer:user', DS.JSONSerializer.extend({\n      attrs: {\n        favouriteMessage: { embedded: 'always' }\n      }\n    }));\n\n    store = env.store;\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"The store can materialize a non loaded monomorphic belongsTo association\", function() {\n  expect(1);\n\n  env.store.modelFor('post').reopen({\n    user: DS.belongsTo('user', { async: true })\n  });\n\n  env.adapter.find = function(store, type, id) {\n    ok(true, \"The adapter's find method should be called\");\n    return Ember.RSVP.resolve({ id: 1 });\n  };\n\n  env.store.push('post', { id: 1, user: 2});\n\n  env.store.find('post', 1).then(async(function(post) {\n    post.get('user');\n  }));\n});\n\ntest(\"Only a record of the same type can be used with a monomorphic belongsTo relationship\", function() {\n  expect(1);\n\n  store.push('post', { id: 1 });\n  store.push('comment', { id: 2 });\n\n  hash({ post: store.find('post', 1), comment: store.find('comment', 2) }).then(async(function(records) {\n    expectAssertion(function() {\n      records.post.set('user', records.comment);\n    }, /You can only add a 'user' record to this relationship/);\n  }));\n});\n\ntest(\"Only a record of the same base type can be used with a polymorphic belongsTo relationship\", function() {\n  expect(1);\n  store.push('comment', { id: 1 });\n  store.push('comment', { id: 2 });\n  store.push('post', { id: 1 });\n  store.push('user', { id: 3 });\n\n  var asyncRecords = hash({\n    user: store.find('user', 3),\n    post: store.find('post', 1),\n    comment: store.find('comment', 1),\n    anotherComment: store.find('comment', 2)\n  });\n\n  asyncRecords.then(async(function(records) {\n    var comment = records.comment;\n\n    comment.set('message', records.anotherComment);\n    comment.set('message', records.post);\n    comment.set('message', null);\n\n    expectAssertion(function() {\n      comment.set('message', records.user);\n    }, /You can only add a 'message' record to this relationship/);\n  }));\n});\n\ntest(\"The store can load a polymorphic belongsTo association\", function() {\n  env.store.push('post', { id: 1 });\n  env.store.push('comment', { id: 2, message: 1, message_type: 'post' });\n\n  hash({ message: store.find('post', 1), comment: store.find('comment', 2) }).then(async(function(records) {\n    equal(records.comment.get('message'), records.message);\n  }));\n});\n\ntest(\"The store can serialize a polymorphic belongsTo association\", function() {\n  env.store.push('post', { id: 1 });\n  env.store.push('comment', { id: 2, message: 1, message_type: 'post' });\n\n  store.find('comment', 2).then(async(function(comment) {\n    var serialized = store.serialize(comment, { includeId: true });\n    equal(serialized['message'], 1);\n    equal(serialized['message_type'], 'post');\n  }));\n});\n\ntest(\"TODO (embedded): The store can load an embedded polymorphic belongsTo association\", function() {\n  expect(0);\n  //serializer.keyForEmbeddedType = function() {\n    //return 'embeddedType';\n  //};\n\n  //adapter.load(store, App.User, { id: 2, favourite_message: { id: 1, embeddedType: 'comment'}});\n\n  //var user = store.find(App.User, 2),\n      //message = store.find(App.Comment, 1);\n\n  //equal(user.get('favouriteMessage'), message);\n});\n\ntest(\"TODO (embedded): The store can serialize an embedded polymorphic belongsTo association\", function() {\n  expect(0);\n  //serializer.keyForEmbeddedType = function() {\n    //return 'embeddedType';\n  //};\n  //adapter.load(store, App.User, { id: 2, favourite_message: { id: 1, embeddedType: 'comment'}});\n\n  //var user = store.find(App.User, 2),\n      //serialized = store.serialize(user, {includeId: true});\n\n  //ok(serialized.hasOwnProperty('favourite_message'));\n  //equal(serialized.favourite_message.id, 1);\n  //equal(serialized.favourite_message.embeddedType, 'comment');\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/belongs_to_test");minispade.register('ember-data/~tests/integration/relationships/has_many_test', "(function() {var env, User, Message, Post, Comment;\nvar get = Ember.get, set = Ember.set;\n\nvar attr = DS.attr, hasMany = DS.hasMany, belongsTo = DS.belongsTo;\n\nfunction stringify(string) {\n  return function() { return string; };\n}\n\nmodule(\"integration/relationships/has_many - Has-Many Relationships\", {\n  setup: function() {\n    User = DS.Model.extend({\n      name: attr('string'),\n      messages: hasMany('message', { polymorphic: true }),\n    });\n\n    Message = DS.Model.extend({\n      user: belongsTo('user'),\n      created_at: attr('date')\n    });\n    Message.toString = stringify('Message');\n\n    Post = Message.extend({\n      title: attr('string'),\n      comments: hasMany('comment')\n    });\n    Post.toString = stringify('Post');\n\n    Comment = Message.extend({\n      body: DS.attr('string'),\n      message: DS.belongsTo('post', { polymorphic: true })\n    });\n    Comment.toString = stringify('Comment');\n\n    env = setupStore({\n      user: User,\n      post: Post,\n      comment: Comment,\n      message: Message\n    });\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"When a hasMany relationship is accessed, the adapter's findMany method should not be called if all the records in the relationship are already loaded\", function() {\n  expect(0);\n\n  env.adapter.findMany = function() {\n    ok(false, \"The adapter's find method should not be called\");\n  };\n\n  env.store.push('post', { id: 1, comments: [ 1 ] });\n  env.store.push('comment', { id: 1 });\n\n  env.store.find('post', 1).then(async(function(post) {\n    post.get('comments');\n  }));\n});\n\n// This tests the case where a serializer materializes a has-many\n// relationship as a reference that it can fetch lazily. The most\n// common use case of this is to provide a URL to a collection that\n// is loaded later.\ntest(\"A serializer can materialize a hasMany as an opaque token that can be lazily fetched via the adapter's findHasMany hook\", function() {\n  Post.reopen({\n    comments: DS.hasMany('comment', { async: true })\n  });\n\n  // When the store asks the adapter for the record with ID 1,\n  // provide some fake data.\n  env.adapter.find = function(store, type, id) {\n    equal(type, Post, \"find type was Post\");\n    equal(id, \"1\", \"find id was 1\");\n\n    return Ember.RSVP.resolve({ id: 1, links: { comments: \"/posts/1/comments\" } });\n  };\n\n  env.adapter.findMany = function() {\n    throw new Error(\"Adapter's findMany should not be called\");\n  };\n\n  env.adapter.findHasMany = function(store, record, link, relationship) {\n    equal(relationship.type, Comment, \"findHasMany relationship type was Comment\");\n    equal(relationship.key, 'comments', \"findHasMany relationship key was comments\");\n    equal(link, \"/posts/1/comments\", \"findHasMany link was /posts/1/comments\");\n\n    return Ember.RSVP.resolve([\n      { id: 1, body: \"First\" },\n      { id: 2, body: \"Second\" }\n    ]);\n  };\n\n  env.store.find('post', 1).then(async(function(post) {\n    return post.get('comments');\n  })).then(async(function(comments) {\n    equal(comments.get('isLoaded'), true, \"comments are loaded\");\n    equal(comments.get('length'), 2, \"comments have 2 length\");\n  }));\n});\n\ntest(\"When a polymorphic hasMany relationship is accessed, the adapter's findMany method should not be called if all the records in the relationship are already loaded\", function() {\n  expect(1);\n\n  env.adapter.findMany = function() {\n    ok(false, \"The adapter's find method should not be called\");\n  };\n\n  env.store.push('user', { id: 1, messages: [ {id: 1, type: 'post'}, {id: 3, type: 'comment'} ] });\n  env.store.push('post', { id: 1 });\n  env.store.push('comment', { id: 3 });\n\n  env.store.find('user', 1).then(async(function(user) {\n    var messages = user.get('messages');\n    equal(messages.get('length'), 2, \"The messages are correctly loaded\");\n  }));\n});\n\ntest(\"When a polymorphic hasMany relationship is accessed, the store can call multiple adapters' findMany method if the records are not loaded\", function() {\n  User.reopen({\n    messages: hasMany('message', { polymorphic: true, async: true })\n  });\n\n  env.adapter.findMany = function(store, type) {\n    if (type === Post) {\n      return Ember.RSVP.resolve([{ id: 1 }]);\n    } else if (type === Comment) {\n      return Ember.RSVP.resolve([{ id: 3 }]);\n    }\n  };\n\n  env.store.push('user', { id: 1, messages: [ {id: 1, type: 'post'}, {id: 3, type: 'comment'} ] });\n\n  env.store.find('user', 1).then(async(function(user) {\n    return user.get('messages');\n  })).then(async(function(messages) {\n    equal(messages.get('length'), 2, \"The messages are correctly loaded\");\n  }));\n});\n\ntest(\"A record can't be created from a polymorphic hasMany relationship\", function() {\n  env.store.push('user', { id: 1, messages: [] });\n\n  env.store.find('user', 1).then(async(function(user) {\n    return user.get('messages');\n  })).then(async(function(messages) {\n    expectAssertion(function() {\n      messages.createRecord();\n    }, /You cannot add 'message' records to this polymorphic relationship/);\n  }));\n});\n\ntest(\"Only records of the same type can be added to a monomorphic hasMany relationship\", function() {\n  expect(1);\n  env.store.push('post', { id: 1, comments: [] });\n  env.store.push('post', { id: 2 });\n\n  Ember.RSVP.all([ env.store.find('post', 1), env.store.find('post', 2) ]).then(async(function(records) {\n    expectAssertion(function() {\n      records[0].get('comments').pushObject(records[1]);\n    }, /You cannot add 'post' records to this relationship/);\n  }));\n\n});\n\ntest(\"Only records of the same base type can be added to a polymorphic hasMany relationship\", function() {\n  expect(2);\n  env.store.push('user', { id: 1, messages: [] });\n  env.store.push('user', { id: 2, messages: [] });\n  env.store.push('post', { id: 1, comments: [] });\n  env.store.push('comment', { id: 3 });\n\n  var asyncRecords = Ember.RSVP.hash({\n    user: env.store.find('user', 1),\n    anotherUser: env.store.find('user', 2),\n    post: env.store.find('post', 1),\n    comment: env.store.find('comment', 3)\n  });\n\n  asyncRecords.then(async(function(records) {\n    records.messages = records.user.get('messages');\n    return Ember.RSVP.hash(records);\n  })).then(async(function(records) {\n    records.messages.pushObject(records.post);\n    records.messages.pushObject(records.comment);\n    equal(records.messages.get('length'), 2, \"The messages are correctly added\");\n\n    expectAssertion(function() {\n      records.messages.pushObject(records.anotherUser);\n    }, /You cannot add 'user' records to this relationship/);\n  }));\n});\n\ntest(\"A record can be removed from a polymorphic association\", function() {\n  expect(3);\n\n  env.store.push('user', { id: 1 , messages: [{id: 3, type: 'comment'}]});\n  env.store.push('comment', { id: 3 });\n\n  var asyncRecords = Ember.RSVP.hash({\n    user: env.store.find('user', 1),\n    comment: env.store.find('comment', 3),\n  });\n\n  asyncRecords.then(async(function(records) {\n    records.messages = records.user.get('messages');\n    return Ember.RSVP.hash(records);\n  })).then(async(function(records) {\n    equal(records.messages.get('length'), 1, \"The user has 1 message\");\n\n    var removedObject = records.messages.popObject();\n\n    equal(removedObject, records.comment, \"The message is correctly removed\");\n    equal(records.messages.get('length'), 0, \"The user does not have any messages\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/has_many_test");minispade.register('ember-data/~tests/integration/relationships/inverse_relationships_test', "(function() {var Post, Comment, Message, User, store, env;\n\nmodule('integration/relationships/inverse_relationships - Inverse Relationships');\n\ntest(\"When a record is added to a has-many relationship, the inverse belongsTo is determined automatically\", function() {\n  Post = DS.Model.extend({\n    comments: DS.hasMany('comment')\n  });\n\n  Comment = DS.Model.extend({\n    post: DS.belongsTo('post')\n  });\n\n  var env = setupStore({ post: Post, comment: Comment }),\n      store = env.store;\n\n  var comment = store.createRecord('comment');\n  var post = store.createRecord('post');\n\n  equal(comment.get('post'), null, \"no post has been set on the comment\");\n\n  post.get('comments').pushObject(comment);\n  equal(comment.get('post'), post, \"post was set on the comment\");\n});\n\ntest(\"Inverse relationships can be explicitly nullable\", function () {\n  User = DS.Model.extend();\n\n  Post = DS.Model.extend({\n    lastParticipant: DS.belongsTo(User, { inverse: null }),\n    participants: DS.hasMany(User, { inverse: 'posts' })\n  });\n\n  User.reopen({\n    posts: DS.hasMany(Post, { inverse: 'participants' })\n  });\n\n  equal(User.inverseFor('posts').name, 'participants', 'User.posts inverse is Post.participants');\n  equal(Post.inverseFor('lastParticipant'), null, 'Post.lastParticipant has no inverse');\n  equal(Post.inverseFor('participants').name, 'posts', 'Post.participants inverse is User.posts');\n});\n\ntest(\"When a record is added to a has-many relationship, the inverse belongsTo can be set explicitly\", function() {\n  Post = DS.Model.extend({\n    comments: DS.hasMany('comment', { inverse: 'redPost' })\n  });\n\n  Comment = DS.Model.extend({\n    onePost: DS.belongsTo('post'),\n    twoPost: DS.belongsTo('post'),\n    redPost: DS.belongsTo('post'),\n    bluePost: DS.belongsTo('post')\n  });\n\n  var env = setupStore({ post: Post, comment: Comment }),\n      store = env.store;\n\n  var comment = store.createRecord('comment');\n  var post = store.createRecord('post');\n\n  equal(comment.get('onePost'), null, \"onePost has not been set on the comment\");\n  equal(comment.get('twoPost'), null, \"twoPost has not been set on the comment\");\n  equal(comment.get('redPost'), null, \"redPost has not been set on the comment\");\n  equal(comment.get('bluePost'), null, \"bluePost has not been set on the comment\");\n\n  post.get('comments').pushObject(comment);\n\n  equal(comment.get('onePost'), null, \"onePost has not been set on the comment\");\n  equal(comment.get('twoPost'), null, \"twoPost has not been set on the comment\");\n  equal(comment.get('redPost'), post, \"redPost has been set on the comment\");\n  equal(comment.get('bluePost'), null, \"bluePost has not been set on the comment\");\n});\n\ntest(\"When a record's belongsTo relationship is set, it can specify the inverse hasMany to which the new child should be added\", function() {\n  Post = DS.Model.extend({\n    meComments: DS.hasMany('comment'),\n    youComments: DS.hasMany('comment'),\n    everyoneWeKnowComments: DS.hasMany('comment')\n  });\n\n  Comment = DS.Model.extend({\n    post: DS.belongsTo('post', { inverse: 'youComments' })\n  });\n\n  var env = setupStore({ post: Post, comment: Comment }),\n      store = env.store;\n\n  var comment = store.createRecord('comment');\n  var post = store.createRecord('post');\n\n  equal(post.get('meComments.length'), 0, \"meComments has no posts\");\n  equal(post.get('youComments.length'), 0, \"youComments has no posts\");\n  equal(post.get('everyoneWeKnowComments.length'), 0, \"everyoneWeKnowComments has no posts\");\n\n  comment.set('post', post);\n\n  equal(post.get('meComments.length'), 0, \"meComments has no posts\");\n  equal(post.get('youComments.length'), 1, \"youComments had the post added\");\n  equal(post.get('everyoneWeKnowComments.length'), 0, \"everyoneWeKnowComments has no posts\");\n});\n\ntest(\"When a record is added to or removed from a polymorphic has-many relationship, the inverse belongsTo can be set explicitly\", function() {\n  User = DS.Model.extend({\n    messages: DS.hasMany('message', {\n      inverse: 'redUser',\n      polymorphic: true\n    })\n  });\n\n  Message = DS.Model.extend({\n    oneUser: DS.belongsTo('user'),\n    twoUser: DS.belongsTo('user'),\n    redUser: DS.belongsTo('user'),\n    blueUser: DS.belongsTo('user')\n  });\n\n  Post = Message.extend();\n\n  var env = setupStore({ user: User, message: Message, post: Post }),\n      store = env.store;\n\n  var post = store.createRecord('post');\n  var user = store.createRecord('user');\n\n  equal(post.get('oneUser'), null, \"oneUser has not been set on the user\");\n  equal(post.get('twoUser'), null, \"twoUser has not been set on the user\");\n  equal(post.get('redUser'), null, \"redUser has not been set on the user\");\n  equal(post.get('blueUser'), null, \"blueUser has not been set on the user\");\n\n  user.get('messages').pushObject(post);\n\n  equal(post.get('oneUser'), null, \"oneUser has not been set on the user\");\n  equal(post.get('twoUser'), null, \"twoUser has not been set on the user\");\n  equal(post.get('redUser'), user, \"redUser has been set on the user\");\n  equal(post.get('blueUser'), null, \"blueUser has not been set on the user\");\n\n  user.get('messages').popObject();\n\n  equal(post.get('oneUser'), null, \"oneUser has not been set on the user\");\n  equal(post.get('twoUser'), null, \"twoUser has not been set on the user\");\n  equal(post.get('redUser'), null, \"redUser has bot been set on the user\");\n  equal(post.get('blueUser'), null, \"blueUser has not been set on the user\");\n});\n\ntest(\"When a record's belongsTo relationship is set, it can specify the inverse polymorphic hasMany to which the new child should be added or removed\", function() {\n  User = DS.Model.extend({\n    meMessages: DS.hasMany('message', { polymorphic: true }),\n    youMessages: DS.hasMany('message', { polymorphic: true }),\n    everyoneWeKnowMessages: DS.hasMany('message', { polymorphic: true }),\n  });\n\n  Message = DS.Model.extend({\n    user: DS.belongsTo('user', { inverse: 'youMessages' })\n  });\n\n  Post = Message.extend();\n\n  var env = setupStore({ user: User, message: Message, post: Post }),\n      store = env.store;\n\n  var user = store.createRecord('user');\n  var post = store.createRecord('post');\n\n  equal(user.get('meMessages.length'), 0, \"meMessages has no posts\");\n  equal(user.get('youMessages.length'), 0, \"youMessages has no posts\");\n  equal(user.get('everyoneWeKnowMessages.length'), 0, \"everyoneWeKnowMessages has no posts\");\n\n  post.set('user', user);\n\n  equal(user.get('meMessages.length'), 0, \"meMessages has no posts\");\n  equal(user.get('youMessages.length'), 1, \"youMessages had the post added\");\n  equal(user.get('everyoneWeKnowMessages.length'), 0, \"everyoneWeKnowMessages has no posts\");\n\n  post.set('user', null);\n\n  equal(user.get('meMessages.length'), 0, \"meMessages has no posts\");\n  equal(user.get('youMessages.length'), 0, \"youMessages has no posts\");\n  equal(user.get('everyoneWeKnowMessages.length'), 0, \"everyoneWeKnowMessages has no posts\");\n});\n\ntest(\"When a record's polymorphic belongsTo relationship is set, it can specify the inverse hasMany to which the new child should be added\", function() {\n  Message = DS.Model.extend({\n    meMessages: DS.hasMany('comment'),\n    youMessages: DS.hasMany('comment'),\n    everyoneWeKnowMessages: DS.hasMany('comment')\n  });\n\n  Post = Message.extend();\n\n  Comment = Message.extend({\n    message: DS.belongsTo('message', {\n      polymorphic: true,\n      inverse: 'youMessages'\n    }),\n  });\n\n  var env = setupStore({ comment: Comment, message: Message, post: Post }),\n      store = env.store;\n\n  var comment = store.createRecord('comment');\n  var post = store.createRecord('post');\n\n  equal(post.get('meMessages.length'), 0, \"meMessages has no posts\");\n  equal(post.get('youMessages.length'), 0, \"youMessages has no posts\");\n  equal(post.get('everyoneWeKnowMessages.length'), 0, \"everyoneWeKnowMessages has no posts\");\n\n  comment.set('message', post);\n\n  equal(post.get('meMessages.length'), 0, \"meMessages has no posts\");\n  equal(post.get('youMessages.length'), 1, \"youMessages had the post added\");\n  equal(post.get('everyoneWeKnowMessages.length'), 0, \"everyoneWeKnowMessages has no posts\");\n\n  comment.set('message', null);\n\n  equal(post.get('meMessages.length'), 0, \"meMessages has no posts\");\n  equal(post.get('youMessages.length'), 0, \"youMessages has no posts\");\n  equal(post.get('everyoneWeKnowMessages.length'), 0, \"everyoneWeKnowMessages has no posts\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/inverse_relationships_test");minispade.register('ember-data/~tests/unit/debug_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar store;\n\nvar TestAdapter = DS.Adapter.extend();\n\nmodule(\"Debug\", {\n  setup: function() {\n    store = DS.Store.create({\n      adapter: TestAdapter.create(),\n    });\n  },\n\n  teardown: function() {\n    store.destroy();\n    store = null;\n  }\n});\n\ntest(\"_debugInfo groups the attributes and relationships correctly\", function() {\n  var MaritalStatus = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Post = DS.Model.extend({\n    title: DS.attr('string')\n  });\n\n  var User = DS.Model.extend({\n    name: DS.attr('string'),\n    isDrugAddict: DS.attr('boolean'),\n    maritalStatus: DS.belongsTo(MaritalStatus),\n    posts: DS.hasMany(Post)\n  });\n\n  var record = store.createRecord(User);\n\n  var propertyInfo = record._debugInfo().propertyInfo;\n\n  equal(propertyInfo.groups.length, 4);\n  deepEqual(propertyInfo.groups[0].properties, ['id', 'name', 'isDrugAddict']);\n  deepEqual(propertyInfo.groups[1].properties, ['maritalStatus']);\n  deepEqual(propertyInfo.groups[2].properties, ['posts']);\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/debug_test");minispade.register('ember-data/~tests/unit/model/lifecycle_callbacks_test', "(function() {var get = Ember.get, set = Ember.set;\n\nmodule(\"unit/model/lifecycle_callbacks - Lifecycle Callbacks\");\n\ntest(\"a record receives a didLoad callback when it has finished loading\", function() {\n  var Person = DS.Model.extend({\n    name: DS.attr(),\n    didLoad: function() {\n      ok(\"The didLoad callback was called\");\n    }\n  });\n\n  var adapter = DS.Adapter.create({\n    find: function(store, type, id) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Foo\" });\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  store.find(Person, 1).then(async(function(person) {\n    equal(person.get('id'), \"1\", \"The person's ID is available\");\n    equal(person.get('name'), \"Foo\", \"The person's properties are available\");\n  }));\n});\n\ntest(\"a record receives a didUpdate callback when it has finished updating\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    bar: DS.attr('string'),\n\n    didUpdate: function() {\n      callCount++;\n      equal(get(this, 'isSaving'), false, \"record should be saving\");\n      equal(get(this, 'isDirty'), false, \"record should not be dirty\");\n    }\n  });\n\n  var adapter = DS.Adapter.create({\n    find: function(store, type, id) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Foo\" });\n    },\n\n    updateRecord: function(store, type, record) {\n      equal(callCount, 0, \"didUpdate callback was not called until didSaveRecord is called\");\n\n      return Ember.RSVP.resolve();\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var asyncPerson = store.find(Person, 1);\n  equal(callCount, 0, \"precond - didUpdate callback was not called yet\");\n\n  asyncPerson.then(async(function(person) {\n    person.set('bar', \"Bar\");\n    return person.save();\n  })).then(async(function() {\n    equal(callCount, 1, \"didUpdate called after update\");\n  }));\n});\n\ntest(\"a record receives a didCreate callback when it has finished updating\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    didCreate: function() {\n      callCount++;\n      equal(get(this, 'isSaving'), false, \"record should not be saving\");\n      equal(get(this, 'isDirty'), false, \"record should not be dirty\");\n    }\n  });\n\n  var adapter = DS.Adapter.create({\n    createRecord: function(store, type, record) {\n      equal(callCount, 0, \"didCreate callback was not called until didSaveRecord is called\");\n\n      return Ember.RSVP.resolve();\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  equal(callCount, 0, \"precond - didCreate callback was not called yet\");\n\n  var person = store.createRecord(Person, { id: 69, name: \"Newt Gingrich\" });\n\n  person.save().then(async(function() {\n    equal(callCount, 1, \"didCreate called after commit\");\n  }));\n});\n\ntest(\"a record receives a didDelete callback when it has finished deleting\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    bar: DS.attr('string'),\n\n    didDelete: function() {\n      callCount++;\n\n      equal(get(this, 'isSaving'), false, \"record should not be saving\");\n      equal(get(this, 'isDirty'), false, \"record should not be dirty\");\n    }\n  });\n\n  var adapter = DS.Adapter.create({\n    find: function(store, type, id) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Foo\" });\n    },\n\n    deleteRecord: function(store, type, record) {\n      equal(callCount, 0, \"didDelete callback was not called until didSaveRecord is called\");\n\n      return Ember.RSVP.resolve();\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var asyncPerson = store.find(Person, 1);\n  equal(callCount, 0, \"precond - didDelete callback was not called yet\");\n\n  asyncPerson.then(async(function(person) {\n    person.deleteRecord();\n    return person.save();\n  })).then(async(function() {\n    equal(callCount, 1, \"didDelete called after delete\");\n  }));\n});\n\ntest(\"a record receives a becameInvalid callback when it became invalid\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    bar: DS.attr('string'),\n\n    becameInvalid: function() {\n      callCount++;\n\n      equal(get(this, 'isSaving'), false, \"record should not be saving\");\n      equal(get(this, 'isDirty'), true, \"record should be dirty\");\n    }\n  });\n\n  var adapter = DS.Adapter.create({\n    find: function(store, type, id) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Foo\" });\n    },\n\n    updateRecord: function(store, type, record) {\n      equal(callCount, 0, \"becameInvalid callback was not called untill recordWasInvalid is called\");\n\n      return Ember.RSVP.reject(new DS.InvalidError({ bar: 'error' }));\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var asyncPerson = store.find(Person, 1);\n  equal(callCount, 0, \"precond - becameInvalid callback was not called yet\");\n\n  // Make sure that the error handler has a chance to attach before\n  // save fails.\n  Ember.run(function() {\n    asyncPerson.then(async(function(person) {\n      person.set('bar', \"Bar\");\n      return person.save();\n    })).then(null, async(function() {\n      equal(callCount, 1, \"becameInvalid called after invalidating\");\n    }));\n  });\n});\n\ntest(\"an ID of 0 is allowed\", function() {\n  var store = DS.Store.create();\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  store.push(Person, { id: 0, name: \"Tom Dale\" });\n  equal(store.all(Person).objectAt(0).get('name'), \"Tom Dale\", \"found record with id 0\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/model/lifecycle_callbacks_test");minispade.register('ember-data/~tests/unit/model/merge_test', "(function() {var Person;\n\nmodule(\"unit/model/merge - Merging\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      name: DS.attr(),\n      city: DS.attr()\n    });\n  },\n\n  teardown: function() {\n\n  }\n});\n\ntest(\"When a record is in flight, changes can be made\", function() {\n  var adapter = DS.Adapter.create({\n    createRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\" });\n    }\n  });\n\n  var store = DS.Store.create({ adapter: adapter });\n\n  var person = store.createRecord(Person, { name: \"Tom Dale\" });\n\n  // Make sure saving isn't resolved synchronously\n  Ember.run(function() {\n    var promise = person.save();\n\n    equal(person.get('name'), \"Tom Dale\");\n\n    person.set('name', \"Thomas Dale\");\n\n    promise.then(function(person) {\n      equal(person.get('isDirty'), true, \"The person is still dirty\");\n      equal(person.get('name'), \"Thomas Dale\", \"The changes made still apply\");\n    });\n  });\n});\n\ntest(\"When a record is in flight, pushes are applied underneath the in flight changes\", function() {\n  var adapter = DS.Adapter.create({\n    updateRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Senor Thomas Dale, Esq.\", city: \"Portland\" });\n    }\n  });\n\n  var store = DS.Store.create({ adapter: adapter });\n\n  var person = store.push(Person, { id: 1, name: \"Tom\" });\n  person.set('name', \"Thomas Dale\");\n\n  // Make sure saving isn't resolved synchronously\n  Ember.run(function() {\n    var promise = person.save();\n\n    equal(person.get('name'), \"Thomas Dale\");\n\n    person.set('name', \"Tomasz Dale\");\n\n    store.push(Person, { id: 1, name: \"Tommy Dale\", city: \"PDX\" });\n\n    equal(person.get('name'), \"Tomasz Dale\", \"the local changes applied on top\");\n    equal(person.get('city'), \"PDX\", \"the pushed change is available\");\n\n    promise.then(function(person) {\n      equal(person.get('isDirty'), true, \"The person is still dirty\");\n      equal(person.get('name'), \"Tomasz Dale\", \"The local changes apply\");\n      equal(person.get('city'), \"Portland\", \"The updates from the server apply on top of the previous pushes\");\n    });\n  });\n});\n\ntest(\"When a record is dirty, pushes are overridden by local changes\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n\n  var person = store.push(Person, { id: 1, name: \"Tom Dale\", city: \"San Francisco\" });\n\n  person.set('name', \"Tomasz Dale\");\n\n  equal(person.get('isDirty'), true, \"the person is currently dirty\");\n  equal(person.get('name'), \"Tomasz Dale\", \"the update was effective\");\n  equal(person.get('city'), \"San Francisco\", \"the original data applies\");\n\n  store.push(Person, { id: 1, name: \"Thomas Dale\", city: \"Portland\" });\n\n  equal(person.get('isDirty'), true, \"the local changes are reapplied\");\n  equal(person.get('name'), \"Tomasz Dale\", \"the local changes are reapplied\");\n  equal(person.get('city'), \"Portland\", \"if there are no local changes, the new data applied\");\n});\n\ntest(\"A record with no changes can still be saved\", function() {\n  var adapter = DS.Adapter.create({\n    updateRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Thomas Dale\" });\n    }\n  });\n\n  var store = DS.Store.create({ adapter: adapter });\n\n  var person = store.push(Person, { id: 1, name: \"Tom Dale\" });\n\n  person.save().then(async(function() {\n    equal(person.get('name'), \"Thomas Dale\", \"the updates occurred\");\n  }));\n});\n\ntest(\"A dirty record can be reloaded\", function() {\n  var adapter = DS.Adapter.create({\n    find: function(store, type, id) {\n      return Ember.RSVP.resolve({ id: 1, name: \"Thomas Dale\", city: \"Portland\" });\n    }\n  });\n\n  var store = DS.Store.create({ adapter: adapter });\n\n  var person = store.push(Person, { id: 1, name: \"Tom Dale\" });\n\n  person.set('name', \"Tomasz Dale\");\n\n  person.reload().then(async(function() {\n    equal(person.get('isDirty'), true, \"the person is dirty\");\n    equal(person.get('name'), \"Tomasz Dale\", \"the local changes remain\");\n    equal(person.get('city'), \"Portland\", \"the new changes apply\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/model/merge_test");minispade.register('ember-data/~tests/unit/model/relationships_test', "(function() {/*global Tag App*/\n\nvar get = Ember.get, set = Ember.set;\n\nmodule(\"unit/model/relationships - DS.Model\");\n\ntest(\"exposes a hash of the relationships on a model\", function() {\n  var Occupation = DS.Model.extend();\n\n  var Person = DS.Model.extend({\n    occupations: DS.hasMany(Occupation)\n  });\n\n  Person.reopen({\n    people: DS.hasMany(Person),\n    parent: DS.belongsTo(Person)\n  });\n\n  var relationships = get(Person, 'relationships');\n  deepEqual(relationships.get(Person), [\n    { name: \"people\", kind: \"hasMany\" },\n    { name: \"parent\", kind: \"belongsTo\" }\n  ]);\n\n  deepEqual(relationships.get(Occupation), [\n    { name: \"occupations\", kind: \"hasMany\" }\n  ]);\n});\n\nvar env;\nmodule(\"unit/model/relationships - DS.hasMany\", {\n  setup: function() {\n    env = setupStore();\n  }\n});\n\ntest(\"hasMany handles pre-loaded relationships\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Pet = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag'),\n    pets: DS.hasMany('pet')\n  });\n\n  env.container.register('model:tag', Tag);\n  env.container.register('model:pet', Pet);\n  env.container.register('model:person', Person);\n\n  env.adapter.find = function(store, type, id) {\n    if (type === Tag && id === '12') {\n      return Ember.RSVP.resolve({ id: 12, name: \"oohlala\" });\n    } else {\n      ok(false, \"find() should not be called with these values\");\n    }\n  };\n\n  var store = env.store;\n\n  store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n  store.pushMany('pet', [{ id: 4, name: \"fluffy\" }, { id: 7, name: \"snowy\" }, { id: 12, name: \"cerberus\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [5] });\n  store.push('person', { id: 2, name: \"Yehuda Katz\", tags: [12] });\n\n  var wycats;\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n    var tags = get(person, 'tags');\n    equal(get(tags, 'length'), 1, \"the list of tags should have the correct length\");\n    equal(get(tags.objectAt(0), 'name'), \"friendly\", \"the first tag should be a Tag\");\n\n    store.push('person', { id: 1, name: \"Tom Dale\", tags: [5, 2] });\n    equal(tags, get(person, 'tags'), \"a relationship returns the same object every time\");\n    equal(get(get(person, 'tags'), 'length'), 2, \"the length is updated after new data is loaded\");\n\n    strictEqual(get(person, 'tags').objectAt(0), get(person, 'tags').objectAt(0), \"the returned object is always the same\");\n    asyncEqual(get(person, 'tags').objectAt(0), store.find(Tag, 5), \"relationship objects are the same as objects retrieved directly\");\n\n    store.push('person', { id: 3, name: \"KSelden\" });\n\n    return store.find('person', 3);\n  })).then(async(function(kselden) {\n    equal(get(get(kselden, 'tags'), 'length'), 0, \"a relationship that has not been supplied returns an empty array\");\n\n    store.push('person', { id: 4, name: \"Cyvid Hamluck\", pets: [4] });\n    return store.find('person', 4);\n  })).then(async(function(cyvid) {\n    equal(get(cyvid, 'name'), \"Cyvid Hamluck\", \"precond - retrieves person record from store\");\n\n    var pets = get(cyvid, 'pets');\n    equal(get(pets, 'length'), 1, \"the list of pets should have the correct length\");\n    equal(get(pets.objectAt(0), 'name'), \"fluffy\", \"the first pet should be correct\");\n\n    store.push(Person, { id: 4, name: \"Cyvid Hamluck\", pets: [4, 12] });\n    equal(pets, get(cyvid, 'pets'), \"a relationship returns the same object every time\");\n    equal(get(get(cyvid, 'pets'), 'length'), 2, \"the length is updated after new data is loaded\");\n  }));\n});\n\ntest(\"hasMany lazily loads async relationships\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Pet = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag', { async: true }),\n    pets: DS.hasMany('pet')\n  });\n\n  env.container.register('model:tag', Tag);\n  env.container.register('model:pet', Pet);\n  env.container.register('model:person', Person);\n\n  env.adapter.find = function(store, type, id) {\n    if (type === Tag && id === '12') {\n      return Ember.RSVP.resolve({ id: 12, name: \"oohlala\" });\n    } else {\n      ok(false, \"find() should not be called with these values\");\n    }\n  };\n\n  var store = env.store;\n\n  store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n  store.pushMany('pet', [{ id: 4, name: \"fluffy\" }, { id: 7, name: \"snowy\" }, { id: 12, name: \"cerberus\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [5] });\n  store.push('person', { id: 2, name: \"Yehuda Katz\", tags: [12] });\n\n  var wycats;\n\n  store.find('person', 2).then(async(function(person) {\n    wycats = person;\n\n    equal(get(wycats, 'name'), \"Yehuda Katz\", \"precond - retrieves person record from store\");\n\n    return Ember.RSVP.hash({\n      wycats: wycats,\n      tags: wycats.get('tags')\n    });\n  })).then(async(function(records) {\n    equal(get(records.tags, 'length'), 1, \"the list of tags should have the correct length\");\n    equal(get(records.tags.objectAt(0), 'name'), \"oohlala\", \"the first tag should be a Tag\");\n\n    strictEqual(records.tags.objectAt(0), records.tags.objectAt(0), \"the returned object is always the same\");\n    asyncEqual(records.tags.objectAt(0), store.find(Tag, 12), \"relationship objects are the same as objects retrieved directly\");\n\n    return get(wycats, 'tags');\n  })).then(async(function(tags) {\n    var newTag = store.createRecord(Tag);\n    tags.pushObject(newTag);\n  }));\n});\n\ntest(\"should be able to retrieve the type for a hasMany relationship from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n\n  equal(Person.typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a hasMany relationship specified using a string from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  equal(env.store.modelFor('person').typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a belongsTo relationship from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.belongsTo('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  equal(env.store.modelFor('person').typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a belongsTo relationship specified using a string from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.belongsTo('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  equal(env.store.modelFor('person').typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"relationships work when declared with a string path\", function() {\n  window.App = {};\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var env = setupStore({\n    person: Person,\n    tag: Tag\n  });\n\n  env.store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  env.store.push('person', { id: 1, name: \"Tom Dale\", tags: [5, 2] });\n\n  env.store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n    equal(get(person, 'tags.length'), 2, \"the list of tags should have the correct length\");\n  }));\n});\n\ntest(\"hasMany relationships work when the data hash has not been loaded\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag', { async: true })\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  env.adapter.findMany = function(store, type, ids) {\n    equal(type, Tag, \"type should be Tag\");\n    deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n\n    return Ember.RSVP.resolve([{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n  };\n\n  env.adapter.find = function(store, type, id) {\n    equal(type, Person, \"type should be Person\");\n    equal(id, 1, \"id should be 1\");\n\n    return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", tags: [5, 2] });\n  };\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n\n    return person.get('tags');\n  })).then(async(function(tags) {\n    equal(get(tags, 'length'), 2, \"the tags object still exists\");\n    equal(get(tags.objectAt(0), 'name'), \"friendly\", \"Tom Dale is now friendly\");\n    equal(get(tags.objectAt(0), 'isLoaded'), true, \"Tom Dale is now loaded\");\n  }));\n});\n\ntest(\"it is possible to add a new item to a relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    people: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  var store = env.store;\n\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [ 1 ] });\n  store.push('tag', { id: 1, name: \"ember\" });\n\n  store.find(Person, 1).then(async(function(person) {\n    var tag = get(person, 'tags').objectAt(0);\n\n    equal(get(tag, 'name'), \"ember\", \"precond - relationships work\");\n\n    tag = store.createRecord(Tag, { name: \"js\" });\n    get(person, 'tags').pushObject(tag);\n\n    equal(get(person, 'tags').objectAt(1), tag, \"newly added relationship works\");\n  }));\n});\n\ntest(\"it is possible to remove an item from a relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [ 1 ] });\n  store.push('tag', { id: 1, name: \"ember\" });\n\n  store.find('person', 1).then(async(function(person) {\n    var tag = get(person, 'tags').objectAt(0);\n\n    equal(get(tag, 'name'), \"ember\", \"precond - relationships work\");\n\n    get(person, 'tags').removeObject(tag);\n\n    equal(get(person, 'tags.length'), 0, \"object is removed from the relationship\");\n  }));\n});\n\ntest(\"it is possible to add an item to a relationship, remove it, then add it again\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  Tag.toString = function() { return \"Tag\"; };\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  var person = store.createRecord('person');\n  var tag1 = store.createRecord('tag');\n  var tag2 = store.createRecord('tag');\n  var tag3 = store.createRecord('tag');\n\n  var tags = get(person, 'tags');\n\n  tags.pushObjects([tag1, tag2, tag3]);\n  tags.removeObject(tag2);\n  equal(tags.objectAt(0), tag1);\n  equal(tags.objectAt(1), tag3);\n  equal(get(person, 'tags.length'), 2, \"object is removed from the relationship\");\n\n  tags.insertAt(0, tag2);\n  equal(get(person, 'tags.length'), 3, \"object is added back to the relationship\");\n  equal(tags.objectAt(0), tag2);\n  equal(tags.objectAt(1), tag1);\n  equal(tags.objectAt(2), tag3);\n});\n\nmodule(\"unit/model/relationships - RecordArray\");\n\ntest(\"updating the content of a RecordArray updates its content\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var env = setupStore({ tag: Tag }),\n      store = env.store;\n\n  var records = store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n\n  var tags = DS.RecordArray.create({ content: Ember.A(records.slice(0, 2)), store: store, type: Tag });\n\n  var tag = tags.objectAt(0);\n  equal(get(tag, 'name'), \"friendly\", \"precond - we're working with the right tags\");\n\n  set(tags, 'content', Ember.A(records.slice(1, 3)));\n  tag = tags.objectAt(0);\n  equal(get(tag, 'name'), \"smarmy\", \"the lookup was updated\");\n});\n\ntest(\"can create child record from a hasMany relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.push('person', { id: 1, name: \"Tom Dale\"});\n\n  store.find('person', 1).then(async(function(person) {\n    person.get(\"tags\").createRecord({ name: \"cool\" });\n\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n    equal(get(person, 'tags.length'), 1, \"tag is added to the parent record\");\n    equal(get(person, 'tags').objectAt(0).get(\"name\"), \"cool\", \"tag values are passed along\");\n  }));\n});\n\nmodule(\"unit/model/relationships - DS.belongsTo\");\n\ntest(\"belongsTo lazily loads relationships as needed\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    people: DS.hasMany('person')\n  });\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag')\n  });\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tag: 5 });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n    equal(get(person, 'tag') instanceof Tag, true, \"the tag property should return a tag\");\n    equal(get(person, 'tag.name'), \"friendly\", \"the tag shuld have name\");\n\n    strictEqual(get(person, 'tag'), get(person, 'tag'), \"the returned object is always the same\");\n    asyncEqual(get(person, 'tag'), store.find('tag', 5), \"relationship object is the same as object retrieved directly\");\n  }));\n});\n\ntest(\"async belongsTo relationships work when the data hash has not been loaded\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag', { async: true })\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  env.adapter.find = function(store, type, id) {\n    if (type === Person) {\n      equal(id, 1, \"id should be 1\");\n\n      return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", tag: 2 });\n    } else if (type === Tag) {\n      equal(id, 2, \"id should be 2\");\n\n      return Ember.RSVP.resolve({ id: 2, name: \"friendly\" });\n    }\n  };\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n\n    return get(person, 'tag');\n  })).then(async(function(tag) {\n    equal(get(tag, 'name'), \"friendly\", \"Tom Dale is now friendly\");\n    equal(get(tag, 'isLoaded'), true, \"Tom Dale is now loaded\");\n  }));\n});\n\ntest(\"calling createRecord and passing in an undefined value for a relationship should be treated as if null\", function () {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag'),\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.createRecord('person', {id: 1, tag: undefined});\n\n  store.find(Person, 1).then(async(function(person) {\n    strictEqual(person.get('tag'), null, \"undefined values should return null relationships\");\n  }));\n});\n\ntest(\"findMany is passed the owner record for adapters when some of the object graph is already loaded\", function() {\n  var Occupation = DS.Model.extend({\n    description: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  Occupation.toString = function() { return \"Occupation\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    occupations: DS.hasMany('occupation', { async: true })\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ occupation: Occupation, person: Person }),\n      store = env.store;\n\n  env.adapter.findMany = function(store, type, ids, owner) {\n    equal(type, Occupation, \"type should be Occupation\");\n    deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n    equal(get(owner, 'id'), 1, \"the owner record id should be 1\");\n\n    return Ember.RSVP.resolve([{ id: 5, description: \"fifth\" }, { id: 2, description: \"second\" }]);\n  };\n\n  store.push('person', { id: 1, name: \"Tom Dale\", occupations: [5, 2] });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'isLoaded'), true, \"isLoaded should be true\");\n    equal(get(person, 'name'), \"Tom Dale\", \"the person is still Tom Dale\");\n\n    return get(person, 'occupations');\n  })).then(async(function(occupations) {\n    equal(get(occupations, 'length'), 2, \"the list of occupations should have the correct length\");\n\n    equal(get(occupations.objectAt(0), 'description'), \"fifth\", \"the occupation is the fifth\");\n    equal(get(occupations.objectAt(0), 'isLoaded'), true, \"the occupation is now loaded\");\n  }));\n});\n\ntest(\"findMany is passed the owner record for adapters when none of the object graph is loaded\", function() {\n  var Occupation = DS.Model.extend({\n    description: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  Occupation.toString = function() { return \"Occupation\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    occupations: DS.hasMany('occupation', { async: true })\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ occupation: Occupation, person: Person }),\n      store = env.store;\n\n  env.adapter.findMany = function(store, type, ids, owner) {\n    equal(type, Occupation, \"type should be Occupation\");\n    deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n    equal(get(owner, 'id'), 1, \"the owner record id should be 1\");\n\n    return Ember.RSVP.resolve([{ id: 5, description: \"fifth\" }, { id: 2, description: \"second\" }]);\n  };\n\n  env.adapter.find = function(store, type, id) {\n    equal(type, Person, \"type should be Person\");\n    equal(id, 1, \"id should be 1\");\n\n    return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", occupations: [5, 2] });\n  };\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n\n    return get(person, 'occupations');\n  })).then(async(function(occupations) {\n    equal(get(occupations, 'length'), 2, \"the occupation objects still exist\");\n    equal(get(occupations.objectAt(0), 'description'), \"fifth\", \"the occupation is the fifth\");\n    equal(get(occupations.objectAt(0), 'isLoaded'), true, \"the occupation is now loaded\");\n  }));\n});\n\ntest(\"belongsTo supports relationships to models with id 0\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    people: DS.hasMany('person')\n  });\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag')\n  });\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.pushMany('tag', [{ id: 0, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tag: 0 });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n    equal(get(person, 'tag') instanceof Tag, true, \"the tag property should return a tag\");\n    equal(get(person, 'tag.name'), \"friendly\", \"the tag shuld have name\");\n\n    strictEqual(get(person, 'tag'), get(person, 'tag'), \"the returned object is always the same\");\n    asyncEqual(get(person, 'tag'), store.find(Tag, 0), \"relationship object is the same as object retrieved directly\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/model/relationships_test");minispade.register('ember-data/~tests/unit/model_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar Person, store, array;\n\nmodule(\"unit/model - DS.Model\", {\n  setup: function() {\n    store = DS.Store.create({ adapter: DS.Adapter });\n\n    Person = DS.Model.extend({\n      name: DS.attr('string'),\n      isDrugAddict: DS.attr('boolean')\n    });\n  },\n\n  teardown: function() {\n    Person = null;\n    store = null;\n  }\n});\n\ntest(\"can have a property set on it\", function() {\n  var record = store.createRecord(Person);\n  set(record, 'name', 'bar');\n\n  equal(get(record, 'name'), 'bar', \"property was set on the record\");\n});\n\ntest(\"setting a property on a record that has not changed does not cause it to become dirty\", function() {\n  store.push(Person, { id: 1, name: \"Peter\", isDrugAddict: true });\n  store.find(Person, 1).then(async(function(person) {\n    equal(person.get('isDirty'), false, \"precond - person record should not be dirty\");\n    person.set('name', \"Peter\");\n    person.set('isDrugAddict', true);\n    equal(person.get('isDirty'), false, \"record does not become dirty after setting property to old value\");\n  }));\n});\n\ntest(\"a record reports its unique id via the `id` property\", function() {\n  store.push(Person, { id: 1 });\n\n  store.find(Person, 1).then(async(function(record) {\n    equal(get(record, 'id'), 1, \"reports id as id by default\");\n  }));\n});\n\ntest(\"a record's id is included in its toString representation\", function() {\n  store.push(Person, { id: 1 });\n\n  store.find(Person, 1).then(async(function(record) {\n    equal(record.toString(), '<(subclass of DS.Model):'+Ember.guidFor(record)+':1>', \"reports id in toString\");\n  }));\n});\n\ntest(\"trying to set an `id` attribute should raise\", function() {\n  Person = DS.Model.extend({\n    id: DS.attr('number'),\n    name: \"Scumdale\"\n  });\n\n  expectAssertion(function() {\n    store.push(Person, { id: 1, name: \"Scumdale\" });\n    var person = store.find(Person, 1);\n  }, /You may not set `id`/);\n});\n\ntest(\"it should use `_reference` and not `reference` to store its reference\", function() {\n  store.push(Person, { id: 1 });\n\n  store.find(Person, 1).then(async(function(record) {\n    equal(record.get('reference'), undefined, \"doesn't shadow reference key\");\n  }));\n});\n\ntest(\"it should cache attributes\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n\n  var Post = DS.Model.extend({\n    updatedAt: DS.attr('string')\n  });\n\n  var dateString = \"Sat, 31 Dec 2011 00:08:16 GMT\";\n  var date = new Date(dateString);\n\n  store.push(Post, { id: 1 });\n\n  store.find(Post, 1).then(async(function(record) {\n    record.set('updatedAt', date);\n    deepEqual(date, get(record, 'updatedAt'), \"setting a date returns the same date\");\n    strictEqual(get(record, 'updatedAt'), get(record, 'updatedAt'), \"second get still returns the same object\");\n  }));\n});\n\nmodule(\"unit/model - DS.Model updating\", {\n  setup: function() {\n    array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n    Person = DS.Model.extend({ name: DS.attr('string') });\n    store = DS.Store.create({ adapter: DS.Adapter });\n    store.pushMany(Person, array);\n  },\n  teardown: function() {\n    Person = null;\n    store = null;\n    array = null;\n  }\n});\n\ntest(\"a DS.Model can update its attributes\", function() {\n  store.find(Person, 2).then(async(function(person) {\n    set(person, 'name', \"Brohuda Katz\");\n    equal(get(person, 'name'), \"Brohuda Katz\", \"setting took hold\");\n  }));\n});\n\ntest(\"a DS.Model can have a defaultValue\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string', { defaultValue: \"unknown\" })\n  });\n\n  var tag = store.createRecord(Tag);\n\n  equal(get(tag, 'name'), \"unknown\", \"the default value is found\");\n\n  set(tag, 'name', null);\n\n  equal(get(tag, 'name'), null, \"null doesn't shadow defaultValue\");\n});\n\ntest(\"a defaultValue for an attribite can be a function\", function() {\n  var Tag = DS.Model.extend({\n    createdAt: DS.attr('string', {\n      defaultValue: function() {\n        return \"le default value\";\n      }\n    })\n  });\n\n  var tag = store.createRecord(Tag);\n  equal(get(tag, 'createdAt'), \"le default value\", \"the defaultValue function is evaluated\");\n});\n\ntest(\"when a DS.Model updates its attributes, its changes affect its filtered Array membership\", function() {\n  var people = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Katz$/)) { return true; }\n  });\n\n  equal(get(people, 'length'), 1, \"precond - one item is in the RecordArray\");\n\n  var person = people.objectAt(0);\n\n  equal(get(person, 'name'), \"Scumbag Katz\", \"precond - the item is correct\");\n\n  set(person, 'name', \"Yehuda Katz\");\n\n  equal(get(people, 'length'), 1, \"there is still one item\");\n  equal(get(person, 'name'), \"Yehuda Katz\", \"it has the updated item\");\n\n  set(person, 'name', \"Yehuda Katz-Foo\");\n\n  equal(get(people, 'length'), 0, \"there are now no items\");\n});\n\nmodule(\"unit/model - with a simple Person model\", {\n  setup: function() {\n    array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n    Person = DS.Model.extend({\n      name: DS.attr('string')\n    });\n    store = DS.Store.create({ adapter: DS.Adapter });\n    store.pushMany(Person, array);\n  },\n  teardown: function() {\n    Person = null;\n    store = null;\n    array = null;\n  }\n});\n\ntest(\"when a DS.Model updates its attributes, its changes affect its filtered Array membership\", function() {\n  var people = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Katz$/)) { return true; }\n  });\n\n  equal(get(people, 'length'), 1, \"precond - one item is in the RecordArray\");\n\n  var person = people.objectAt(0);\n\n  equal(get(person, 'name'), \"Scumbag Katz\", \"precond - the item is correct\");\n\n  set(person, 'name', \"Yehuda Katz\");\n\n  equal(get(people, 'length'), 1, \"there is still one item\");\n  equal(get(person, 'name'), \"Yehuda Katz\", \"it has the updated item\");\n\n  set(person, 'name', \"Yehuda Katz-Foo\");\n\n  equal(get(people, 'length'), 0, \"there are now no items\");\n});\n\ntest(\"can ask if record with a given id is loaded\", function() {\n  equal(store.recordIsLoaded(Person, 1), true, 'should have person with id 1');\n  equal(store.recordIsLoaded(Person, 4), false, 'should not have person with id 2');\n});\n\ntest(\"a listener can be added to a record\", function() {\n  var count = 0;\n  var F = function() { count++; };\n  var record = store.createRecord(Person);\n\n  record.on('event!', F);\n  record.trigger('event!');\n\n  equal(count, 1, \"the event was triggered\");\n\n  record.trigger('event!');\n\n  equal(count, 2, \"the event was triggered\");\n});\n\ntest(\"when an event is triggered on a record the method with the same name is invoked with arguments\", function(){\n  var count = 0;\n  var F = function() { count++; };\n  var record = store.createRecord(Person);\n\n  record.eventNamedMethod = F;\n\n  record.trigger('eventNamedMethod');\n\n  equal(count, 1, \"the corresponding method was called\");\n});\n\ntest(\"when a method is invoked from an event with the same name the arguments are passed through\", function(){\n  var eventMethodArgs = null;\n  var F = function() { eventMethodArgs = arguments; };\n  var record = store.createRecord(Person);\n\n  record.eventThatTriggersMethod = F;\n\n  record.trigger('eventThatTriggersMethod', 1, 2);\n\n  equal( eventMethodArgs[0], 1);\n  equal( eventMethodArgs[1], 2);\n});\n\nvar converts = function(type, provided, expected) {\n  var testStore = DS.Store.create({ adapter: DS.Adapter });\n\n  var Model = DS.Model.extend({\n    name: DS.attr(type)\n  });\n\n  testStore.push(Model, { id: 1, name: provided });\n  testStore.push(Model, { id: 2 });\n\n  testStore.find(Model, 1).then(async(function(record) {\n    deepEqual(get(record, 'name'), expected, type + \" coerces \" + provided + \" to \" + expected);\n  }));\n\n  // See: Github issue #421\n  // record = testStore.find(Model, 2);\n  // set(record, 'name', provided);\n  // deepEqual(get(record, 'name'), expected, type + \" coerces \" + provided + \" to \" + expected);\n};\n\nvar convertsFromServer = function(type, provided, expected) {\n  var testStore = DS.Store.create({ adapter: DS.Adapter });\n\n  var Model = DS.Model.extend({\n    name: DS.attr(type)\n  });\n\n  testStore.push(Model, { id: 1, name: provided });\n  testStore.find(Model, 1).then(async(function(record) {\n    deepEqual(get(record, 'name'), expected, type + \" coerces \" + provided + \" to \" + expected);\n  }));\n};\n\nvar convertsWhenSet = function(type, provided, expected) {\n  var testStore = DS.Store.create({ adapter: DS.Adapter });\n\n  var Model = DS.Model.extend({\n    name: DS.attr(type)\n  });\n\n  testStore.push(Model, { id: 2 });\n  var record = testStore.find(Model, 2).then(async(function(record) {\n    set(record, 'name', provided);\n    deepEqual(record.serialize().name, expected, type + \" saves \" + provided + \" as \" + expected);\n  }));\n};\n\ntest(\"a DS.Model can describe String attributes\", function() {\n  converts('string', \"Scumbag Tom\", \"Scumbag Tom\");\n  converts('string', 1, \"1\");\n  converts('string', \"\", \"\");\n  converts('string', null, null);\n  converts('string', undefined, null);\n  convertsFromServer('string', undefined, null);\n});\n\ntest(\"a DS.Model can describe Number attributes\", function() {\n  converts('number', \"1\", 1);\n  converts('number', \"0\", 0);\n  converts('number', 1, 1);\n  converts('number', 0, 0);\n  converts('number', \"\", null);\n  converts('number', null, null);\n  converts('number', undefined, null);\n  converts('number', true, 1);\n  converts('number', false, 0);\n});\n\ntest(\"a DS.Model can describe Boolean attributes\", function() {\n  converts('boolean', \"1\", true);\n  converts('boolean', \"\", false);\n  converts('boolean', 1, true);\n  converts('boolean', 0, false);\n  converts('boolean', null, false);\n  converts('boolean', true, true);\n  converts('boolean', false, false);\n});\n\ntest(\"a DS.Model can describe Date attributes\", function() {\n  converts('date', null, null);\n  converts('date', undefined, undefined);\n\n  var dateString = \"Sat, 31 Dec 2011 00:08:16 GMT\";\n  var date = new Date(dateString);\n\n  var store = DS.Store.create({ adapter: DS.Adapter });\n\n  var Person = DS.Model.extend({\n    updatedAt: DS.attr('date')\n  });\n\n  store.push(Person, { id: 1 });\n  store.find(Person, 1).then(async(function(record) {\n    record.set('updatedAt', date);\n    deepEqual(date, get(record, 'updatedAt'), \"setting a date returns the same date\");\n  }));\n\n  convertsFromServer('date', dateString, date);\n  convertsWhenSet('date', date, dateString);\n});\n\ntest(\"don't allow setting\", function(){\n  var store = DS.Store.create({ adapter: DS.Adapter });\n\n  var Person = DS.Model.extend();\n  var record = store.createRecord(Person);\n\n  raises(function(){\n    record.set('isLoaded', true);\n  }, \"raised error when trying to set an unsettable record\");\n});\n\ntest(\"ensure model exits loading state, materializes data and fulfills promise only after data is available\", function () {\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      find: function(store, type, id) {\n        return Ember.RSVP.resolve({ id: 1, name: \"John\", isDrugAddict: false });\n      }\n    })\n  });\n\n  store.find(Person, 1).then(async(function(person) {\n    equal(get(person, 'currentState.stateName'), 'root.loaded.saved', 'model is in loaded state');\n    equal(get(person, 'isLoaded'), true, 'model is loaded');\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/model_test");minispade.register('ember-data/~tests/unit/record_array_test', "(function() {var get = Ember.get, set = Ember.set;\nvar indexOf = Ember.EnumerableUtils.indexOf;\n\nvar Person, array;\n\nmodule(\"unit/record_array - DS.RecordArray\", {\n  setup: function() {\n    array = [{ id: '1', name: \"Scumbag Dale\" }, { id: '2', name: \"Scumbag Katz\" }, { id: '3', name: \"Scumbag Bryn\" }];\n\n    Person = DS.Model.extend({\n      name: DS.attr('string')\n    });\n  }\n});\n\ntest(\"a record array is backed by records\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  store.pushMany(Person, array);\n\n  store.findByIds(Person, [1,2,3]).then(async(function(records) {\n    for (var i=0, l=get(array, 'length'); i<l; i++) {\n      deepEqual(records[i].getProperties('id', 'name'), array[i], \"a record array materializes objects on demand\");\n    }\n  }));\n});\n\ntest(\"acts as a live query\", function() {\n  var store = DS.Store.create();\n\n  var recordArray = store.all(Person);\n  store.push(Person, { id: 1, name: 'wycats' });\n  equal(get(recordArray, 'lastObject.name'), 'wycats');\n\n  store.push(Person, { id: 2, name: 'brohuda' });\n  equal(get(recordArray, 'lastObject.name'), 'brohuda');\n});\n\ntest(\"a loaded record is removed from a record array when it is deleted\", function() {\n  var Tag = DS.Model.extend({\n    people: DS.hasMany('person')\n  });\n\n  Person.reopen({\n    tag: DS.belongsTo('tag')\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.pushMany('person', array);\n  store.push('tag', { id: 1 });\n\n  var asyncRecords = Ember.RSVP.hash({\n    scumbag: store.find('person', 1),\n    tag: store.find('tag', 1)\n  });\n\n  asyncRecords.then(async(function(records) {\n    var scumbag = records.scumbag, tag = records.tag;\n\n    tag.get('people').addObject(scumbag);\n    equal(get(scumbag, 'tag'), tag, \"precond - the scumbag's tag has been set\");\n\n    var recordArray = tag.get('people');\n\n    equal(get(recordArray, 'length'), 1, \"precond - record array has one item\");\n    equal(get(recordArray.objectAt(0), 'name'), \"Scumbag Dale\", \"item at index 0 is record with id 1\");\n\n    scumbag.deleteRecord();\n\n    equal(get(recordArray, 'length'), 0, \"record is removed from the record array\");\n  }));\n});\n\n// GitHub Issue #168\ntest(\"a newly created record is removed from a record array when it is deleted\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter }),\n      recordArray;\n\n  recordArray = store.all(Person);\n\n  var scumbag = store.createRecord(Person, {\n    name: \"Scumbag Dale\"\n  });\n\n  equal(get(recordArray, 'length'), 1, \"precond - record array already has the first created item\");\n\n  // guarantee coalescence\n  Ember.run(function() {\n    store.createRecord(Person, { name: 'p1'});\n    store.createRecord(Person, { name: 'p2'});\n    store.createRecord(Person, { name: 'p3'});\n  });\n\n  equal(get(recordArray, 'length'), 4, \"precond - record array has the created item\");\n  equal(get(recordArray.objectAt(0), 'name'), \"Scumbag Dale\", \"item at index 0 is record with id 1\");\n\n  scumbag.deleteRecord();\n\n  equal(get(recordArray, 'length'), 3, \"record is removed from the record array\");\n\n  recordArray.objectAt(0).set('name', 'toto');\n\n  equal(get(recordArray, 'length'), 3, \"record is still removed from the record array\");\n});\n\ntest(\"a record array returns undefined when asking for a member outside of its content Array's range\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n\n  store.pushMany(Person, array);\n\n  var recordArray = store.all(Person);\n\n  strictEqual(recordArray.objectAt(20), undefined, \"objects outside of the range just return undefined\");\n});\n\n// This tests for a bug in the recordCache, where the records were being cached in the incorrect order.\ntest(\"a record array should be able to be enumerated in any order\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  store.pushMany(Person, array);\n\n  var recordArray = store.all(Person);\n\n  equal(get(recordArray.objectAt(2), 'id'), 3, \"should retrieve correct record at index 2\");\n  equal(get(recordArray.objectAt(1), 'id'), 2, \"should retrieve correct record at index 1\");\n  equal(get(recordArray.objectAt(0), 'id'), 1, \"should retrieve correct record at index 0\");\n});\n\nvar shouldContain = function(array, item) {\n  ok(indexOf(array, item) !== -1, \"array should contain \"+item.get('name'));\n};\n\nvar shouldNotContain = function(array, item) {\n  ok(indexOf(array, item) === -1, \"array should not contain \"+item.get('name'));\n};\n\ntest(\"an AdapterPopulatedRecordArray knows if it's loaded or not\", function() {\n  var env = setupStore({ person: Person }),\n      store = env.store;\n\n  env.adapter.findQuery = function(store, type, query, recordArray) {\n    return Ember.RSVP.resolve(array);\n  };\n\n  store.find('person', { page: 1 }).then(async(function(people) {\n    equal(get(people, 'isLoaded'), true, \"The array is now loaded\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/record_array_test");minispade.register('ember-data/~tests/unit/states_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar rootState, stateName;\n\nmodule(\"unit/states - Flags for record states\", {\n  setup: function() {\n    rootState = DS.RootState;\n  }\n});\n\nvar isTrue = function(flag) {\n  equal(get(rootState, stateName + \".\" + flag), true, stateName + \".\" + flag + \" should be true\");\n};\n\nvar isFalse = function(flag) {\n  equal(get(rootState, stateName + \".\" + flag), false, stateName + \".\" + flag + \" should be false\");\n};\n\ntest(\"the empty state\", function() {\n  stateName = \"empty\";\n  isFalse(\"isLoading\");\n  isFalse(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n});\n\ntest(\"the loading state\", function() {\n  stateName = \"loading\";\n  isTrue(\"isLoading\");\n  isFalse(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n});\n\ntest(\"the loaded state\", function() {\n  stateName = \"loaded\";\n  isFalse(\"isLoading\");\n  isTrue(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n});\n\ntest(\"the updated state\", function() {\n  stateName = \"loaded.updated\";\n  isFalse(\"isLoading\");\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n});\n\ntest(\"the saving state\", function() {\n  stateName = \"loaded.updated.inFlight\";\n  isFalse(\"isLoading\");\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isTrue(\"isSaving\");\n  isFalse(\"isDeleted\");\n});\n\ntest(\"the deleted state\", function() {\n  stateName = \"deleted\";\n  isFalse(\"isLoading\");\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isFalse(\"isSaving\");\n  isTrue(\"isDeleted\");\n});\n\ntest(\"the deleted.saving state\", function() {\n  stateName = \"deleted.inFlight\";\n  isFalse(\"isLoading\");\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isTrue(\"isSaving\");\n  isTrue(\"isDeleted\");\n});\n\ntest(\"the deleted.saved state\", function() {\n  stateName = \"deleted.saved\";\n  isFalse(\"isLoading\");\n  isTrue(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isTrue(\"isDeleted\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/states_test");minispade.register('ember-data/~tests/unit/store/adapter_interop_test', "(function() {var get = Ember.get, set = Ember.set;\nvar resolve = Ember.RSVP.resolve;\nvar TestAdapter;\n\nmodule(\"unit/store/adapter_interop - DS.Store working with a DS.Adapter\", {\n  setup: function() {\n    TestAdapter = DS.Adapter.extend();\n  }\n});\n\ntest(\"Calling Store#find invokes its adapter#find\", function() {\n  expect(4);\n\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      ok(true, \"Adapter#find was called\");\n      equal(store, currentStore, \"Adapter#find was called with the right store\");\n      equal(type,  currentType,  \"Adapter#find was called with the type passed into Store#find\");\n      equal(id,    1,            \"Adapter#find was called with the id passed into Store#find\");\n\n      return Ember.RSVP.resolve({ id: 1 });\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend();\n\n  currentStore.find(currentType, 1);\n});\n\ntest(\"Returning a promise from `find` asynchronously loads data\", function() {\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      return resolve({ id: 1, name: \"Scumbag Dale\" });\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  currentStore.find(currentType, 1).then(async(function(object) {\n    strictEqual(get(object, 'name'), \"Scumbag Dale\", \"the data was pushed\");\n  }));\n});\n\ntest(\"IDs provided as numbers are coerced to strings\", function() {\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      equal(typeof id, 'string', \"id has been normalized to a string\");\n      return resolve({ id: 1, name: \"Scumbag Sylvain\" });\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  currentStore.find(currentType, 1).then(async(function(object) {\n    equal(typeof object.get('id'), 'string', \"id was coerced to a string\");\n    currentStore.push(currentType, { id: 2, name: \"Scumbag Sam Saffron\" });\n    return currentStore.find(currentType, 2);\n  })).then(async(function(object) {\n    ok(object, \"object was found\");\n    equal(typeof object.get('id'), 'string', \"id is a string despite being supplied and searched for as a number\");\n  }));\n});\n\n\nvar array = [{ id: \"1\", name: \"Scumbag Dale\" }, { id: \"2\", name: \"Scumbag Katz\" }, { id: \"3\", name: \"Scumbag Bryn\" }];\n\ntest(\"can load data for the same record if it is not dirty\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  store.push(Person, { id: 1, name: \"Tom Dale\" });\n\n  var tom = store.find(Person, 1).then(async(function(tom) {\n    equal(get(tom, 'isDirty'), false, \"precond - record is not dirty\");\n    equal(get(tom, 'name'), \"Tom Dale\", \"returns the correct name\");\n\n    store.push(Person, { id: 1, name: \"Captain Underpants\" });\n    equal(get(tom, 'name'), \"Captain Underpants\", \"updated record with new date\");\n  }));\n\n});\n\n/*\ntest(\"DS.Store loads individual records without explicit IDs with a custom primaryKey\", function() {\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({ name: DS.attr('string'), primaryKey: 'key' });\n\n  store.load(Person, { key: 1, name: \"Tom Dale\" });\n\n  var tom = store.find(Person, 1);\n  equal(get(tom, 'name'), \"Tom Dale\", \"the person was successfully loaded for the given ID\");\n});\n*/\n\ntest(\"pushMany extracts ids from an Array of hashes if no ids are specified\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n\n  var Person = DS.Model.extend({ name: DS.attr('string') });\n\n  store.pushMany(Person, array);\n  store.find(Person, 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Scumbag Dale\", \"correctly extracted id for loaded data\");\n  }));\n});\n\ntest(\"loadMany takes an optional Object and passes it on to the Adapter\", function() {\n  var passedQuery = { page: 1 };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var adapter = TestAdapter.create({\n    findQuery: function(store, type, query) {\n      equal(type, Person, \"The type was Person\");\n      equal(query, passedQuery, \"The query was passed in\");\n      return Ember.RSVP.resolve([]);\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  store.find(Person, passedQuery);\n});\n\ntest(\"all(type) returns a record array of all records of a specific type\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  store.push(Person, { id: 1, name: \"Tom Dale\" });\n\n  var results = store.all(Person);\n  equal(get(results, 'length'), 1, \"record array should have the original object\");\n  equal(get(results.objectAt(0), 'name'), \"Tom Dale\", \"record has the correct information\");\n\n  store.push(Person, { id: 2, name: \"Yehuda Katz\" });\n  equal(get(results, 'length'), 2, \"record array should have the new object\");\n  equal(get(results.objectAt(1), 'name'), \"Yehuda Katz\", \"record has the correct information\");\n\n  strictEqual(results, store.all(Person), \"subsequent calls to all return the same recordArray)\");\n});\n\ntest(\"a new record of a particular type is created via store.createRecord(type)\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var person = store.createRecord(Person);\n\n  equal(get(person, 'isLoaded'), true, \"A newly created record is loaded\");\n  equal(get(person, 'isNew'), true, \"A newly created record is new\");\n  equal(get(person, 'isDirty'), true, \"A newly created record is dirty\");\n\n  set(person, 'name', \"Braaahm Dale\");\n\n  equal(get(person, 'name'), \"Braaahm Dale\", \"Even if no hash is supplied, `set` still worked\");\n});\n\ntest(\"a new record with a specific id can't be created if this id is already used in the store\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n  });\n\n  Person.reopenClass({\n    toString: function() {\n      return 'Person';\n    }\n  });\n\n  store.createRecord(Person, {id: 5});\n\n  expectAssertion(function() {\n    store.createRecord(Person, {id: 5});\n  }, /The id 5 has already been used with another record of type Person/);\n});\n\ntest(\"an initial data hash can be provided via store.createRecord(type, hash)\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var person = store.createRecord(Person, { name: \"Brohuda Katz\" });\n\n  equal(get(person, 'isLoaded'), true, \"A newly created record is loaded\");\n  equal(get(person, 'isNew'), true, \"A newly created record is new\");\n  equal(get(person, 'isDirty'), true, \"A newly created record is dirty\");\n\n  equal(get(person, 'name'), \"Brohuda Katz\", \"The initial data hash is provided\");\n});\n\ntest(\"if an id is supplied in the initial data hash, it can be looked up using `store.find`\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter });\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var person = store.createRecord(Person, { id: 1, name: \"Brohuda Katz\" });\n\n  store.find(Person, 1).then(async(function(again) {\n    strictEqual(person, again, \"the store returns the loaded object\");\n  }));\n});\n\ntest(\"records inside a collection view should have their ids updated\", function() {\n  var Person = DS.Model.extend();\n\n  var idCounter = 1;\n  var adapter = TestAdapter.create({\n    createRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({name: record.get('name'), id: idCounter++});\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var container = Ember.CollectionView.create({\n    content: store.all(Person)\n  });\n\n  container.appendTo('#qunit-fixture');\n\n  var tom = store.createRecord(Person, {name: 'Tom Dale'});\n  var yehuda = store.createRecord(Person, {name: 'Yehuda Katz'});\n\n  Ember.RSVP.all([ tom.save(), yehuda.save() ]).then(async(function() {\n    container.content.forEach(function(person, index) {\n      equal(person.get('id'), index + 1, \"The record's id should be correct.\");\n    });\n\n    container.destroy();\n  }));\n});\n\nvar stubAdapter, store;\n\nmodule(\"DS.Store - Adapter Callbacks\", {\n  setup: function() {\n    stubAdapter = Ember.Object.create({\n      extractId: function(type, hash) {\n        return hash.id;\n      },\n\n      materialize: function(record, hash) {\n        record.materializedData = hash;\n      }\n    });\n\n    store = DS.Store.create({ adapter: stubAdapter });\n  },\n\n  teardown: function() {\n    stubAdapter.destroy();\n    store.destroy();\n  }\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/store/adapter_interop_test");minispade.register('ember-data/~tests/unit/store/push_test', "(function() {var store, container, adapter, Person, PhoneNumber;\nvar attr = DS.attr, hasMany = DS.hasMany, belongsTo = DS.belongsTo;\n\nmodule(\"unit/store/push - DS.Store#push\", {\n  setup: function() {\n    container = new Ember.Container();\n    adapter = DS.Adapter.create();\n\n    Person = DS.Model.extend({\n      firstName: attr('string'),\n      lastName: attr('string'),\n      phoneNumbers: hasMany('phone-number')\n    });\n\n    PhoneNumber = DS.Model.extend({\n      number: attr('string'),\n      person: belongsTo('person')\n    });\n\n    store = DS.Store.create({\n      container: container,\n      adapter: adapter\n    });\n\n    var DefaultSerializer = DS.JSONSerializer.extend({\n      store: store\n    });\n\n    container.register('model:person', Person);\n    container.register('model:phone-number', PhoneNumber);\n    container.register('serializer:_default', DefaultSerializer);\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      store.destroy();\n      container.destroy();\n    });\n  }\n});\n\ntest(\"Calling push with a normalized hash returns a record\", function() {\n  var person = store.push('person', {\n    id: 'wat',\n    firstName: \"Yehuda\",\n    lastName: \"Katz\"\n  });\n\n  store.find('person', 'wat').then(async(function(foundPerson) {\n    equal(foundPerson, person, \"record returned via load() is the same as the record returned from find()\");\n    deepEqual(foundPerson.getProperties('id', 'firstName', 'lastName'), {\n      id: 'wat',\n      firstName: \"Yehuda\",\n      lastName: \"Katz\"\n    });\n  }));\n});\n\ntest(\"Calling push with a normalized hash containing related records returns a record\", function() {\n  var number1 = store.push('phone-number', {\n    id: 1,\n    number: '5551212',\n    person: 'wat'\n  });\n\n  var number2 = store.push('phone-number', {\n    id: 2,\n    number: '5552121',\n    person: 'wat'\n  });\n\n  var person = store.push('person', {\n    id: 'wat',\n    firstName: 'John',\n    lastName: 'Smith',\n    phoneNumbers: [number1, number2]\n  });\n\n  deepEqual(person.get('phoneNumbers').toArray(), [ number1, number2 ], \"phoneNumbers array is correct\");\n});\n\ntest(\"Calling push with a normalized hash containing IDs of related records returns a record\", function() {\n  Person.reopen({\n    phoneNumbers: hasMany('phone-number', { async: true })\n  });\n\n  var person = store.push('person', {\n    id: 'wat',\n    firstName: 'John',\n    lastName: 'Smith',\n    phoneNumbers: [\"1\", \"2\"]\n  });\n\n  adapter.find = function(store, type, id) {\n    if (id === \"1\") {\n      return Ember.RSVP.resolve({\n        id: 1,\n        number: '5551212',\n        person: 'wat'\n      });\n    }\n\n    if (id === \"2\") {\n      return Ember.RSVP.resolve({\n        id: 2,\n        number: '5552121',\n        person: 'wat'\n      });\n    }\n  };\n\n  person.get('phoneNumbers').then(async(function(phoneNumbers) {\n    deepEqual(phoneNumbers.map(function(item) {\n      return item.getProperties('id', 'number', 'person');\n    }), [{\n      id: \"1\",\n      number: '5551212',\n      person: person\n    }, {\n      id: \"2\",\n      number: '5552121',\n      person: person\n    }]);\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/store/push_test");minispade.register('ember-data/~tests/unit/store/serializer_for_test', "(function() {var container, store, app;\n\nmodule(\"unit/store/serializer_for - DS.Store#serializerFor\", {\n  setup: function() {\n    container = new Ember.Container();\n\n    store = DS.Store.create({\n      container: container\n    });\n  },\n\n  teardown: function() {\n    container.destroy();\n    store.destroy();\n\n    if (app) { app.destroy(); }\n  }\n});\n\ntest(\"Calling serializerFor looks up 'serializer:<type>' from the container\", function() {\n  var PersonSerializer = DS.JSONSerializer.extend();\n\n  container.register('serializer:person', PersonSerializer);\n\n  ok(store.serializerFor('person') instanceof PersonSerializer, \"serializer returned from serializerFor is an instance of the registered Serializer class\");\n});\n\ntest(\"Calling serializerFor with a type that has not been registered looks up the default ApplicationSerializer\", function() {\n  var ApplicationSerializer = DS.JSONSerializer.extend();\n\n  container.register('serializer:application', ApplicationSerializer);\n\n  ok(store.serializerFor('person') instanceof ApplicationSerializer, \"serializer returned from serializerFor is an instance of ApplicationSerializer\");\n});\n\ntest(\"Calling serializerFor with a type that has not been registered and in an application that does not have an ApplicationSerializer looks up the default Ember Data serializer\", function() {\n  Ember.run(function() {\n    app = Ember.Application.create();\n    app.Store = DS.Store.extend();\n    app.advanceReadiness();\n  });\n\n  var store = app.__container__.lookup('store:main');\n\n  ok(store.serializerFor('person') instanceof DS.JSONSerializer, \"serializer returned from serializerFor is an instance of DS.JSONSerializer\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/store/serializer_for_test");minispade.register('ember-data/~tests/unit/store/unload_test', "(function() {var get = Ember.get, set = Ember.set;\nvar store, tryToFind, Record;\n\nmodule(\"unit/store/unload - Store unloading records\", {\n  setup: function() {\n    store = DS.Store.create({\n      adapter: DS.Adapter.create({\n        find: function(store, type, id) {\n          tryToFind = true;\n          return Ember.RSVP.resolve({ id: id, wasFetched: true });\n        }\n      })\n    });\n\n    Record = DS.Model.extend({\n      title: DS.attr('string')\n    });\n  },\n\n  teardown: function() {\n    store.destroy();\n  }\n});\n\ntest(\"unload a dirty record\", function() {\n  store.push(Record, {id: 1, title: 'toto'});\n\n  store.find(Record, 1).then(async(function(record) {\n    record.set('title', 'toto2');\n\n    equal(get(record, 'isDirty'), true, \"record is dirty\");\n    expectAssertion(function() {\n      record.unloadRecord();\n    }, \"You can only unload a loaded, non-dirty record.\", \"can not unload dirty record\");\n  }));\n});\n\ntest(\"unload a record\", function() {\n  store.push(Record, {id: 1, title: 'toto'});\n\n  store.find(Record, 1).then(async(function(record) {\n    equal(get(record, 'id'), 1, \"found record with id 1\");\n    equal(get(record, 'isDirty'), false, \"record is not dirty\");\n\n    store.unloadRecord(record);\n\n    equal(get(record, 'isDirty'), false, \"record is not dirty\");\n    equal(get(record, 'isDeleted'), true, \"record is deleted\");\n\n    tryToFind = false;\n    store.find(Record, 1);\n    equal(tryToFind, true, \"not found record with id 1\");\n  }));\n});\n\nmodule(\"DS.Store - unload record with relationships\");\n\ntest(\"can commit store after unload record with relationships\", function() {\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      find: function() {\n        return Ember.RSVP.resolve({ id: 1, description: 'cuisinart', brand: 1 });\n      },\n      createRecord: function(store, type, record) {\n        return Ember.RSVP.resolve();\n      }\n    })\n  });\n\n  var like, product, brand;\n\n  var Brand = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Product = DS.Model.extend({\n    description: DS.attr('string'),\n    brand: DS.belongsTo(Brand)\n  });\n\n  var Like = DS.Model.extend({\n    product: DS.belongsTo(Product)\n  });\n\n  store.push(Brand, { id: 1, name: 'EmberJS' });\n  store.push(Product, { id: 1, description: 'toto', brand: 1 });\n\n  var asyncRecords = Ember.RSVP.hash({\n    brand: store.find(Brand, 1),\n    product: store.find(Product, 1)\n  });\n\n  asyncRecords.then(async(function(records) {\n    like = store.createRecord(Like, { id: 1, product: product });\n    records.like = like.save();\n    return Ember.RSVP.hash(records);\n  })).then(async(function(records) {\n    store.unloadRecord(records.product);\n\n    return store.find(Product, 1);\n  })).then(async(function(product) {\n    equal(product.get('description'), 'cuisinart', \"The record was unloaded and the adapter's `find` was called\");\n    store.destroy();\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/store/unload_test");minispade.register('ember-inflector/~tests/system/inflector_test', "(function() {module('ember-inflector.unit');\n\ntest('plurals', function() {\n  expect(1);\n\n  var inflector = new Ember.Inflector({\n    plurals: [\n      [/$/, 's'],\n      [/s$/i, 's']\n    ]\n  });\n\n  equal(inflector.pluralize('apple'), 'apples');\n});\n\ntest('singularization',function(){\n  expect(1);\n\n  var inflector = new Ember.Inflector({\n    singular: [\n      [/s$/i, ''],\n      [/(ss)$/i, '$1']\n    ]\n  });\n\n  equal(inflector.singularize('apple'), 'apple');\n});\n\ntest('plural',function(){\n  expect(1);\n\n  var inflector = new Ember.Inflector({\n    plurals: [\n      ['1', '1'],\n      ['2', '2'],\n      ['3', '3']\n    ]\n  });\n\n  equal(inflector.rules.plurals.length, 3);\n});\n\ntest('singular',function(){\n  expect(1);\n\n  var inflector = new Ember.Inflector({\n    singular: [\n      ['1', '1'],\n      ['2', '2'],\n      ['3', '3']\n    ]\n  });\n\n  equal(inflector.rules.singular.length, 3);\n});\n\ntest('irregular',function(){\n  expect(6);\n\n  var inflector = new Ember.Inflector({\n    irregularPairs: [\n      ['1', '12'],\n      ['2', '22'],\n      ['3', '32']\n    ]\n  });\n\n  equal(inflector.rules.irregular['1'], '12');\n  equal(inflector.rules.irregular['2'], '22');\n  equal(inflector.rules.irregular['3'], '32');\n\n  equal(inflector.rules.irregularInverse['12'], '1');\n  equal(inflector.rules.irregularInverse['22'], '2');\n  equal(inflector.rules.irregularInverse['32'], '3');\n});\n\ntest('uncountable',function(){\n  expect(3);\n\n  var inflector = new Ember.Inflector({\n    uncountable: [\n      '1',\n      '2',\n      '3'\n    ]\n  });\n\n  equal(inflector.rules.uncountable['1'], true);\n  equal(inflector.rules.uncountable['2'], true);\n  equal(inflector.rules.uncountable['3'], true);\n});\n\ntest('inflect.nothing', function(){\n  expect(2);\n\n  var inflector = new Ember.Inflector();\n\n  equal(inflector.inflect('',  []), '');\n  equal(inflector.inflect(' ', []), ' ');\n});\n\ntest('inflect.noRules',function(){\n  expect(1);\n\n  var inflector = new Ember.Inflector();\n\n  equal(inflector.inflect('word', []),'word');\n});\n\ntest('inflect.uncountable', function(){\n  expect(1);\n\n  var inflector = new Ember.Inflector({\n    plural: [\n      [/$/,'s']\n    ],\n    uncountable: [\n      'word'\n    ]\n  });\n\n  var rules = [];\n\n  equal(inflector.inflect('word', rules), 'word');\n});\n\ntest('inflect.irregular', function(){\n  expect(2);\n\n  var inflector = new Ember.Inflector({\n    irregularPairs: [\n      ['word', 'wordy']\n    ]\n  });\n\n  var rules = [];\n\n  equal(inflector.inflect('word', rules), 'wordy');\n  equal(inflector.inflect('wordy', rules), 'word');\n});\n\ntest('inflect.basicRules', function(){\n  expect(1);\n\n  var inflector = new Ember.Inflector();\n  var rules = [[/$/, 's']];\n\n  equal(inflector.inflect('word', rules ), 'words');\n});\n\ntest('inflect.advancedRules', function(){\n  expect(1);\n\n  var inflector = new Ember.Inflector();\n  var rules = [[/^(ox)$/i, '$1en']];\n\n  equal(inflector.inflect('ox', rules), 'oxen');\n});\n\n})();\n//@ sourceURL=ember-inflector/~tests/system/inflector_test");minispade.register('ember-inflector/~tests/system/integration_test', "(function() {module(\"ember-inflector.integration\");\n\ntest(\"pluralize\", function(){\n  expect(3);\n\n  equal(Ember.String.pluralize('word'),     'words');\n  equal(Ember.String.pluralize('ox'),       'oxen');\n  equal(Ember.String.pluralize('octopus'),  'octopi');\n});\n\ntest(\"singularize\", function(){\n  expect(3);\n\n  equal(Ember.String.singularize('words'),  'word');\n  equal(Ember.String.singularize('oxen'),   'ox');\n  equal(Ember.String.singularize('octopi'), 'octopus');\n});\n\n})();\n//@ sourceURL=ember-inflector/~tests/system/integration_test");