var define, requireModule;

(function() {
  var registry = {}, seen = {};

  define = function(name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  requireModule = function(name) {
    if (seen[name]) { return seen[name]; }
    seen[name] = {};

    var mod, deps, callback, reified , exports;

    mod = registry[name];

    if (!mod) {
      throw new Error("Module '" + name + "' not found.");
    }

    deps = mod.deps;
    callback = mod.callback;
    reified = [];
    exports;

    for (var i=0, l=deps.length; i<l; i++) {
      if (deps[i] === 'exports') {
        reified.push(exports = {});
      } else {
        reified.push(requireModule(deps[i]));
      }
    }

    var value = callback.apply(this, reified);
    return seen[name] = exports || value;
  };
})();
minispade.register('ember-data/adapters', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/adapters/fixture_adapter\");\nminispade.require(\"ember-data/adapters/rest_adapter\");\n\n})();\n//@ sourceURL=ember-data/adapters");minispade.register('ember-data/adapters/fixture_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require(\"ember-data/system/adapter\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, fmt = Ember.String.fmt,\n    indexOf = Ember.EnumerableUtils.indexOf;\n\nvar counter = 0;\n\n/**\n  `DS.FixtureAdapter` is an adapter that loads records from memory.\n  Its primarily used for development and testing. You can also use\n  `DS.FixtureAdapter` while working on the API but are not ready to\n  integrate yet. It is a fully functioning adapter. All CRUD methods\n  are implemented. You can also implement query logic that a remote\n  system would do. Its possible to do develop your entire application\n  with `DS.FixtureAdapter`.\n\n  @class FixtureAdapter\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.FixtureAdapter = DS.Adapter.extend({\n  // by default, fixtures are already in normalized form\n  serializer: null,\n\n  simulateRemoteResponse: true,\n\n  latency: 50,\n\n  /**\n    Implement this method in order to provide data associated with a type\n\n    @method fixturesForType\n    @param  type\n  */\n  fixturesForType: function(type) {\n    if (type.FIXTURES) {\n      var fixtures = Ember.A(type.FIXTURES);\n      return fixtures.map(function(fixture){\n        var fixtureIdType = typeof fixture.id;\n        if(fixtureIdType !== \"number\" && fixtureIdType !== \"string\"){\n          throw new Error(fmt('the id property must be defined as a number or string for fixture %@', [fixture]));\n        }\n        fixture.id = fixture.id + '';\n        return fixture;\n      });\n    }\n    return null;\n  },\n\n  /**\n    Implement this method in order to query fixtures data\n\n    @method queryFixtures\n    @param  fixture\n    @param  query\n    @param  type\n  */\n  queryFixtures: function(fixtures, query, type) {\n    Ember.assert('Not implemented: You must override the DS.FixtureAdapter::queryFixtures method to support querying the fixture store.');\n  },\n\n  /**\n    @method updateFixtures\n    @param  type\n    @param  fixture\n  */\n  updateFixtures: function(type, fixture) {\n    if(!type.FIXTURES) {\n      type.FIXTURES = [];\n    }\n\n    var fixtures = type.FIXTURES;\n\n    this.deleteLoadedFixture(type, fixture);\n\n    fixtures.push(fixture);\n  },\n\n  /**\n    Implement this method in order to provide provide json for CRUD methods\n\n    @method mockJSON\n    @param  type\n    @param  record\n  */\n  mockJSON: function(store, type, record) {\n    return store.serializerFor(type).serialize(record, { includeId: true });\n  },\n\n  /**\n    @method generateIdForRecord\n    @param  store\n    @param  record\n  */\n  generateIdForRecord: function(store) {\n    return counter++;\n  },\n\n  /**\n    @method find\n    @param  store\n    @param  type\n    @param  id\n  */\n  find: function(store, type, id) {\n    var fixtures = this.fixturesForType(type),\n        fixture;\n\n    Ember.warn(\"Unable to find fixtures for model type \" + type.toString(), fixtures);\n\n    if (fixtures) {\n      fixture = Ember.A(fixtures).findProperty('id', id);\n    }\n\n    if (fixture) {\n      return this.simulateRemoteCall(function() {\n        return fixture;\n      }, this);\n    }\n  },\n\n  /**\n    @method findMany\n    @param  store\n    @param  type\n    @param  ids\n  */\n  findMany: function(store, type, ids) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), !!fixtures);\n\n    if (fixtures) {\n      fixtures = fixtures.filter(function(item) {\n        return indexOf(ids, item.id) !== -1;\n      });\n    }\n\n    if (fixtures) {\n      return this.simulateRemoteCall(function() {\n        return fixtures;\n      }, this);\n    }\n  },\n\n  /**\n    @method findAll\n    @param  store\n    @param  type\n  */\n  findAll: function(store, type) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), !!fixtures);\n\n    return this.simulateRemoteCall(function() {\n      return fixtures;\n    }, this);\n  },\n\n  /**\n    @method findQuery\n    @param  store\n    @param  type\n    @param  query\n    @param  array\n  */\n  findQuery: function(store, type, query, array) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), !!fixtures);\n\n    fixtures = this.queryFixtures(fixtures, query, type);\n\n    if (fixtures) {\n      return this.simulateRemoteCall(function() {\n        return fixtures;\n      }, this);\n    }\n  },\n\n  /**\n    @method createRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  createRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.updateFixtures(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      return fixture;\n    }, this);\n  },\n\n  /**\n    @method updateRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  updateRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.updateFixtures(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      return fixture;\n    }, this);\n  },\n\n  /**\n    @method deleteRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  deleteRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.deleteLoadedFixture(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      // no payload in a deletion\n      return null;\n    });\n  },\n\n  /*\n    @method deleteLoadedFixture\n    @private\n    @param type\n    @param record\n  */\n  deleteLoadedFixture: function(type, record) {\n    var existingFixture = this.findExistingFixture(type, record);\n\n    if(existingFixture) {\n      var index = indexOf(type.FIXTURES, existingFixture);\n      type.FIXTURES.splice(index, 1);\n      return true;\n    }\n  },\n\n  /*\n    @method findExistingFixture\n    @private\n    @param type\n    @param record\n  */\n  findExistingFixture: function(type, record) {\n    var fixtures = this.fixturesForType(type);\n    var id = get(record, 'id');\n\n    return this.findFixtureById(fixtures, id);\n  },\n\n  /*\n    @method findFixtureById\n    @private\n    @param type\n    @param record\n  */\n  findFixtureById: function(fixtures, id) {\n    return Ember.A(fixtures).find(function(r) {\n      if(''+get(r, 'id') === ''+id) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  },\n\n  /*\n    @method simulateRemoteCall\n    @private\n    @param callback\n    @param context\n  */\n  simulateRemoteCall: function(callback, context) {\n    var adapter = this;\n\n    return new Ember.RSVP.Promise(function(resolve) {\n      if (get(adapter, 'simulateRemoteResponse')) {\n        // Schedule with setTimeout\n        Ember.run.later(function() {\n          resolve(callback.call(context));\n        }, get(adapter, 'latency'));\n      } else {\n        // Asynchronous, but at the of the runloop with zero latency\n        Ember.run.once(function() {\n          resolve(callback.call(context));\n        });\n      }\n    });\n  }\n});\n\n})();\n//@ sourceURL=ember-data/adapters/fixture_adapter");minispade.register('ember-data/adapters/rest_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require('ember-data/system/adapter');\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.ArrayPolyfills.forEach;\n\nDS.rejectionHandler = function(reason) {\n  Ember.Logger.assert([reason, reason.message, reason.stack]);\n\n  throw reason;\n};\n\nfunction coerceId(id) {\n  return id == null ? null : id+'';\n}\n\nDS.RESTSerializer = DS.JSONSerializer.extend({\n  /**\n    Normalizes a part of the JSON payload returned by\n    the server. You should override this method, munge the hash\n    and call super if you have generic normalization to do.\n\n    It takes the type of the record that is being normalized\n    (as a DS.Model class), the property where the hash was\n    originally found, and the hash to normalize.\n\n    For example, if you have a payload that looks like this:\n\n    ```js\n    {\n      \"post\": {\n        \"id\": 1,\n        \"title\": \"Rails is omakase\",\n        \"comments\": [ 1, 2 ]\n      },\n      \"comments\": [{\n        \"id\": 1,\n        \"body\": \"FIRST\"\n      }, {\n        \"id\": 2,\n        \"body\": \"Rails is unagi\"\n      }]\n    }\n    ```\n\n    The `normalize` method will be called three times:\n\n    * With `App.Post`, `\"posts\"` and `{ id: 1, title: \"Rails is omakase\", ... }`\n    * With `App.Comment`, `\"comments\"` and `{ id: 1, body: \"FIRST\" }`\n    * With `App.Comment`, `\"comments\"` and `{ id: 2, body: \"Rails is unagi\" }`\n\n    You can use this method, for example, to normalize underscored keys to camelized\n    or other general-purpose normalizations.\n\n    If you want to do normalizations specific to some part of the payload, you\n    can specify those under `normalizeHash`.\n\n    For example, if the `IDs` under `\"comments\"` are provided as `_id` instead of\n    `id`, you can specify how to normalize just the comments:\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      normalizeHash: {\n        comments: function(hash) {\n          hash.id = hash._id;\n          delete hash._id;\n          return hash;\n        }\n      }\n    });\n    ```\n\n    The key under `normalizeHash` is just the original key that was in the original\n    payload.\n\n    @method normalize\n    @param {subclass of DS.Model} type\n    @param {String} prop\n    @param {Object} hash\n    @returns Object\n  */\n  normalize: function(type, prop, hash) {\n    this.normalizeId(hash);\n    this.normalizeAttributes(hash);\n\n    if (this.normalizeHash && this.normalizeHash[prop]) {\n      return this.normalizeHash[prop](hash);\n    }\n\n    return hash;\n  },\n\n  /**\n    @method normalizeId\n    @private\n  */\n  normalizeId: function(hash) {\n    var primaryKey = get(this, 'primaryKey');\n\n    if (primaryKey === 'id') { return; }\n\n    hash.id = hash[primaryKey];\n    delete hash[primaryKey];\n  },\n\n  /**\n    @method normalizeAttributes\n    @private\n  */\n  normalizeAttributes: function(hash) {\n    var attrs = get(this, 'attrs');\n\n    if (!attrs) { return; }\n\n    for (var key in attrs) {\n      var payloadKey = attrs[key];\n\n      hash[key] = hash[payloadKey];\n      delete hash[payloadKey];\n    }\n  },\n\n  /**\n    Called when the server has returned a payload representing\n    a single record, such as in response to a `find` or `save`.\n\n    It is your opportunity to clean up the server's response into the normalized\n    form expected by Ember Data.\n\n    If you want, you can just restructure the top-level of your payload, and\n    do more fine-grained normalization in the `normalize` method.\n\n    For example, if you have a payload like this in response to a request for\n    post 1:\n\n    ```js\n    {\n      \"id\": 1,\n      \"title\": \"Rails is omakase\",\n\n      \"_embedded\": {\n        \"comment\": [{\n          \"_id\": 1,\n          \"comment_title\": \"FIRST\"\n        }, {\n          \"_id\": 2,\n          \"comment_title\": \"Rails is unagi\"\n        }]\n      }\n    }\n    ```\n\n    You could implement a serializer that looks like this to get your payload\n    into shape:\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      // First, restructure the top-level so it's organized by type\n      extractSingle: function(store, type, payload, id, requestType) {\n        var comments = payload._embedded.comment;\n        delete payload._embedded;\n\n        payload = { comments: comments, post: payload };\n        return this._super(store, type, payload, id, requestType);\n      },\n\n      normalizeHash: {\n        // Next, normalize individual comments, which (after `extract`)\n        // are now located under `comments`\n        comments: function(hash) {\n          hash.id = hash._id;\n          hash.title = hash.comment_title;\n          delete hash._id;\n          delete hash.comment_title;\n          return hash;\n        }\n      }\n    })\n    ```\n\n    When you call super from your own implementation of `extractSingle`, the\n    built-in implementation will find the primary record in your normalized\n    payload and push the remaining records into the store.\n\n    The primary record is the single hash found under `post` or the first\n    element of the `posts` array.\n\n    The primary record has special meaning when the record is being created\n    for the first time or updated (`createRecord` or `updateRecord`). In\n    particular, it will update the properties of the record that was saved.\n\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @param {String} id\n    @param {'find'|'createRecord'|'updateRecord'|'deleteRecord'} requestType\n    @returns Object the primary response to the original request\n  */\n  extractSingle: function(store, primaryType, payload, recordId, requestType) {\n    var primaryTypeName = primaryType.typeKey,\n        primaryRecord;\n\n    for (var prop in payload) {\n      // legacy support for singular names\n      if (prop === primaryTypeName) {\n        primaryRecord = this.normalize(primaryType, prop, payload[prop]);\n        continue;\n      }\n\n      var typeName = this.singularize(prop),\n          type = store.modelFor(typeName);\n\n      /*jshint loopfunc:true*/\n      forEach.call(payload[prop], function(hash) {\n        hash = this.normalize(type, prop, hash);\n\n        var isFirstCreatedRecord = typeName === primaryTypeName && !recordId && !primaryRecord,\n            isUpdatedRecord = typeName === primaryTypeName && coerceId(hash.id) === recordId;\n\n        // find the primary record.\n        //\n        // It's either:\n        // * the record with the same ID as the original request\n        // * in the case of a newly created record that didn't have an ID, the first\n        //   record in the Array\n        if (isFirstCreatedRecord || isUpdatedRecord) {\n          primaryRecord = hash;\n        } else {\n          store.push(typeName, hash);\n        }\n      }, this);\n    }\n\n    return primaryRecord;\n  },\n\n  /**\n    Called when the server has returned a payload representing\n    multiple records, such as in response to a `findAll` or `findQuery`.\n\n    It is your opportunity to clean up the server's response into the normalized\n    form expected by Ember Data.\n\n    If you want, you can just restructure the top-level of your payload, and\n    do more fine-grained normalization in the `normalize` method.\n\n    For example, if you have a payload like this in response to a request for\n    all posts:\n\n    ```js\n    {\n      \"_embedded\": {\n        \"post\": [{\n          \"id\": 1,\n          \"title\": \"Rails is omakase\"\n        }, {\n          \"id\": 2,\n          \"title\": \"The Parley Letter\"\n        }],\n        \"comment\": [{\n          \"_id\": 1,\n          \"comment_title\": \"Rails is unagi\"\n          \"post_id\": 1\n        }, {\n          \"_id\": 2,\n          \"comment_title\": \"Don't tread on me\",\n          \"post_id\": 2\n        }]\n      }\n    }\n    ```\n\n    You could implement a serializer that looks like this to get your payload\n    into shape:\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      // First, restructure the top-level so it's organized by type\n      // and the comments are listed under a post's `comments` key.\n      extractArray: function(store, type, payload, id, requestType) {\n        var posts = payload._embedded.post;\n        var comments = [];\n        var postCache = {};\n\n        posts.forEach(function(post) {\n          post.comments = [];\n          postCache[post.id] = post;\n        });\n\n        payload._embedded.comment.forEach(function(comment) {\n          comments.push(comment);\n          postCache[comment.post_id].comments.push(comment);\n          delete comment.post_id;\n        }\n\n        payload = { comments: comments, posts: payload };\n\n        return this._super(store, type, payload, id, requestType);\n      },\n\n      normalizeHash: {\n        // Next, normalize individual comments, which (after `extract`)\n        // are now located under `comments`\n        comments: function(hash) {\n          hash.id = hash._id;\n          hash.title = hash.comment_title;\n          delete hash._id;\n          delete hash.comment_title;\n          return hash;\n        }\n      }\n    })\n    ```\n\n    When you call super from your own implementation of `extractArray`, the\n    built-in implementation will find the primary array in your normalized\n    payload and push the remaining records into the store.\n\n    The primary array is the array found under `posts`.\n\n    The primary record has special meaning when responding to `findQuery`\n    or `findHasMany`. In particular, the primary array will become the\n    list of records in the record array that kicked off the request.\n\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} payload\n    @param {'findAll'|'findMany'|'findHasMany'|'findQuery'} requestType\n    @returns {Array<Object>} The primary array that was returned in response\n      to the original query.\n  */\n  extractArray: function(store, primaryType, payload) {\n    var primaryTypeName = primaryType.typeKey,\n        primaryArray;\n\n    for (var prop in payload) {\n      var typeName = this.singularize(prop),\n          type = store.modelFor(typeName),\n          isPrimary = typeName === primaryTypeName;\n\n      /*jshint loopfunc:true*/\n      var normalizedArray = payload[prop].map(function(hash) {\n        return this.normalize(type, prop, hash);\n      }, this);\n\n      if (isPrimary) {\n        primaryArray = normalizedArray;\n      } else {\n        store.pushMany(typeName, normalizedArray);\n      }\n    }\n\n    return primaryArray;\n  },\n\n  /**\n    @private\n    @method pluralize\n    @param {String} key\n  */\n  pluralize: function(key) {\n    return Ember.String.pluralize(key);\n  },\n\n  /**\n    @private\n    @method singularize\n    @param {String} key\n  */\n  singularize: function(key) {\n    return Ember.String.singularize(key);\n  },\n\n  // SERIALIZE\n\n  /**\n    Called when a record is saved in order to convert the\n    record into JSON.\n\n    By default, it creates a JSON object with a key for\n    each attribute and belongsTo relationship.\n\n    For example, consider this model:\n\n    ```js\n    App.Comment = DS.Model.extend({\n      title: DS.attr(),\n      body: DS.attr(),\n\n      author: DS.belongsTo('user')\n    });\n    ```\n\n    The default serialization would create a JSON object like:\n\n    ```js\n    {\n      \"title\": \"Rails is unagi\",\n      \"body\": \"Rails? Omakase? O_O\",\n      \"author\": 12\n    }\n    ```\n\n    By default, attributes are passed through as-is, unless\n    you specified an attribute type (`DS.attr('date')`). If\n    you specify a transform, the JavaScript value will be\n    serialized when inserted into the JSON hash.\n\n    By default, belongs-to relationships are converted into\n    IDs when inserted into the JSON hash.\n\n    ## IDs\n\n    `serialize` takes an options hash with a single option:\n    `includeId`. If this option is `true`, `serialize` will,\n    by default include the ID in the JSON object it builds.\n\n    The adapter passes in `includeId: true` when serializing\n    a record for `createRecord`, but not for `updateRecord`.\n\n    ## Customization\n\n    Your server may expect a different JSON format than the\n    built-in serialization format.\n\n    In that case, you can implement `serialize` yourself and\n    return a JSON hash of your choosing.\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      serialize: function(post, options) {\n        var json = {\n          POST_TTL: post.get('title'),\n          POST_BDY: post.get('body'),\n          POST_CMS: post.get('comments').mapProperty('id')\n        }\n\n        if (options.includeId) {\n          json.POST_ID_ = post.get('id');\n        }\n\n        return json;\n      }\n    });\n    ```\n\n    ## Customizing an App-Wide Serializer\n\n    If you want to define a serializer for your entire\n    application, you'll probably want to use `eachAttribute`\n    and `eachRelationship` on the record.\n\n    ```js\n    App.ApplicationSerializer = DS.RESTSerializer.extend({\n      serialize: function(record, options) {\n        var json = {};\n\n        record.eachAttribute(function(name) {\n          json[serverAttributeName(name)] = record.get(name);\n        })\n\n        record.eachRelationship(function(name, relationship) {\n          if (relationship.kind === 'hasMany') {\n            json[serverHasManyName(name)] = record.get(name).mapBy('id');\n          }\n        });\n\n        if (options.includeId) {\n          json.ID_ = record.get('id');\n        }\n\n        return json;\n      }\n    });\n\n    function serverAttributeName(attribute) {\n      return attribute.underscore().toUpperCase();\n    }\n\n    function serverHasManyName(name) {\n      return serverAttributeName(name.singularize()) + \"_IDS\";\n    }\n    ```\n\n    This serializer will generate JSON that looks like this:\n\n    ```js\n    {\n      \"TITLE\": \"Rails is omakase\",\n      \"BODY\": \"Yep. Omakase.\",\n      \"COMMENT_IDS\": [ 1, 2, 3 ]\n    }\n    ```\n\n    ## Tweaking the Default JSON\n\n    If you just want to do some small tweaks on the default JSON,\n    you can call super first and make the tweaks on the returned\n    JSON.\n\n    ```js\n    App.PostSerializer = DS.RESTSerializer.extend({\n      serialize: function(record, options) {\n        var json = this._super(record, options);\n\n        json.subject = json.title;\n        delete json.title;\n\n        return json;\n      }\n    });\n    ```\n  */\n  serialize: function(record, options) {\n    return this._super.apply(this, arguments);\n  }\n});\n\n/**\n  The REST adapter allows your store to communicate with an HTTP server by\n  transmitting JSON via XHR. Most Ember.js apps that consume a JSON API\n  should use the REST adapter.\n\n  This adapter is designed around the idea that the JSON exchanged with\n  the server should be conventional.\n\n  ## JSON Structure\n\n  The REST adapter expects the JSON returned from your server to follow\n  these conventions.\n\n  ### Object Root\n\n  The JSON payload should be an object that contains the record inside a\n  root property. For example, in response to a `GET` request for\n  `/posts/1`, the JSON should look like this:\n\n  ```js\n  {\n    \"post\": {\n      title: \"I'm Running to Reform the W3C's Tag\",\n      author: \"Yehuda Katz\"\n    }\n  }\n  ```\n\n  ### Conventional Names\n\n  Attribute names in your JSON payload should be the underscored versions of\n  the attributes in your Ember.js models.\n\n  For example, if you have a `Person` model:\n\n  ```js\n  App.Person = DS.Model.extend({\n    firstName: DS.attr('string'),\n    lastName: DS.attr('string'),\n    occupation: DS.attr('string')\n  });\n  ```\n\n  The JSON returned should look like this:\n\n  ```js\n  {\n    \"person\": {\n      \"first_name\": \"Barack\",\n      \"last_name\": \"Obama\",\n      \"occupation\": \"President\"\n    }\n  }\n  ```\n\n  ## Customization\n\n  ### Endpoint path customization\n\n  Endpoint paths can be prefixed with a `namespace` by setting the namespace\n  property on the adapter:\n\n  ```js\n  DS.RESTAdapter.reopen({\n    namespace: 'api/1'\n  });\n  ```\n  Requests for `App.Person` would now target `/api/1/people/1`.\n\n  ### Host customization\n\n  An adapter can target other hosts by setting the `host` property.\n\n  ```js\n  DS.RESTAdapter.reopen({\n    host: 'https://api.example.com'\n  });\n  ```\n\n  ### Headers customization\n\n  Some APIs require HTTP headers, eg to provide an API key. An array of\n  headers can be added to the adapter which are passed with every request:\n\n  ```js\n  DS.RESTAdapter.reopen({\n    headers: {\n      \"API_KEY\": \"secret key\",\n      \"ANOTHER_HEADER\": \"asdsada\"\n    }\n  });\n  ```\n\n  @class RESTAdapter\n  @constructor\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.RESTAdapter = DS.Adapter.extend({\n  defaultSerializer: '_rest',\n\n  /**\n    Called by the store in order to fetch the JSON for a given\n    type and ID.\n\n    It makes an Ajax request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @method find\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {String} id\n    @returns Promise\n  */\n  find: function(store, type, id) {\n    return this.ajax(this.buildURL(type, id), 'GET');\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for all\n    of the records for a given type.\n\n    It makes an Ajax request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @method findAll\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @returns Promise\n  */\n  findAll: function(store, type) {\n    return this.ajax(this.buildURL(type), 'GET');\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the records that match a particular query.\n\n    The query is a simple JavaScript object that will be passed directly\n    to the server as parameters.\n\n    It makes an Ajax request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @method findQuery\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} query\n    @returns Promise\n  */\n  findQuery: function(store, type, query) {\n    return this.ajax(this.buildURL(type), 'GET', { data: query });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a has-many relationship that were originally\n    specified as IDs.\n\n    For example, if the original payload looks like:\n\n    ```js\n    {\n      \"id\": 1,\n      \"title\": \"Rails is omakase\",\n      \"comments\": [ 1, 2, 3 ]\n    }\n    ```\n\n    The IDs will be passed as a URL-encoded Array of IDs, in this form:\n\n    ```\n    ids[]=1&ids[]=2&ids[]=3\n    ```\n\n    Many servers, such as Rails and PHP, will automatically convert this\n    into an Array for you on the server-side. If you want to encode the\n    IDs, differently, just override this (one-line) method.\n\n    It makes an Ajax request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @method findMany\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Array<String>} ids\n    @returns Promise\n  */\n  findMany: function(store, type, ids) {\n    return this.ajax(this.buildURL(type), 'GET', { data: { ids: ids } });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a has-many relationship that were originally\n    specified as a URL (inside of `links`).\n\n    For example, if your original payload looks like this:\n\n    ```js\n    {\n      \"post\": {\n        \"id\": 1,\n        \"title\": \"Rails is omakase\",\n        \"links\": { \"comments\": \"/posts/1/comments\" }\n      }\n    }\n    ```\n\n    This method will be called with the parent record and `/posts/1/comments`.\n\n    It will make an Ajax request to the originally specified URL.\n\n    @method findHasMany\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {DS.Model} record\n    @param {String} url\n    @returns Promise\n  */\n  findHasMany: function(store, record, url) {\n    return this.ajax(url, 'GET');\n  },\n\n  /**\n    Called by the store when a newly created record is\n    `save`d.\n\n    It serializes the record, and `POST`s it to a URL generated by `buildURL`.\n\n    See `serialize` for information on how to customize the serialized form\n    of a record.\n\n    @method createRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  createRecord: function(store, type, record) {\n    var data = {};\n    data[type.typeKey] = this.serializerFor(type.typeKey).serialize(record, { includeId: true });\n\n    return this.ajax(this.buildURL(type), \"POST\", { data: data });\n  },\n\n  /**\n    Called by the store when an existing record is `save`d.\n\n    It serializes the record, and `POST`s it to a URL generated by `buildURL`.\n\n    See `serialize` for information on how to customize the serialized form\n    of a record.\n\n    @method updateRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  updateRecord: function(store, type, record) {\n    var data = {};\n    data[type.typeKey] = this.serializerFor(type.typeKey).serialize(record);\n\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type, id), \"PUT\", { data: data });\n  },\n\n  /**\n    Called by the store when an deleted record is `save`d.\n\n    It serializes the record, and `POST`s it to a URL generated by `buildURL`.\n\n    @method deleteRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  deleteRecord: function(store, type, record) {\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type, id), \"DELETE\");\n  },\n\n  /**\n    Builds a URL for a given type and optional ID.\n\n    By default, it pluralizes the type's name (for example,\n    'post' becomes 'posts' and 'person' becomes 'people').\n\n    If an ID is specified, it adds the ID to the plural form\n    of the type, separated by a `/`.\n\n    @method buildURL\n    @param {subclass of DS.Model} type\n    @param {String} id\n    @returns String\n  */\n  buildURL: function(type, id) {\n    var host = get(this, 'host'),\n        namespace = get(this, 'namespace'),\n        url = [];\n\n    if (host) { url.push(host); }\n    if (namespace) { url.push(namespace); }\n\n    url.push(Ember.String.pluralize(type.typeKey));\n    if (id) { url.push(id); }\n\n    url = url.join('/');\n    if (!host) { url = '/' + url; }\n\n    return url;\n  },\n\n  serializerFor: function(type) {\n    // This logic has to be kept in sync with DS.Store#serializerFor\n    return this.container.lookup('serializer:' + type) ||\n           this.container.lookup('serializer:application') ||\n           this.container.lookup('serializer:_rest');\n  },\n\n\n  /**\n    Takes a URL, an HTTP method and a hash of data, and makes an\n    HTTP request.\n\n    When the server responds with a payload, Ember Data will call into `extractSingle`\n    or `extractArray` (depending on whether the original query was for one record or\n    many records).\n\n    By default, it has the following behavior:\n\n    * It sets the response `dataType` to `\"json\"`\n    * If the HTTP method is not `\"GET\"`, it sets the `Content-Type` to be\n      `application/json; charset=utf-8`\n    * If the HTTP method is not `\"GET\"`, it stringifies the data passed in. The\n      data is the serialized record in the case of a save.\n    * Registers success and failure handlers.\n\n    @method ajax\n    @private\n    @param  url\n    @param  type\n    @param  hash\n  */\n  ajax: function(url, type, hash) {\n    var adapter = this;\n\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n      hash = hash || {};\n      hash.url = url;\n      hash.type = type;\n      hash.dataType = 'json';\n      hash.context = adapter;\n\n      if (hash.data && type !== 'GET') {\n        hash.contentType = 'application/json; charset=utf-8';\n        hash.data = JSON.stringify(hash.data);\n      }\n\n      if (adapter.headers !== undefined) {\n        var headers = adapter.headers;\n        hash.beforeSend = function (xhr) {\n          forEach.call(Ember.keys(headers), function(key) {\n            xhr.setRequestHeader(key, headers[key]);\n          });\n        };\n      }\n\n      hash.success = function(json) {\n        Ember.run(null, resolve, json);\n      };\n\n      hash.error = function(jqXHR, textStatus, errorThrown) {\n        if (jqXHR) {\n          jqXHR.then = null;\n        }\n\n        Ember.run(null, reject, jqXHR);\n      };\n\n      Ember.$.ajax(hash);\n    });\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/adapters/rest_adapter");minispade.register('ember-data/core', "(function() {/**\n  @module ember-data\n*/\n\n/**\n  All Ember Data methods and functions are defined inside of this namespace.\n\n  @class DS\n  @static\n*/\n\nif ('undefined' === typeof DS) {\n  DS = Ember.Namespace.create({\n    VERSION: '1.0.0-beta.1'\n  });\n\n  if ('undefined' !== typeof window) {\n    window.DS = DS;\n  }\n}\n})();\n//@ sourceURL=ember-data/core");minispade.register('ember-data/ext', "(function() {minispade.require('ember-data/ext/date');\n\n})();\n//@ sourceURL=ember-data/ext");minispade.register('ember-data/ext/date', "(function() {/**\n  @module ember-data\n*/\n\n/**\n  Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n\n  © 2011 Colin Snover <http://zetafleet.com>\n\n  Released under MIT license.\n\n  @class Date\n  @namespace Ember\n  @static\n*/\nEmber.Date = Ember.Date || {};\n\nvar origParse = Date.parse, numericKeys = [ 1, 4, 5, 6, 7, 10, 11 ];\n\n/**\n  @method parse\n  @param date\n*/\nEmber.Date.parse = function (date) {\n    var timestamp, struct, minutesOffset = 0;\n\n    // ES5 §15.9.4.2 states that the string should attempt to be parsed as a Date Time String Format string\n    // before falling back to any implementation-specific date parsing, so that’s what we do, even if native\n    // implementations could be faster\n    //              1 YYYY                2 MM       3 DD           4 HH    5 mm       6 ss        7 msec        8 Z 9 ±    10 tzHH    11 tzmm\n    if ((struct = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/.exec(date))) {\n        // avoid NaN timestamps caused by “undefined” values being passed to Date.UTC\n        for (var i = 0, k; (k = numericKeys[i]); ++i) {\n            struct[k] = +struct[k] || 0;\n        }\n\n        // allow undefined days and months\n        struct[2] = (+struct[2] || 1) - 1;\n        struct[3] = +struct[3] || 1;\n\n        if (struct[8] !== 'Z' && struct[9] !== undefined) {\n            minutesOffset = struct[10] * 60 + struct[11];\n\n            if (struct[9] === '+') {\n                minutesOffset = 0 - minutesOffset;\n            }\n        }\n\n        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);\n    }\n    else {\n        timestamp = origParse ? origParse(date) : NaN;\n    }\n\n    return timestamp;\n};\n\nif (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Date) {\n  Date.parse = Ember.Date.parse;\n}\n\n})();\n//@ sourceURL=ember-data/ext/date");minispade.register('ember-data/initializers', "(function() {minispade.require(\"ember-data/serializers/json_serializer\");\nminispade.require(\"ember-data/system/debug/debug_adapter\");\nminispade.require(\"ember-data/transforms/index\");\n\n/**\n  @module ember-data\n*/\n\nvar set = Ember.set;\n\n/*\n  This code registers an injection for Ember.Application.\n\n  If an Ember.js developer defines a subclass of DS.Store on their application,\n  this code will automatically instantiate it and make it available on the\n  router.\n\n  Additionally, after an application's controllers have been injected, they will\n  each have the store made available to them.\n\n  For example, imagine an Ember.js application with the following classes:\n\n  App.Store = DS.Store.extend({\n    adapter: 'custom'\n  });\n\n  App.PostsController = Ember.ArrayController.extend({\n    // ...\n  });\n\n  When the application is initialized, `App.Store` will automatically be\n  instantiated, and the instance of `App.PostsController` will have its `store`\n  property set to that instance.\n\n  Note that this code will only be run if the `ember-application` package is\n  loaded. If Ember Data is being used in an environment other than a\n  typical application (e.g., node.js where only `ember-runtime` is available),\n  this code will be ignored.\n*/\n\nEmber.onLoad('Ember.Application', function(Application) {\n  Application.initializer({\n    name: \"store\",\n\n    initialize: function(container, application) {\n      application.register('store:main', application.Store || DS.Store);\n      application.register('serializer:_default', DS.JSONSerializer);\n      application.register('serializer:_rest', DS.RESTSerializer);\n      application.register('adapter:_rest', DS.RESTAdapter);\n\n      // Eagerly generate the store so defaultStore is populated.\n      // TODO: Do this in a finisher hook\n      container.lookup('store:main');\n    }\n  });\n\n  Application.initializer({\n    name: \"transforms\",\n\n    initialize: function(container, application) {\n      application.register('transform:boolean', DS.BooleanTransform);\n      application.register('transform:date', DS.DateTransform);\n      application.register('transform:number', DS.NumberTransform);\n      application.register('transform:string', DS.StringTransform);\n    }\n  });\n\n  Application.initializer({\n    name: \"dataAdapter\",\n\n    initialize: function(container, application) {\n      application.register('dataAdapter:main', DS.DebugAdapter);\n    }\n  });\n\n  Application.initializer({\n    name: \"injectStore\",\n\n    initialize: function(container, application) {\n      application.inject('controller', 'store', 'store:main');\n      application.inject('route', 'store', 'store:main');\n      application.inject('serializer', 'store', 'store:main');\n      application.inject('dataAdapter', 'store', 'store:main');\n    }\n  });\n\n});\n\n})();\n//@ sourceURL=ember-data/initializers");minispade.register('ember-data', "(function() {//Copyright (C) 2011 by Living Social, Inc.\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of\n//this software and associated documentation files (the \"Software\"), to deal in\n//the Software without restriction, including without limitation the rights to\n//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n//of the Software, and to permit persons to whom the Software is furnished to do\n//so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n/**\n  Ember Data\n\n  @module ember-data\n  @main ember-data\n*/\nminispade.require(\"ember-data/core\");\nminispade.require(\"ember-data/initializers\");\nminispade.require(\"ember-data/ext\");\nminispade.require(\"ember-data/system/store\");\nminispade.require(\"ember-data/system/model\");\nminispade.require(\"ember-data/system/changes\");\nminispade.require(\"ember-data/system/relationships\");\nminispade.require(\"ember-data/system/record_arrays\");\nminispade.require(\"ember-data/system/record_array_manager\");\nminispade.require(\"ember-data/system/adapter\");\nminispade.require(\"ember-data/adapters\");\nminispade.require(\"ember-data/system/debug\");\n\n})();\n//@ sourceURL=ember-data");minispade.register('ember-data/serializers/json_serializer', "(function() {var get = Ember.get, set = Ember.set, isNone = Ember.isNone;\n\n// Simple dispatcher to support overriding the aliased\n// method in subclasses.\nfunction aliasMethod(methodName) {\n  return function() {\n    return this[methodName].apply(this, arguments);\n  };\n}\n\nDS.JSONSerializer = Ember.Object.extend({\n  primaryKey: 'id',\n\n  deserialize: function(type, data) {\n    var store = get(this, 'store');\n\n    type.eachTransformedAttribute(function(key, type) {\n      var transform = this.transformFor(type);\n      data[key] = transform.deserialize(data[key]);\n    }, this);\n\n    type.eachRelationship(function(key, relationship) {\n      // A link (usually a URL) was already provided in\n      // normalized form\n      if (data.links && data.links[key]) {\n        return;\n      }\n\n      var type = relationship.type,\n          value = data[key];\n\n      if (value == null) { return; }\n\n      if (relationship.kind === 'belongsTo') {\n        this.deserializeRecordId(data, key, relationship, value);\n      } else if (relationship.kind === 'hasMany') {\n        this.deserializeRecordIds(data, key, relationship, value);\n      }\n    }, this);\n\n    return data;\n  },\n\n  deserializeRecordId: function(data, key, relationship, id) {\n    if (isNone(id) || id instanceof DS.Model) {\n      return;\n    }\n\n    var type;\n\n    if (typeof id === 'number' || typeof id === 'string') {\n      type = this.typeFor(relationship, key, data);\n      data[key] = get(this, 'store').recordForId(type, id);\n    } else if (typeof id === 'object') {\n      // polymorphic\n      data[key] = get(this, 'store').recordForId(id.type, id.id);\n    }\n  },\n\n  deserializeRecordIds: function(data, key, relationship, ids) {\n    for (var i=0, l=ids.length; i<l; i++) {\n      this.deserializeRecordId(ids, i, relationship, ids[i]);\n    }\n  },\n\n  // SERIALIZE\n\n  serialize: function(record, options) {\n    var store = get(this, 'store');\n\n    var json = {};\n\n    if (options && options.includeId) {\n      var id = get(record, 'id');\n\n      if (id) {\n        json[get(this, 'primaryKey')] = get(record, 'id');\n      }\n    }\n\n    var attrs = get(this, 'attrs');\n\n    record.eachAttribute(function(key, attribute) {\n      var value = get(record, key), type = attribute.type;\n\n      if (type) {\n        var transform = this.transformFor(type);\n        value = transform.serialize(value);\n      }\n\n      // if provided, use the mapping provided by `attrs` in\n      // the serializer\n      key = attrs && attrs[key] || key;\n\n      json[key] = value;\n    }, this);\n\n    record.eachRelationship(function(key, relationship) {\n      if (relationship.kind === 'belongsTo') {\n        this.serializeBelongsTo(record, json, relationship);\n      } else if (relationship.kind === 'hasMany') {\n        this.serializeHasMany(record, json, relationship);\n      }\n    }, this);\n\n    return json;\n  },\n\n  serializeBelongsTo: function(record, json, relationship) {\n    var key = relationship.key;\n\n    var belongsTo = get(record, key);\n\n    if (isNone(belongsTo)) { return; }\n\n    json[key] = get(belongsTo, 'id');\n\n    if (relationship.options.polymorphic) {\n      json[key + \"_type\"] = belongsTo.constructor.typeKey;\n    }\n  },\n\n  serializeHasMany: Ember.K,\n\n  // EXTRACT\n\n  extract: function(store, type, payload, id, requestType) {\n    var specificExtract = \"extract\" + requestType.charAt(0).toUpperCase() + requestType.substr(1);\n    return this[specificExtract](store, type, payload, id, requestType);\n  },\n\n  extractFindAll: aliasMethod('extractArray'),\n  extractFindQuery: aliasMethod('extractArray'),\n  extractFindMany: aliasMethod('extractArray'),\n  extractFindHasMany: aliasMethod('extractArray'),\n\n  extractCreateRecord: aliasMethod('extractSave'),\n  extractUpdateRecord: aliasMethod('extractSave'),\n  extractDeleteRecord: aliasMethod('extractSave'),\n\n  extractFind: aliasMethod('extractSingle'),\n  extractSave: aliasMethod('extractSingle'),\n\n  extractSingle: function(store, type, payload) {\n    return payload;\n  },\n\n  extractArray: function(store, type, payload) {\n    return payload;\n  },\n  // HELPERS\n\n  typeFor: function(relationship, key, data) {\n    if (relationship.options.polymorphic) {\n      return data[key + \"_type\"];\n    } else {\n      return relationship.type;\n    }\n  },\n\n  transformFor: function(attributeType) {\n    return this.container.lookup('transform:' + attributeType);\n  },\n\n  eachEmbeddedRecord: function() {\n    // this is used by transaction.add\n  }\n});\n\n})();\n//@ sourceURL=ember-data/serializers/json_serializer");minispade.register('ember-data/system/adapter', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set, merge = Ember.merge;\nvar map = Ember.ArrayPolyfills.map;\nvar resolve = Ember.RSVP.resolve;\n\nvar errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\nDS.InvalidError = function(errors) {\n  var tmp = Error.prototype.constructor.call(this, \"The backend rejected the commit because it was invalid: \" + Ember.inspect(errors));\n  this.errors = errors;\n\n  for (var i=0, l=errorProps.length; i<l; i++) {\n    this[errorProps[i]] = tmp[errorProps[i]];\n  }\n};\nDS.InvalidError.prototype = Ember.create(Error.prototype);\n\nfunction isThenable(object) {\n  return object && typeof object.then === 'function';\n}\n\n// Simple dispatcher to support overriding the aliased\n// method in subclasses.\nfunction aliasMethod(methodName) {\n  return function() {\n    return this[methodName].apply(this, arguments);\n  };\n}\n\n/**\n  An adapter is an object that receives requests from a store and\n  translates them into the appropriate action to take against your\n  persistence layer. The persistence layer is usually an HTTP API, but may\n  be anything, such as the browser's local storage.\n\n  ### Creating an Adapter\n\n  First, create a new subclass of `DS.Adapter`:\n\n      App.MyAdapter = DS.Adapter.extend({\n        // ...your code here\n      });\n\n  To tell your store which adapter to use, set its `adapter` property:\n\n      App.store = DS.Store.create({\n        adapter: App.MyAdapter.create()\n      });\n\n  `DS.Adapter` is an abstract base class that you should override in your\n  application to customize it for your backend. The minimum set of methods\n  that you should implement is:\n\n    * `find()`\n    * `createRecord()`\n    * `updateRecord()`\n    * `deleteRecord()`\n\n  To improve the network performance of your application, you can optimize\n  your adapter by overriding these lower-level methods:\n\n    * `findMany()`\n    * `createRecords()`\n    * `updateRecords()`\n    * `deleteRecords()`\n    * `commit()`\n\n  For an example implementation, see `DS.RestAdapter`, the\n  included REST adapter.\n\n  @class Adapter\n  @namespace DS\n  @extends Ember.Object\n  @uses DS._Mappable\n*/\n\nDS.Adapter = Ember.Object.extend(DS._Mappable, {\n\n  /**\n    The `find()` method is invoked when the store is asked for a record that\n    has not previously been loaded. In response to `find()` being called, you\n    should query your persistence layer for a record with the given ID. Once\n    found, you can asynchronously call the store's `load()` method to load\n    the record.\n\n    Here is an example `find` implementation:\n\n        find: function(store, type, id) {\n          var url = type.url;\n          url = url.fmt(id);\n\n          jQuery.getJSON(url, function(data) {\n              // data is a hash of key/value pairs. If your server returns a\n              // root, simply do something like:\n              // store.load(type, id, data.person)\n              store.load(type, id, data);\n          });\n        }\n\n    @method find\n  */\n  find: Ember.required(Function),\n\n  /**\n    Optional\n\n    @method findAll\n    @param  store\n    @param  type\n    @param  since\n  */\n  findAll: null,\n\n  /**\n    Optional\n\n    @method findQuery\n    @param  store\n    @param  type\n    @param  query\n    @param  recordArray\n  */\n  findQuery: null,\n\n  /**\n    If the globally unique IDs for your records should be generated on the client,\n    implement the `generateIdForRecord()` method. This method will be invoked\n    each time you create a new record, and the value returned from it will be\n    assigned to the record's `primaryKey`.\n\n    Most traditional REST-like HTTP APIs will not use this method. Instead, the ID\n    of the record will be set by the server, and your adapter will update the store\n    with the new ID when it calls `didCreateRecord()`. Only implement this method if\n    you intend to generate record IDs on the client-side.\n\n    The `generateIdForRecord()` method will be invoked with the requesting store as\n    the first parameter and the newly created record as the second parameter:\n\n        generateIdForRecord: function(store, record) {\n          var uuid = App.generateUUIDWithStatisticallyLowOddsOfCollision();\n          return uuid;\n        }\n\n    @method generateIdForRecord\n    @param {DS.Store} store\n    @param {DS.Model} record\n  */\n  generateIdForRecord: null,\n\n  /**\n    Proxies to the serializer's `serialize` method.\n\n    @method serialize\n    @param {DS.Model} record\n    @param {Object}   options\n  */\n  serialize: function(record, options) {\n    return get(record, 'store').serializerFor(record.constructor.typeKey).serialize(record, options);\n  },\n\n  /**\n    Implement this method in a subclass to handle the creation of\n    new records.\n\n    Serializes the record and send it to the server.\n\n    This implementation should call the adapter's `didCreateRecord`\n    method on success or `didError` method on failure.\n\n    @method createRecord\n    @property {DS.Store} store\n    @property {subclass of DS.Model} type   the DS.Model class of the record\n    @property {DS.Model} record\n  */\n  createRecord: Ember.required(Function),\n\n  /**\n    Implement this method in a subclass to handle the updating of\n    a record.\n\n    Serializes the record update and send it to the server.\n\n    @method updateRecord\n    @property {DS.Store} store\n    @property {subclass of DS.Model} type   the DS.Model class of the record\n    @property {DS.Model} record\n  */\n  updateRecord: Ember.required(Function),\n\n  /**\n    Implement this method in a subclass to handle the deletion of\n    a record.\n\n    Sends a delete request for the record to the server.\n\n    @method deleteRecord\n    @property {DS.Store} store\n    @property {subclass of DS.Model} type   the DS.Model class of the record\n    @property {DS.Model} record\n  */\n  deleteRecord: Ember.required(Function),\n\n  /**\n    Find multiple records at once.\n\n    By default, it loops over the provided ids and calls `find` on each.\n    May be overwritten to improve performance and reduce the number of\n    server requests.\n\n    @method findMany\n    @property {DS.Store} store\n    @property {subclass of DS.Model} type   the DS.Model class of the records\n    @property {Array}    ids\n  */\n  findMany: function(store, type, ids) {\n    var promises = map.call(ids, function(id) {\n      return this.find(store, type, id);\n    }, this);\n\n    return Ember.RSVP.all(promises);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/adapter");minispade.register('ember-data/system/changes', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/changes/attribute_change\");\nminispade.require(\"ember-data/system/changes/relationship_change\");\n\n})();\n//@ sourceURL=ember-data/system/changes");minispade.register('ember-data/system/changes/attribute_change', "(function() {/**\n  @module ember-data\n*/\n\n/**\n  An AttributeChange object is created whenever a record's\n  attribute changes value. It is used to track changes to a\n  record between transaction commits.\n\n  @class AttributeChange\n  @namespace DS\n  @private\n  @constructor\n*/\nvar AttributeChange = DS.AttributeChange = function(options) {\n  this.record = options.record;\n  this.store = options.store;\n  this.name = options.name;\n  this.value = options.value;\n  this.oldValue = options.oldValue;\n};\n\nAttributeChange.createChange = function(options) {\n  return new AttributeChange(options);\n};\n\nAttributeChange.prototype = {\n  sync: function() {\n    if (this.value !== this.oldValue) {\n      this.record.send('becomeDirty');\n      this.record.updateRecordArraysLater();\n    }\n\n    // TODO: Use this object in the commit process\n    this.destroy();\n  },\n\n  /**\n    If the AttributeChange is destroyed (either by being rolled back\n    or being committed), remove it from the list of pending changes\n    on the record.\n\n    @method destroy\n  */\n  destroy: function() {\n    delete this.record._changesToSync[this.name];\n  }\n};\n\n})();\n//@ sourceURL=ember-data/system/changes/attribute_change");minispade.register('ember-data/system/changes/relationship_change', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.EnumerableUtils.forEach;\n\n/**\n  @class RelationshipChange\n  @namespace DS\n  @private\n  @construtor\n*/\nDS.RelationshipChange = function(options) {\n  this.parentRecord = options.parentRecord;\n  this.childRecord = options.childRecord;\n  this.firstRecord = options.firstRecord;\n  this.firstRecordKind = options.firstRecordKind;\n  this.firstRecordName = options.firstRecordName;\n  this.secondRecord = options.secondRecord;\n  this.secondRecordKind = options.secondRecordKind;\n  this.secondRecordName = options.secondRecordName;\n  this.changeType = options.changeType;\n  this.store = options.store;\n\n  this.committed = {};\n};\n\n/**\n  @class RelationshipChangeAdd\n  @namespace DS\n  @private\n  @construtor\n*/\nDS.RelationshipChangeAdd = function(options){\n  DS.RelationshipChange.call(this, options);\n};\n\n/**\n  @class RelationshipChangeRemove\n  @namespace DS\n  @private\n  @construtor\n*/\nDS.RelationshipChangeRemove = function(options){\n  DS.RelationshipChange.call(this, options);\n};\n\nDS.RelationshipChange.create = function(options) {\n  return new DS.RelationshipChange(options);\n};\n\nDS.RelationshipChangeAdd.create = function(options) {\n  return new DS.RelationshipChangeAdd(options);\n};\n\nDS.RelationshipChangeRemove.create = function(options) {\n  return new DS.RelationshipChangeRemove(options);\n};\n\nDS.OneToManyChange = {};\nDS.OneToNoneChange = {};\nDS.ManyToNoneChange = {};\nDS.OneToOneChange = {};\nDS.ManyToManyChange = {};\n\nDS.RelationshipChange._createChange = function(options){\n  if(options.changeType === \"add\"){\n    return DS.RelationshipChangeAdd.create(options);\n  }\n  if(options.changeType === \"remove\"){\n    return DS.RelationshipChangeRemove.create(options);\n  }\n};\n\n\nDS.RelationshipChange.determineRelationshipType = function(recordType, knownSide){\n  var knownKey = knownSide.key, key, otherKind;\n  var knownKind = knownSide.kind;\n\n  var inverse = recordType.inverseFor(knownKey);\n\n  if (inverse){\n    key = inverse.name;\n    otherKind = inverse.kind;\n  }\n\n  if (!inverse){\n    return knownKind === \"belongsTo\" ? \"oneToNone\" : \"manyToNone\";\n  }\n  else{\n    if(otherKind === \"belongsTo\"){\n      return knownKind === \"belongsTo\" ? \"oneToOne\" : \"manyToOne\";\n    }\n    else{\n      return knownKind === \"belongsTo\" ? \"oneToMany\" : \"manyToMany\";\n    }\n  }\n\n};\n\nDS.RelationshipChange.createChange = function(firstRecord, secondRecord, store, options){\n  // Get the type of the child based on the child's client ID\n  var firstRecordType = firstRecord.constructor, changeType;\n  changeType = DS.RelationshipChange.determineRelationshipType(firstRecordType, options);\n  if (changeType === \"oneToMany\"){\n    return DS.OneToManyChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"manyToOne\"){\n    return DS.OneToManyChange.createChange(secondRecord, firstRecord, store, options);\n  }\n  else if (changeType === \"oneToNone\"){\n    return DS.OneToNoneChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"manyToNone\"){\n    return DS.ManyToNoneChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"oneToOne\"){\n    return DS.OneToOneChange.createChange(firstRecord, secondRecord, store, options);\n  }\n  else if (changeType === \"manyToMany\"){\n    return DS.ManyToManyChange.createChange(firstRecord, secondRecord, store, options);\n  }\n};\n\nDS.OneToNoneChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key = options.key;\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      store: store,\n      changeType: options.changeType,\n      firstRecordName: key,\n      firstRecordKind: \"belongsTo\"\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n\n  return change;\n};\n\nDS.ManyToNoneChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key = options.key;\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: childRecord,\n      childRecord: parentRecord,\n      secondRecord: childRecord,\n      store: store,\n      changeType: options.changeType,\n      secondRecordName: options.key,\n      secondRecordKind: \"hasMany\"\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n  return change;\n};\n\n\nDS.ManyToManyChange.createChange = function(childRecord, parentRecord, store, options) {\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  var key = options.key;\n\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      secondRecord: parentRecord,\n      firstRecordKind: \"hasMany\",\n      secondRecordKind: \"hasMany\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n\n\n  return change;\n};\n\nDS.OneToOneChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key;\n\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  if (options.parentType) {\n    key = options.parentType.inverseFor(options.key).name;\n  } else if (options.key) {\n    key = options.key;\n  } else {\n    Ember.assert(\"You must pass either a parentType or belongsToName option to OneToManyChange.forChildAndParent\", false);\n  }\n\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      secondRecord: parentRecord,\n      firstRecordKind: \"belongsTo\",\n      secondRecordKind: \"belongsTo\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, null, change);\n\n\n  return change;\n};\n\nDS.OneToOneChange.maintainInvariant = function(options, store, childRecord, key){\n  if (options.changeType === \"add\" && store.recordIsMaterialized(childRecord)) {\n    var oldParent = get(childRecord, key);\n    if (oldParent){\n      var correspondingChange = DS.OneToOneChange.createChange(childRecord, oldParent, store, {\n          parentType: options.parentType,\n          hasManyName: options.hasManyName,\n          changeType: \"remove\",\n          key: options.key\n        });\n      store.addRelationshipChangeFor(childRecord, key, options.parentRecord , null, correspondingChange);\n     correspondingChange.sync();\n    }\n  }\n};\n\nDS.OneToManyChange.createChange = function(childRecord, parentRecord, store, options) {\n  var key;\n\n  // If the name of the belongsTo side of the relationship is specified,\n  // use that\n  // If the type of the parent is specified, look it up on the child's type\n  // definition.\n  if (options.parentType) {\n    key = options.parentType.inverseFor(options.key).name;\n    DS.OneToManyChange.maintainInvariant( options, store, childRecord, key );\n  } else if (options.key) {\n    key = options.key;\n  } else {\n    Ember.assert(\"You must pass either a parentType or belongsToName option to OneToManyChange.forChildAndParent\", false);\n  }\n\n  var change = DS.RelationshipChange._createChange({\n      parentRecord: parentRecord,\n      childRecord: childRecord,\n      firstRecord: childRecord,\n      secondRecord: parentRecord,\n      firstRecordKind: \"belongsTo\",\n      secondRecordKind: \"hasMany\",\n      store: store,\n      changeType: options.changeType,\n      firstRecordName:  key\n  });\n\n  store.addRelationshipChangeFor(childRecord, key, parentRecord, change.getSecondRecordName(), change);\n\n\n  return change;\n};\n\n\nDS.OneToManyChange.maintainInvariant = function(options, store, childRecord, key){\n  if (options.changeType === \"add\" && childRecord) {\n    var oldParent = get(childRecord, key);\n    if (oldParent){\n      var correspondingChange = DS.OneToManyChange.createChange(childRecord, oldParent, store, {\n          parentType: options.parentType,\n          hasManyName: options.hasManyName,\n          changeType: \"remove\",\n          key: options.key\n        });\n      store.addRelationshipChangeFor(childRecord, key, options.parentRecord, correspondingChange.getSecondRecordName(), correspondingChange);\n      correspondingChange.sync();\n    }\n  }\n};\n\n/**\n  @class RelationshipChange\n  @namespace DS\n*/\nDS.RelationshipChange.prototype = {\n\n  getSecondRecordName: function() {\n    var name = this.secondRecordName, parent;\n\n    if (!name) {\n      parent = this.secondRecord;\n      if (!parent) { return; }\n\n      var childType = this.firstRecord.constructor;\n      var inverse = childType.inverseFor(this.firstRecordName);\n      this.secondRecordName = inverse.name;\n    }\n\n    return this.secondRecordName;\n  },\n\n  /**\n    Get the name of the relationship on the belongsTo side.\n\n    @method getFirstRecordName\n    @return {String}\n  */\n  getFirstRecordName: function() {\n    var name = this.firstRecordName;\n    return name;\n  },\n\n  /**\n    @method destroy\n    @private\n  */\n  destroy: function() {\n    var childRecord = this.childRecord,\n        belongsToName = this.getFirstRecordName(),\n        hasManyName = this.getSecondRecordName(),\n        store = this.store;\n\n    store.removeRelationshipChangeFor(childRecord, belongsToName, this.parentRecord, hasManyName, this.changeType);\n  },\n\n  getSecondRecord: function(){\n    return this.secondRecord;\n  },\n\n  /**\n    @method getFirstRecord\n    @private\n  */\n  getFirstRecord: function() {\n    return this.firstRecord;\n  },\n\n  coalesce: function(){\n    var relationshipPairs = this.store.relationshipChangePairsFor(this.firstRecord);\n    forEach(relationshipPairs, function(pair){\n      var addedChange = pair[\"add\"];\n      var removedChange = pair[\"remove\"];\n      if(addedChange && removedChange) {\n        addedChange.destroy();\n        removedChange.destroy();\n      }\n    });\n  }\n};\n\nDS.RelationshipChangeAdd.prototype = Ember.create(DS.RelationshipChange.create({}));\nDS.RelationshipChangeRemove.prototype = Ember.create(DS.RelationshipChange.create({}));\n\n// the object is a value, and not a promise\nfunction isValue(object) {\n  return typeof object === 'object' && (!object.then || typeof object.then !== 'function');\n}\n\nDS.RelationshipChangeAdd.prototype.changeType = \"add\";\nDS.RelationshipChangeAdd.prototype.sync = function() {\n  var secondRecordName = this.getSecondRecordName(),\n      firstRecordName = this.getFirstRecordName(),\n      firstRecord = this.getFirstRecord(),\n      secondRecord = this.getSecondRecord();\n\n  //Ember.assert(\"You specified a hasMany (\" + hasManyName + \") on \" + (!belongsToName && (newParent || oldParent || this.lastParent).constructor) + \" but did not specify an inverse belongsTo on \" + child.constructor, belongsToName);\n  //Ember.assert(\"You specified a belongsTo (\" + belongsToName + \") on \" + child.constructor + \" but did not specify an inverse hasMany on \" + (!hasManyName && (newParent || oldParent || this.lastParentRecord).constructor), hasManyName);\n\n  if (secondRecord instanceof DS.Model && firstRecord instanceof DS.Model) {\n    if(this.secondRecordKind === \"belongsTo\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        set(secondRecord, secondRecordName, firstRecord);\n      });\n\n     }\n     else if(this.secondRecordKind === \"hasMany\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        var relationship = get(secondRecord, secondRecordName);\n        if (isValue(relationship)) { relationship.addObject(firstRecord); }\n      });\n    }\n  }\n\n  if (firstRecord instanceof DS.Model && secondRecord instanceof DS.Model && get(firstRecord, firstRecordName) !== secondRecord) {\n    if(this.firstRecordKind === \"belongsTo\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        set(firstRecord, firstRecordName, secondRecord);\n      });\n    }\n    else if(this.firstRecordKind === \"hasMany\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        var relationship = get(firstRecord, firstRecordName);\n        if (isValue(relationship)) { relationship.addObject(secondRecord); }\n      });\n    }\n  }\n\n  this.coalesce();\n};\n\nDS.RelationshipChangeRemove.prototype.changeType = \"remove\";\nDS.RelationshipChangeRemove.prototype.sync = function() {\n  var secondRecordName = this.getSecondRecordName(),\n      firstRecordName = this.getFirstRecordName(),\n      firstRecord = this.getFirstRecord(),\n      secondRecord = this.getSecondRecord();\n\n  //Ember.assert(\"You specified a hasMany (\" + hasManyName + \") on \" + (!belongsToName && (newParent || oldParent || this.lastParent).constructor) + \" but did not specify an inverse belongsTo on \" + child.constructor, belongsToName);\n  //Ember.assert(\"You specified a belongsTo (\" + belongsToName + \") on \" + child.constructor + \" but did not specify an inverse hasMany on \" + (!hasManyName && (newParent || oldParent || this.lastParentRecord).constructor), hasManyName);\n\n  if (secondRecord instanceof DS.Model && firstRecord instanceof DS.Model) {\n    if(this.secondRecordKind === \"belongsTo\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        set(secondRecord, secondRecordName, null);\n      });\n    }\n    else if(this.secondRecordKind === \"hasMany\"){\n      secondRecord.suspendRelationshipObservers(function(){\n        var relationship = get(secondRecord, secondRecordName);\n        if (isValue(relationship)) { relationship.removeObject(firstRecord); }\n      });\n    }\n  }\n\n  if (firstRecord instanceof DS.Model && get(firstRecord, firstRecordName)) {\n    if(this.firstRecordKind === \"belongsTo\"){\n      firstRecord.suspendRelationshipObservers(function(){\n        set(firstRecord, firstRecordName, null);\n      });\n     }\n     else if(this.firstRecordKind === \"hasMany\"){\n       firstRecord.suspendRelationshipObservers(function(){\n         var relationship = get(firstRecord, firstRecordName);\n         if (isValue(relationship)) { relationship.removeObject(secondRecord); }\n      });\n    }\n  }\n\n  this.coalesce();\n};\n\n})();\n//@ sourceURL=ember-data/system/changes/relationship_change");minispade.register('ember-data/system/debug', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/debug/debug_info\");\nminispade.require(\"ember-data/system/debug/debug_adapter\");\n\n})();\n//@ sourceURL=ember-data/system/debug");minispade.register('ember-data/system/debug/debug_adapter', "(function() {/**\n  @module ember-data\n*/\nvar get = Ember.get, capitalize = Ember.String.capitalize, underscore = Ember.String.underscore, DS = window.DS ;\n\n/**\n  Extend `Ember.DataAdapter` with ED specific code.\n*/\nDS.DebugAdapter = Ember.DataAdapter.extend({\n  getFilters: function() {\n    return [\n      { name: 'isNew', desc: 'New' },\n      { name: 'isModified', desc: 'Modified' },\n      { name: 'isClean', desc: 'Clean' }\n    ];\n  },\n\n  detect: function(klass) {\n    return klass !== DS.Model && DS.Model.detect(klass);\n  },\n\n  columnsForType: function(type) {\n    var columns = [{ name: 'id', desc: 'Id' }], count = 0, self = this;\n    Ember.A(get(type, 'attributes')).forEach(function(name, meta) {\n        if (count++ > self.attributeLimit) { return false; }\n        var desc = capitalize(underscore(name).replace('_', ' '));\n        columns.push({ name: name, desc: desc });\n    });\n    return columns;\n  },\n\n  getRecords: function(type) {\n    return this.get('store').all(type);\n  },\n\n  getRecordColumnValues: function(record) {\n    var self = this, count = 0,\n        columnValues = { id: get(record, 'id') };\n\n    record.eachAttribute(function(key) {\n      if (count++ > self.attributeLimit) {\n        return false;\n      }\n      var value = get(record, key);\n      columnValues[key] = value;\n    });\n    return columnValues;\n  },\n\n  getRecordKeywords: function(record) {\n    var keywords = [], keys = Ember.A(['id']);\n    record.eachAttribute(function(key) {\n      keys.push(key);\n    });\n    keys.forEach(function(key) {\n      keywords.push(get(record, key));\n    });\n    return keywords;\n  },\n\n  getRecordFilterValues: function(record) {\n    return {\n      isNew: record.get('isNew'),\n      isModified: record.get('isDirty') && !record.get('isNew'),\n      isClean: !record.get('isDirty')\n    };\n  },\n\n  getRecordColor: function(record) {\n    var color = 'black';\n    if (record.get('isNew')) {\n      color = 'green';\n    } else if (record.get('isDirty')) {\n      color = 'blue';\n    }\n    return color;\n  },\n\n  observeRecord: function(record, recordUpdated) {\n    var releaseMethods = Ember.A(), self = this,\n        keysToObserve = Ember.A(['id', 'isNew', 'isDirty']);\n\n    record.eachAttribute(function(key) {\n      keysToObserve.push(key);\n    });\n\n    keysToObserve.forEach(function(key) {\n      var handler = function() {\n        recordUpdated(self.wrapRecord(record));\n      };\n      Ember.addObserver(record, key, handler);\n      releaseMethods.push(function() {\n        Ember.removeObserver(record, key, handler);\n      });\n    });\n\n    var release = function() {\n      releaseMethods.forEach(function(fn) { fn(); } );\n    };\n\n    return release;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/debug/debug_adapter");minispade.register('ember-data/system/debug/debug_info', "(function() {minispade.require(\"ember-data/system/model/model\");\n\nDS.Model.reopen({\n\n  /**\n   Provides info about the model for debugging purposes\n   by grouping the properties into more semantic groups.\n\n   Meant to be used by debugging tools such as the Chrome Ember Extension.\n\n   - Groups all attributes in \"Attributes\" group.\n   - Groups all belongsTo relationships in \"Belongs To\" group.\n   - Groups all hasMany relationships in \"Has Many\" group.\n   - Groups all flags in \"Flags\" group.\n   - Flags relationship CPs as expensive properties.\n  */\n  _debugInfo: function() {\n    var attributes = ['id'],\n        relationships = { belongsTo: [], hasMany: [] },\n        expensiveProperties = [];\n\n    this.eachAttribute(function(name, meta) {\n      attributes.push(name);\n    }, this);\n\n    this.eachRelationship(function(name, relationship) {\n      relationships[relationship.kind].push(name);\n      expensiveProperties.push(name);\n    });\n\n    var groups = [\n      {\n        name: 'Attributes',\n        properties: attributes,\n        expand: true,\n      },\n      {\n        name: 'Belongs To',\n        properties: relationships.belongsTo,\n        expand: true\n      },\n      {\n        name: 'Has Many',\n        properties: relationships.hasMany,\n        expand: true\n      },\n      {\n        name: 'Flags',\n        properties: ['isLoaded', 'isDirty', 'isSaving', 'isDeleted', 'isError', 'isNew', 'isValid']\n      }\n    ];\n\n    return {\n      propertyInfo: {\n        // include all other mixins / properties (not just the grouped ones)\n        includeOtherProperties: true,\n        groups: groups,\n        // don't pre-calculate unless cached\n        expensiveProperties: expensiveProperties\n      }\n    };\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/debug/debug_info");minispade.register('ember-data/system/mixins/mappable', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get;\nvar forEach = Ember.ArrayPolyfills.forEach;\n\nvar resolveMapConflict = function(oldValue, newValue) {\n  return oldValue;\n};\n\nvar transformMapKey = function(key, value) {\n  return key;\n};\n\nvar transformMapValue = function(key, value) {\n  return value;\n};\n\n/**\n  The Mappable mixin is designed for classes that would like to\n  behave as a map for configuration purposes.\n\n  For example, the DS.Adapter class can behave like a map, with\n  more semantic API, via the `map` API:\n\n    DS.Adapter.map('App.Person', { firstName: { key: 'FIRST' } });\n\n  Class configuration via a map-like API has a few common requirements\n  that differentiate it from the standard Ember.Map implementation.\n\n  First, values often are provided as strings that should be normalized\n  into classes the first time the configuration options are used.\n\n  Second, the values configured on parent classes should also be taken\n  into account.\n\n  Finally, setting the value of a key sometimes should merge with the\n  previous value, rather than replacing it.\n\n  This mixin provides a instance method, `createInstanceMapFor`, that\n  will reify all of the configuration options set on an instance's\n  constructor and provide it for the instance to use.\n\n  Classes can implement certain hooks that allow them to customize\n  the requirements listed above:\n\n  * `resolveMapConflict` - called when a value is set for an existing\n    value\n  * `transformMapKey` - allows a key name (for example, a global path\n    to a class) to be normalized\n  * `transformMapValue` - allows a value (for example, a class that\n    should be instantiated) to be normalized\n\n  Classes that implement this mixin should also implement a class\n  method built using the `generateMapFunctionFor` method:\n\n    DS.Adapter.reopenClass({\n      map: DS.Mappable.generateMapFunctionFor('attributes', function(key, newValue, map) {\n        var existingValue = map.get(key);\n\n        for (var prop in newValue) {\n          if (!newValue.hasOwnProperty(prop)) { continue; }\n          existingValue[prop] = newValue[prop];\n        }\n      })\n    });\n\n  The function passed to `generateMapFunctionFor` is invoked every time a\n  new value is added to the map.\n\n  @class _Mappable\n  @private\n  @namespace DS\n**/\nDS._Mappable = Ember.Mixin.create({\n  createInstanceMapFor: function(mapName) {\n    var instanceMeta = getMappableMeta(this);\n\n    instanceMeta.values = instanceMeta.values || {};\n\n    if (instanceMeta.values[mapName]) { return instanceMeta.values[mapName]; }\n\n    var instanceMap = instanceMeta.values[mapName] = new Ember.Map();\n\n    var klass = this.constructor;\n\n    while (klass && klass !== DS.Store) {\n      this._copyMap(mapName, klass, instanceMap);\n      klass = klass.superclass;\n    }\n\n    instanceMeta.values[mapName] = instanceMap;\n    return instanceMap;\n  },\n\n  _copyMap: function(mapName, klass, instanceMap) {\n    var classMeta = getMappableMeta(klass);\n\n    var classMap = classMeta[mapName];\n    if (classMap) {\n      forEach.call(classMap, eachMap, this);\n    }\n\n    function eachMap(key, value) {\n      var transformedKey = (klass.transformMapKey || transformMapKey)(key, value);\n      var transformedValue = (klass.transformMapValue || transformMapValue)(key, value);\n\n      var oldValue = instanceMap.get(transformedKey);\n      var newValue = transformedValue;\n\n      if (oldValue) {\n        newValue = (this.constructor.resolveMapConflict || resolveMapConflict)(oldValue, newValue);\n      }\n\n      instanceMap.set(transformedKey, newValue);\n    }\n  }\n\n});\n\nDS._Mappable.generateMapFunctionFor = function(mapName, transform) {\n  return function(key, value) {\n    var meta = getMappableMeta(this);\n\n    var map = meta[mapName] || Ember.MapWithDefault.create({\n      defaultValue: function() { return {}; }\n    });\n\n    transform.call(this, key, value, map);\n\n    meta[mapName] = map;\n  };\n};\n\nfunction getMappableMeta(obj) {\n  var meta = Ember.meta(obj, true),\n      keyName = 'DS.Mappable',\n      value = meta[keyName];\n\n  if (!value) { meta[keyName] = {}; }\n\n  if (!meta.hasOwnProperty(keyName)) {\n    meta[keyName] = Ember.create(meta[keyName]);\n  }\n\n  return meta[keyName];\n}\n\n})();\n//@ sourceURL=ember-data/system/mixins/mappable");minispade.register('ember-data/system/model', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/model/model\");\nminispade.require(\"ember-data/system/model/states\");\nminispade.require(\"ember-data/system/model/attributes\");\n\n})();\n//@ sourceURL=ember-data/system/model");minispade.register('ember-data/system/model/attributes', "(function() {minispade.require(\"ember-data/system/model/model\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get;\n\n/**\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopenClass({\n  attributes: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isAttribute) {\n        Ember.assert(\"You may not set `id` as an attribute on your model. Please remove any lines that look like: `id: DS.attr('<type>')` from \" + this.toString(), name !== 'id');\n\n        meta.name = name;\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  transformedAttributes: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachAttribute(function(key, meta) {\n      if (meta.type) {\n        map.set(key, meta.type);\n      }\n    });\n\n    return map;\n  }),\n\n  eachAttribute: function(callback, binding) {\n    get(this, 'attributes').forEach(function(name, meta) {\n      callback.call(binding, name, meta);\n    }, binding);\n  },\n\n  eachTransformedAttribute: function(callback, binding) {\n    get(this, 'transformedAttributes').forEach(function(name, type) {\n      callback.call(binding, name, type);\n    });\n  }\n});\n\n\nDS.Model.reopen({\n  eachAttribute: function(callback, binding) {\n    this.constructor.eachAttribute(callback, binding);\n  }\n});\n\nfunction getDefaultValue(record, options, key) {\n  if (typeof options.defaultValue === \"function\") {\n    return options.defaultValue();\n  } else {\n    return options.defaultValue;\n  }\n}\n\nfunction hasValue(record, key) {\n  return record._attributes.hasOwnProperty(key) ||\n         record._inFlightAttributes.hasOwnProperty(key) ||\n         record._data.hasOwnProperty(key);\n}\n\nfunction getValue(record, key) {\n  if (record._attributes.hasOwnProperty(key)) {\n    return record._attributes[key];\n  } else if (record._inFlightAttributes.hasOwnProperty(key)) {\n    return record._inFlightAttributes[key];\n  } else {\n    return record._data[key];\n  }\n}\n\nDS.attr = function(type, options) {\n  options = options || {};\n\n  var meta = {\n    type: type,\n    isAttribute: true,\n    options: options\n  };\n\n  return Ember.computed(function(key, value, oldValue) {\n    var currentValue;\n\n    if (arguments.length > 1) {\n      Ember.assert(\"You may not set `id` as an attribute on your model. Please remove any lines that look like: `id: DS.attr('<type>')` from \" + this.constructor.toString(), key !== 'id');\n      this.send('didSetProperty', { name: key, oldValue: this._attributes[key] || this._inFlightAttributes[key] || this._data[key], value: value });\n      this._attributes[key] = value;\n      return value;\n    } else if (hasValue(this, key)) {\n      return getValue(this, key);\n    } else {\n      return getDefaultValue(this, options, key);\n    }\n\n  // `data` is never set directly. However, it may be\n  // invalidated from the state manager's setData\n  // event.\n  }).property('data').meta(meta);\n};\n\n\n})();\n//@ sourceURL=ember-data/system/model/attributes");minispade.register('ember-data/system/model/model', "(function() {minispade.require(\"ember-data/system/model/states\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set, map = Ember.EnumerableUtils.map,\n    merge = Ember.merge, once = Ember.run.once;\n\nvar arrayMap = Ember.ArrayPolyfills.map;\n\nvar retrieveFromCurrentState = Ember.computed(function(key, value) {\n  return get(get(this, 'currentState'), key);\n}).property('currentState').readOnly();\n\n/**\n\n  The model class that all Ember Data records descend from.\n\n  @class Model\n  @namespace DS\n  @extends Ember.Object\n  @uses Ember.Evented\n*/\nDS.Model = Ember.Object.extend(Ember.Evented, {\n  isEmpty: retrieveFromCurrentState,\n  isLoading: retrieveFromCurrentState,\n  isLoaded: retrieveFromCurrentState,\n  isDirty: retrieveFromCurrentState,\n  isSaving: retrieveFromCurrentState,\n  isDeleted: retrieveFromCurrentState,\n  isNew: retrieveFromCurrentState,\n  isValid: retrieveFromCurrentState,\n  dirtyType: retrieveFromCurrentState,\n\n  isError: false,\n  isReloading: false,\n\n  clientId: null,\n  id: null,\n  transaction: null,\n  currentState: null,\n  errors: null,\n\n  /**\n    Create a JSON representation of the record, using the serialization\n    strategy of the store's adapter.\n\n    @method serialize\n    @param {Object} options Available options:\n\n    * `includeId`: `true` if the record's ID should be included in the\n      JSON representation.\n\n    @returns {Object} an object whose values are primitive JSON values only\n  */\n  serialize: function(options) {\n    var store = get(this, 'store');\n    return store.serialize(this, options);\n  },\n\n  /**\n    Use {{#crossLink \"DS.JSONSerializer\"}}DS.JSONSerializer{{/crossLink}} to\n    get the JSON representation of a record.\n\n    @method toJSON\n    @param {Object} options Available options:\n\n    * `includeId`: `true` if the record's ID should be included in the\n      JSON representation.\n\n    @returns {Object} A JSON representation of the object.\n  */\n  toJSON: function(options) {\n    var serializer = DS.JSONSerializer.create();\n    return serializer.serialize(this, options);\n  },\n\n  /**\n    Fired when the record is loaded from the server.\n\n    @event didLoad\n  */\n  didLoad: Ember.K,\n\n  /**\n    Fired when the record is reloaded from the server.\n\n    @event didReload\n  */\n  didReload: Ember.K,\n\n  /**\n    Fired when the record is updated.\n\n    @event didUpdate\n  */\n  didUpdate: Ember.K,\n\n  /**\n    Fired when the record is created.\n\n    @event didCreate\n  */\n  didCreate: Ember.K,\n\n  /**\n    Fired when the record is deleted.\n\n    @event didDelete\n  */\n  didDelete: Ember.K,\n\n  /**\n    Fired when the record becomes invalid.\n\n    @event becameInvalid\n  */\n  becameInvalid: Ember.K,\n\n  /**\n    Fired when the record enters the error state.\n\n    @event becameError\n  */\n  becameError: Ember.K,\n\n  data: Ember.computed(function() {\n    this._data = this._data || {};\n    return this._data;\n  }).property(),\n\n  _data: null,\n\n  init: function() {\n    set(this, 'currentState', DS.RootState.empty);\n    this._super();\n    this._setup();\n  },\n\n  _setup: function() {\n    this._changesToSync = {};\n    this._deferredTriggers = [];\n    this._data = {};\n    this._attributes = {};\n    this._inFlightAttributes = {};\n    this._relationships = {};\n  },\n\n  send: function(name, context) {\n    var currentState = get(this, 'currentState');\n\n    if (!currentState[name]) {\n      this._unhandledEvent(currentState, name, context);\n    }\n\n    return currentState[name](this, context);\n  },\n\n  transitionTo: function(name) {\n    // POSSIBLE TODO: Remove this code and replace with\n    // always having direct references to state objects\n\n    var pivotName = name.split(\".\", 1),\n        currentState = get(this, 'currentState'),\n        state = currentState;\n\n    do {\n      if (state.exit) { state.exit(this); }\n      state = state.parentState;\n    } while (!state.hasOwnProperty(pivotName));\n\n    var path = name.split(\".\");\n\n    var setups = [], enters = [], i, l;\n\n    for (i=0, l=path.length; i<l; i++) {\n      state = state[path[i]];\n\n      if (state.enter) { enters.push(state); }\n      if (state.setup) { setups.push(state); }\n    }\n\n    for (i=0, l=enters.length; i<l; i++) {\n      enters[i].enter(this);\n    }\n\n    set(this, 'currentState', state);\n\n    for (i=0, l=setups.length; i<l; i++) {\n      setups[i].setup(this);\n    }\n  },\n\n  _unhandledEvent: function(state, name, context) {\n    var errorMessage = \"Attempted to handle event `\" + name + \"` \";\n    errorMessage    += \"on \" + String(this) + \" while in state \";\n    errorMessage    += state.stateName + \". \";\n\n    if (context !== undefined) {\n      errorMessage  += \"Called with \" + Ember.inspect(context) + \".\";\n    }\n\n    throw new Ember.Error(errorMessage);\n  },\n\n  withTransaction: function(fn) {\n    var transaction = get(this, 'transaction');\n    if (transaction) { fn(transaction); }\n  },\n\n  loadingData: function() {\n    this.send('loadingData');\n  },\n\n  loadedData: function() {\n    this.send('loadedData');\n  },\n\n  pushedData: function() {\n    this.send('pushedData');\n  },\n\n  deleteRecord: function() {\n    this.send('deleteRecord');\n  },\n\n  unloadRecord: function() {\n    Ember.assert(\"You can only unload a loaded, non-dirty record.\", !get(this, 'isDirty'));\n\n    this.send('unloadRecord');\n  },\n\n  clearRelationships: function() {\n    this.eachRelationship(function(name, relationship) {\n      if (relationship.kind === 'belongsTo') {\n        set(this, name, null);\n      } else if (relationship.kind === 'hasMany') {\n        var hasMany = this._relationships[relationship.name];\n        if (hasMany) { hasMany.clear(); }\n      }\n    }, this);\n  },\n\n  updateRecordArrays: function() {\n    var store = get(this, 'store');\n    if (store) {\n      store.dataWasUpdated(this.constructor, this);\n    }\n  },\n\n  adapterWillCommit: function() {\n    this.send('willCommit');\n  },\n\n  /**\n    If the adapter did not return a hash in response to a commit,\n    merge the changed attributes and relationships into the existing\n    saved data.\n\n    @method adapterDidCommit\n  */\n  adapterDidCommit: function(data) {\n    set(this, 'isError', false);\n\n    if (data) {\n      this._data = data;\n    } else {\n      Ember.mixin(this._data, this._inFlightAttributes);\n    }\n\n    this._inFlightAttributes = {};\n\n    this.send('didCommit');\n    this.updateRecordArraysLater();\n\n    if (!data) { return; }\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  adapterDidDirty: function() {\n    this.send('becomeDirty');\n    this.updateRecordArraysLater();\n  },\n\n  dataDidChange: Ember.observer(function() {\n    this.reloadHasManys();\n  }, 'data'),\n\n  reloadHasManys: function() {\n    var relationships = get(this.constructor, 'relationshipsByName');\n    this.updateRecordArraysLater();\n    relationships.forEach(function(name, relationship) {\n      if (relationship.kind === 'hasMany') {\n        this.hasManyDidChange(relationship.key);\n      }\n    }, this);\n  },\n\n  hasManyDidChange: function(key) {\n    var hasMany = this._relationships[key];\n\n    if (hasMany) {\n      var type = get(this.constructor, 'relationshipsByName').get(key).type;\n      var store = get(this, 'store');\n      var records = this._data[key] || [];\n\n      set(hasMany, 'content', Ember.A(records));\n      set(hasMany, 'isLoaded', true);\n      hasMany.trigger('didLoad');\n    }\n  },\n\n  updateRecordArraysLater: function() {\n    Ember.run.once(this, this.updateRecordArrays);\n  },\n\n  setupData: function(data) {\n    this._data = data;\n\n    if (data) { this.pushedData(); }\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  materializeId: function(id) {\n    set(this, 'id', id);\n  },\n\n  materializeAttributes: function(attributes) {\n    Ember.assert(\"Must pass a hash of attributes to materializeAttributes\", !!attributes);\n    merge(this._data, attributes);\n  },\n\n  materializeAttribute: function(name, value) {\n    this._data[name] = value;\n  },\n\n  updateHasMany: function(name, records) {\n    this._data[name] = records;\n    this.hasManyDidChange(name);\n  },\n\n  rollback: function() {\n    this._attributes = {};\n    this.send('rolledBack');\n\n    this.suspendRelationshipObservers(function() {\n      this.notifyPropertyChange('data');\n    });\n  },\n\n  toStringExtension: function() {\n    return get(this, 'id');\n  },\n\n  /**\n    The goal of this method is to temporarily disable specific observers\n    that take action in response to application changes.\n\n    This allows the system to make changes (such as materialization and\n    rollback) that should not trigger secondary behavior (such as setting an\n    inverse relationship or marking records as dirty).\n\n    The specific implementation will likely change as Ember proper provides\n    better infrastructure for suspending groups of observers, and if Array\n    observation becomes more unified with regular observers.\n\n    @method suspendRelationshipObservers\n    @private\n    @param callback\n    @param binding\n  */\n  suspendRelationshipObservers: function(callback, binding) {\n    var observers = get(this.constructor, 'relationshipNames').belongsTo;\n    var self = this;\n\n    try {\n      this._suspendedRelationships = true;\n      Ember._suspendObservers(self, observers, null, 'belongsToDidChange', function() {\n        Ember._suspendBeforeObservers(self, observers, null, 'belongsToWillChange', function() {\n          callback.call(binding || self);\n        });\n      });\n    } finally {\n      this._suspendedRelationships = false;\n    }\n  },\n\n  /**\n    Save the record.\n\n    @method save\n  */\n  save: function() {\n    var resolver = Ember.RSVP.defer(), record = this;\n\n    this.get('store').scheduleSave(this, resolver);\n    this._inFlightAttributes = this._attributes;\n    this._attributes = {};\n\n    return DS.PromiseObject.create({ promise: resolver.promise });\n  },\n\n  /**\n    Reload the record from the adapter.\n\n    This will only work if the record has already finished loading\n    and has not yet been modified (`isLoaded` but not `isDirty`,\n    or `isSaving`).\n\n    @method reload\n  */\n  reload: function() {\n    set(this, 'isReloading', true);\n\n    var resolver = Ember.RSVP.defer(), record = this;\n\n    resolver.promise = resolver.promise.then(function() {\n      record.set('isReloading', false);\n      record.set('isError', false);\n      return record;\n    }, function(reason) {\n      record.set('isError', true);\n      throw reason;\n    });\n\n    this.send('reloadRecord', resolver);\n\n    return DS.PromiseObject.create({ promise: resolver.promise });\n  },\n\n  // FOR USE DURING COMMIT PROCESS\n\n  adapterDidUpdateAttribute: function(attributeName, value) {\n\n    // If a value is passed in, update the internal attributes and clear\n    // the attribute cache so it picks up the new value. Otherwise,\n    // collapse the current value into the internal attributes because\n    // the adapter has acknowledged it.\n    if (value !== undefined) {\n      this._data[attributeName] = value;\n      this.notifyPropertyChange(attributeName);\n    } else {\n      this._data[attributeName] = this._inFlightAttributes[attributeName];\n    }\n\n    this.updateRecordArraysLater();\n  },\n\n  adapterDidInvalidate: function(errors) {\n    this.send('becameInvalid', errors);\n  },\n\n  adapterDidError: function() {\n    this.send('becameError');\n    set(this, 'isError', true);\n  },\n\n  /**\n    Override the default event firing from Ember.Evented to\n    also call methods with the given name.\n\n    @method trigger\n    @private\n    @param name\n  */\n  trigger: function(name) {\n    Ember.tryInvoke(this, name, [].slice.call(arguments, 1));\n    this._super.apply(this, arguments);\n  },\n\n  triggerLater: function() {\n    this._deferredTriggers.push(arguments);\n    once(this, '_triggerDeferredTriggers');\n  },\n\n  _triggerDeferredTriggers: function() {\n    for (var i=0, l=this._deferredTriggers.length; i<l; i++) {\n      this.trigger.apply(this, this._deferredTriggers[i]);\n    }\n\n    this._deferredTriggers = [];\n  }\n});\n\nDS.Model.reopenClass({\n\n  /**\n    Alias DS.Model's `create` method to `_create`. This allows us to create DS.Model\n    instances from within the store, but if end users accidentally call `create()`\n    (instead of `createRecord()`), we can raise an error.\n\n    @method _create\n    @private\n    @static\n  */\n  _create: DS.Model.create,\n\n  /**\n    Override the class' `create()` method to raise an error. This prevents end users\n    from inadvertently calling `create()` instead of `createRecord()`. The store is\n    still able to create instances by calling the `_create()` method.\n\n    @method create\n    @private\n    @static\n  */\n  create: function() {\n    throw new Ember.Error(\"You should not call `create` on a model. Instead, call `store.createRecord` with the attributes you would like to set.\");\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/model/model");minispade.register('ember-data/system/model/states', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set,\n    once = Ember.run.once, arrayMap = Ember.ArrayPolyfills.map;\n\n/*\n  WARNING: Much of these docs are inaccurate as of bf8497.\n\n  This file encapsulates the various states that a record can transition\n  through during its lifecycle.\n\n  ### State Manager\n\n  A record's state manager explicitly tracks what state a record is in\n  at any given time. For instance, if a record is newly created and has\n  not yet been sent to the adapter to be saved, it would be in the\n  `created.uncommitted` state.  If a record has had local modifications\n  made to it that are in the process of being saved, the record would be\n  in the `updated.inFlight` state. (These state paths will be explained\n  in more detail below.)\n\n  Events are sent by the record or its store to the record's state manager.\n  How the state manager reacts to these events is dependent on which state\n  it is in. In some states, certain events will be invalid and will cause\n  an exception to be raised.\n\n  States are hierarchical. For example, a record can be in the\n  `deleted.start` state, then transition into the `deleted.inFlight` state.\n  If a child state does not implement an event handler, the state manager\n  will attempt to invoke the event on all parent states until the root state is\n  reached. The state hierarchy of a record is described in terms of a path\n  string. You can determine a record's current state by getting its manager's\n  current state path:\n\n      record.get('stateManager.currentPath');\n      //=> \"created.uncommitted\"\n\n  The `DS.Model` states are themselves stateless. What we mean is that,\n  though each instance of a record also has a unique instance of a\n  `DS.StateManager`, the hierarchical states that each of *those* points\n  to is a shared data structure. For performance reasons, instead of each\n  record getting its own copy of the hierarchy of states, each state\n  manager points to this global, immutable shared instance. How does a\n  state know which record it should be acting on?  We pass a reference to\n  the current state manager as the first parameter to every method invoked\n  on a state.\n\n  The state manager passed as the first parameter is where you should stash\n  state about the record if needed; you should never store data on the state\n  object itself. If you need access to the record being acted on, you can\n  retrieve the state manager's `record` property. For example, if you had\n  an event handler `myEvent`:\n\n      myEvent: function(manager) {\n        var record = manager.get('record');\n        record.doSomething();\n      }\n\n  For more information about state managers in general, see the Ember.js\n  documentation on `Ember.StateManager`.\n\n  ### Events, Flags, and Transitions\n\n  A state may implement zero or more events, flags, or transitions.\n\n  #### Events\n\n  Events are named functions that are invoked when sent to a record. The\n  state manager will first look for a method with the given name on the\n  current state. If no method is found, it will search the current state's\n  parent, and then its grandparent, and so on until reaching the top of\n  the hierarchy. If the root is reached without an event handler being found,\n  an exception will be raised. This can be very helpful when debugging new\n  features.\n\n  Here's an example implementation of a state with a `myEvent` event handler:\n\n      aState: DS.State.create({\n        myEvent: function(manager, param) {\n          console.log(\"Received myEvent with \"+param);\n        }\n      })\n\n  To trigger this event:\n\n      record.send('myEvent', 'foo');\n      //=> \"Received myEvent with foo\"\n\n  Note that an optional parameter can be sent to a record's `send()` method,\n  which will be passed as the second parameter to the event handler.\n\n  Events should transition to a different state if appropriate. This can be\n  done by calling the state manager's `transitionTo()` method with a path to the\n  desired state. The state manager will attempt to resolve the state path\n  relative to the current state. If no state is found at that path, it will\n  attempt to resolve it relative to the current state's parent, and then its\n  parent, and so on until the root is reached. For example, imagine a hierarchy\n  like this:\n\n      * created\n        * start <-- currentState\n        * inFlight\n      * updated\n        * inFlight\n\n  If we are currently in the `start` state, calling\n  `transitionTo('inFlight')` would transition to the `created.inFlight` state,\n  while calling `transitionTo('updated.inFlight')` would transition to\n  the `updated.inFlight` state.\n\n  Remember that *only events* should ever cause a state transition. You should\n  never call `transitionTo()` from outside a state's event handler. If you are\n  tempted to do so, create a new event and send that to the state manager.\n\n  #### Flags\n\n  Flags are Boolean values that can be used to introspect a record's current\n  state in a more user-friendly way than examining its state path. For example,\n  instead of doing this:\n\n      var statePath = record.get('stateManager.currentPath');\n      if (statePath === 'created.inFlight') {\n        doSomething();\n      }\n\n  You can say:\n\n      if (record.get('isNew') && record.get('isSaving')) {\n        doSomething();\n      }\n\n  If your state does not set a value for a given flag, the value will\n  be inherited from its parent (or the first place in the state hierarchy\n  where it is defined).\n\n  The current set of flags are defined below. If you want to add a new flag,\n  in addition to the area below, you will also need to declare it in the\n  `DS.Model` class.\n\n  #### Transitions\n\n  Transitions are like event handlers but are called automatically upon\n  entering or exiting a state. To implement a transition, just call a method\n  either `enter` or `exit`:\n\n      myState: DS.State.create({\n        // Gets called automatically when entering\n        // this state.\n        enter: function(manager) {\n          console.log(\"Entered myState\");\n        }\n      })\n\n  Note that enter and exit events are called once per transition. If the\n  current state changes, but changes to another child state of the parent,\n  the transition event on the parent will not be triggered.\n*/\n\nvar hasDefinedProperties = function(object) {\n  // Ignore internal property defined by simulated `Ember.create`.\n  var names = Ember.keys(object);\n  var i, l, name;\n  for (i = 0, l = names.length; i < l; i++ ) {\n    name = names[i];\n    if (object.hasOwnProperty(name) && object[name]) { return true; }\n  }\n\n  return false;\n};\n\nvar didSetProperty = function(record, context) {\n  if (context.value !== context.oldValue) {\n    record.send('becomeDirty');\n    record.updateRecordArraysLater();\n  }\n};\n\n// Implementation notes:\n//\n// Each state has a boolean value for all of the following flags:\n//\n// * isLoaded: The record has a populated `data` property. When a\n//   record is loaded via `store.find`, `isLoaded` is false\n//   until the adapter sets it. When a record is created locally,\n//   its `isLoaded` property is always true.\n// * isDirty: The record has local changes that have not yet been\n//   saved by the adapter. This includes records that have been\n//   created (but not yet saved) or deleted.\n// * isSaving: The record has been committed, but\n//   the adapter has not yet acknowledged that the changes have\n//   been persisted to the backend.\n// * isDeleted: The record was marked for deletion. When `isDeleted`\n//   is true and `isDirty` is true, the record is deleted locally\n//   but the deletion was not yet persisted. When `isSaving` is\n//   true, the change is in-flight. When both `isDirty` and\n//   `isSaving` are false, the change has persisted.\n// * isError: The adapter reported that it was unable to save\n//   local changes to the backend. This may also result in the\n//   record having its `isValid` property become false if the\n//   adapter reported that server-side validations failed.\n// * isNew: The record was created on the client and the adapter\n//   did not yet report that it was successfully saved.\n// * isValid: No client-side validations have failed and the\n//   adapter did not report any server-side validation failures.\n\n// The dirty state is a abstract state whose functionality is\n// shared between the `created` and `updated` states.\n//\n// The deleted state shares the `isDirty` flag with the\n// subclasses of `DirtyState`, but with a very different\n// implementation.\n//\n// Dirty states have three child states:\n//\n// `uncommitted`: the store has not yet handed off the record\n//   to be saved.\n// `inFlight`: the store has handed off the record to be saved,\n//   but the adapter has not yet acknowledged success.\n// `invalid`: the record has invalid information and cannot be\n//   send to the adapter yet.\nvar DirtyState = {\n  initialState: 'uncommitted',\n\n  // FLAGS\n  isDirty: true,\n\n  // SUBSTATES\n\n  // When a record first becomes dirty, it is `uncommitted`.\n  // This means that there are local pending changes, but they\n  // have not yet begun to be saved, and are not invalid.\n  uncommitted: {\n\n    // EVENTS\n    didSetProperty: didSetProperty,\n\n    pushedData: Ember.K,\n\n    becomeDirty: Ember.K,\n\n    willCommit: function(record) {\n      record.transitionTo('inFlight');\n    },\n\n    reloadRecord: function(record, resolver) {\n      get(record, 'store').reloadRecord(record, resolver);\n    },\n\n    rolledBack: function(record) {\n      record.transitionTo('loaded.saved');\n    },\n\n    becameInvalid: function(record) {\n      record.transitionTo('invalid');\n    },\n\n    rollback: function(record) {\n      record.rollback();\n    }\n  },\n\n  // Once a record has been handed off to the adapter to be\n  // saved, it is in the 'in flight' state. Changes to the\n  // record cannot be made during this window.\n  inFlight: {\n    // FLAGS\n    isSaving: true,\n\n    // EVENTS\n    didSetProperty: didSetProperty,\n    becomeDirty: Ember.K,\n    pushedData: Ember.K,\n\n    // TODO: More robust semantics around save-while-in-flight\n    willCommit: Ember.K,\n\n    didCommit: function(record) {\n      var dirtyType = get(this, 'dirtyType');\n\n      record.transitionTo('saved');\n      record.send('invokeLifecycleCallbacks', dirtyType);\n    },\n\n    becameInvalid: function(record, errors) {\n      set(record, 'errors', errors);\n\n      record.transitionTo('invalid');\n      record.send('invokeLifecycleCallbacks');\n    },\n\n    becameError: function(record) {\n      record.transitionTo('uncommitted');\n      record.triggerLater('becameError', record);\n    }\n  },\n\n  // A record is in the `invalid` state when its client-side\n  // invalidations have failed, or if the adapter has indicated\n  // the the record failed server-side invalidations.\n  invalid: {\n    // FLAGS\n    isValid: false,\n\n    // EVENTS\n    deleteRecord: function(record) {\n      record.transitionTo('deleted.uncommitted');\n      record.clearRelationships();\n    },\n\n    didSetProperty: function(record, context) {\n      var errors = get(record, 'errors'),\n          key = context.name;\n\n      set(errors, key, null);\n\n      if (!hasDefinedProperties(errors)) {\n        record.send('becameValid');\n      }\n\n      didSetProperty(record, context);\n    },\n\n    becomeDirty: Ember.K,\n\n    rollback: function(record) {\n      record.send('becameValid');\n      record.send('rollback');\n    },\n\n    becameValid: function(record) {\n      record.transitionTo('uncommitted');\n    },\n\n    invokeLifecycleCallbacks: function(record) {\n      record.triggerLater('becameInvalid', record);\n    }\n  }\n};\n\n// The created and updated states are created outside the state\n// chart so we can reopen their substates and add mixins as\n// necessary.\n\nfunction deepClone(object) {\n  var clone = {}, value;\n\n  for (var prop in object) {\n    value = object[prop];\n    if (value && typeof value === 'object') {\n      clone[prop] = deepClone(value);\n    } else {\n      clone[prop] = value;\n    }\n  }\n\n  return clone;\n}\n\nfunction mixin(original, hash) {\n  for (var prop in hash) {\n    original[prop] = hash[prop];\n  }\n\n  return original;\n}\n\nfunction dirtyState(options) {\n  var newState = deepClone(DirtyState);\n  return mixin(newState, options);\n}\n\nvar createdState = dirtyState({\n  dirtyType: 'created',\n\n  // FLAGS\n  isNew: true\n});\n\nvar updatedState = dirtyState({\n  dirtyType: 'updated'\n});\n\ncreatedState.uncommitted.deleteRecord = function(record) {\n  record.clearRelationships();\n  record.transitionTo('deleted.saved');\n};\n\ncreatedState.uncommitted.rollback = function(record) {\n  DirtyState.uncommitted.rollback.apply(this, arguments);\n  record.transitionTo('deleted.saved');\n};\n\nupdatedState.uncommitted.deleteRecord = function(record) {\n  record.transitionTo('deleted.uncommitted');\n  record.clearRelationships();\n};\n\nvar RootState = {\n  // FLAGS\n  isEmpty: false,\n  isLoading: false,\n  isLoaded: false,\n  isDirty: false,\n  isSaving: false,\n  isDeleted: false,\n  isNew: false,\n  isValid: true,\n\n  // DEFAULT EVENTS\n\n  // Trying to roll back if you're not in the dirty state\n  // doesn't change your state. For example, if you're in the\n  // in-flight state, rolling back the record doesn't move\n  // you out of the in-flight state.\n  rolledBack: Ember.K,\n\n  // SUBSTATES\n\n  // A record begins its lifecycle in the `empty` state.\n  // If its data will come from the adapter, it will\n  // transition into the `loading` state. Otherwise, if\n  // the record is being created on the client, it will\n  // transition into the `created` state.\n  empty: {\n    isEmpty: true,\n\n    // EVENTS\n    loadingData: function(record) {\n      record.transitionTo('loading');\n    },\n\n    loadedData: function(record) {\n      record.transitionTo('loaded.created.uncommitted');\n\n      record.suspendRelationshipObservers(function() {\n        record.notifyPropertyChange('data');\n      });\n    },\n\n    pushedData: function(record) {\n      record.transitionTo('loaded.saved');\n    }\n  },\n\n  // A record enters this state when the store askes\n  // the adapter for its data. It remains in this state\n  // until the adapter provides the requested data.\n  //\n  // Usually, this process is asynchronous, using an\n  // XHR to retrieve the data.\n  loading: {\n    // FLAGS\n    isLoading: true,\n\n    // EVENTS\n    pushedData: function(record) {\n      record.transitionTo('loaded.saved');\n      record.triggerLater('didLoad');\n      set(record, 'isError', false);\n    },\n\n    becameError: function(record) {\n      record.triggerLater('becameError', record);\n    }\n  },\n\n  // A record enters this state when its data is populated.\n  // Most of a record's lifecycle is spent inside substates\n  // of the `loaded` state.\n  loaded: {\n    initialState: 'saved',\n\n    // FLAGS\n    isLoaded: true,\n\n    // SUBSTATES\n\n    // If there are no local changes to a record, it remains\n    // in the `saved` state.\n    saved: {\n      setup: function(record) {\n        var attrs = record._attributes,\n            isDirty = false;\n\n        for (var prop in attrs) {\n          if (attrs.hasOwnProperty(prop)) {\n            isDirty = true;\n            break;\n          }\n        }\n\n        if (isDirty) {\n          record.adapterDidDirty();\n        }\n      },\n\n      // EVENTS\n      didSetProperty: didSetProperty,\n\n      pushedData: Ember.K,\n\n      becomeDirty: function(record) {\n        record.transitionTo('updated.uncommitted');\n      },\n\n      willCommit: function(record) {\n        record.transitionTo('updated.inFlight');\n      },\n\n      reloadRecord: function(record, resolver) {\n        get(record, 'store').reloadRecord(record, resolver);\n      },\n\n      deleteRecord: function(record) {\n        record.transitionTo('deleted.uncommitted');\n        record.clearRelationships();\n      },\n\n      unloadRecord: function(record) {\n        // clear relationships before moving to deleted state\n        // otherwise it fails\n        record.clearRelationships();\n        record.transitionTo('deleted.saved');\n      },\n\n      didCommit: function(record) {\n        record.send('invokeLifecycleCallbacks', get(record, 'lastDirtyType'));\n      },\n\n    },\n\n    // A record is in this state after it has been locally\n    // created but before the adapter has indicated that\n    // it has been saved.\n    created: createdState,\n\n    // A record is in this state if it has already been\n    // saved to the server, but there are new local changes\n    // that have not yet been saved.\n    updated: updatedState\n  },\n\n  // A record is in this state if it was deleted from the store.\n  deleted: {\n    initialState: 'uncommitted',\n    dirtyType: 'deleted',\n\n    // FLAGS\n    isDeleted: true,\n    isLoaded: true,\n    isDirty: true,\n\n    // TRANSITIONS\n    setup: function(record) {\n      var store = get(record, 'store');\n\n      store.recordArrayManager.remove(record);\n    },\n\n    // SUBSTATES\n\n    // When a record is deleted, it enters the `start`\n    // state. It will exit this state when the record\n    // starts to commit.\n    uncommitted: {\n\n      // EVENTS\n\n      willCommit: function(record) {\n        record.transitionTo('inFlight');\n      },\n\n      rollback: function(record) {\n        record.rollback();\n      },\n\n      becomeDirty: Ember.K,\n      deleteRecord: Ember.K,\n\n      rolledBack: function(record) {\n        record.transitionTo('loaded.saved');\n      }\n    },\n\n    // After a record starts committing, but\n    // before the adapter indicates that the deletion\n    // has saved to the server, a record is in the\n    // `inFlight` substate of `deleted`.\n    inFlight: {\n      // FLAGS\n      isSaving: true,\n\n      // EVENTS\n\n      // TODO: More robust semantics around save-while-in-flight\n      willCommit: Ember.K,\n      didCommit: function(record) {\n        record.transitionTo('saved');\n\n        record.send('invokeLifecycleCallbacks');\n      },\n\n      becameError: function(record) {\n        record.transitionTo('uncommitted');\n        record.triggerLater('becameError', record);\n      }\n    },\n\n    // Once the adapter indicates that the deletion has\n    // been saved, the record enters the `saved` substate\n    // of `deleted`.\n    saved: {\n      // FLAGS\n      isDirty: false,\n\n      setup: function(record) {\n        var store = get(record, 'store');\n        store.dematerializeRecord(record);\n      },\n\n      invokeLifecycleCallbacks: function(record) {\n        record.triggerLater('didDelete', record);\n        record.triggerLater('didCommit', record);\n      }\n    }\n  },\n\n  invokeLifecycleCallbacks: function(record, dirtyType) {\n    if (dirtyType === 'created') {\n      record.triggerLater('didCreate', record);\n    } else {\n      record.triggerLater('didUpdate', record);\n    }\n\n    record.triggerLater('didCommit', record);\n  }\n};\n\nvar hasOwnProp = {}.hasOwnProperty;\n\nfunction wireState(object, parent, name) {\n  /*jshint proto:true*/\n  // TODO: Use Object.create and copy instead\n  object = mixin(parent ? Ember.create(parent) : {}, object);\n  object.parentState = parent;\n  object.stateName = name;\n\n  for (var prop in object) {\n    if (!object.hasOwnProperty(prop) || prop === 'parentState' || prop === 'stateName') { continue; }\n    if (typeof object[prop] === 'object') {\n      object[prop] = wireState(object[prop], object, name + \".\" + prop);\n    }\n  }\n\n  return object;\n}\n\nRootState = wireState(RootState, null, \"root\");\n\nDS.RootState = RootState;\n\n})();\n//@ sourceURL=ember-data/system/model/states");minispade.register('ember-data/system/record_array_manager', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar forEach = Ember.EnumerableUtils.forEach;\n\n/**\n  @class RecordArrayManager\n  @namespace DS\n  @private\n  @extends Ember.Object\n*/\nDS.RecordArrayManager = Ember.Object.extend({\n  init: function() {\n    this.filteredRecordArrays = Ember.MapWithDefault.create({\n      defaultValue: function() { return []; }\n    });\n\n    this.changedRecords = [];\n  },\n\n  recordDidChange: function(record) {\n    this.changedRecords.push(record);\n    once(this, this.updateRecordArrays);\n  },\n\n  recordArraysForRecord: function(record) {\n    record._recordArrays = record._recordArrays || Ember.OrderedSet.create();\n    return record._recordArrays;\n  },\n\n  /**\n    This method is invoked whenever data is loaded into the store\n    by the adapter or updated by the adapter, or when an attribute\n    changes on a record.\n\n    It updates all filters that a record belongs to.\n\n    To avoid thrashing, it only runs once per run loop per record.\n\n    @method updateRecordArrays\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArrays: function() {\n    forEach(this.changedRecords, function(record) {\n      var type = record.constructor,\n          recordArrays = this.filteredRecordArrays.get(type),\n          filter;\n\n      forEach(recordArrays, function(array) {\n        filter = get(array, 'filterFunction');\n        this.updateRecordArray(array, filter, type, record);\n      }, this);\n\n      // loop through all manyArrays containing an unloaded copy of this\n      // clientId and notify them that the record was loaded.\n      var manyArrays = record._loadingRecordArrays;\n\n      if (manyArrays) {\n        for (var i=0, l=manyArrays.length; i<l; i++) {\n          manyArrays[i].loadedRecord();\n        }\n\n        record._loadingRecordArrays = [];\n      }\n    }, this);\n\n    this.changedRecords = [];\n  },\n\n  /**\n    Update an individual filter.\n\n    @method updateRecordArray\n    @param {DS.FilteredRecordArray} array\n    @param {Function} filter\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArray: function(array, filter, type, record) {\n    var shouldBeInArray;\n\n    if (!filter) {\n      shouldBeInArray = true;\n    } else {\n      shouldBeInArray = filter(record);\n    }\n\n    var recordArrays = this.recordArraysForRecord(record);\n\n    if (shouldBeInArray) {\n      recordArrays.add(array);\n      array.addRecord(record);\n    } else if (!shouldBeInArray) {\n      recordArrays.remove(array);\n      array.removeRecord(record);\n    }\n  },\n\n  /**\n    When a record is deleted, it is removed from all its\n    record arrays.\n\n    @method remove\n    @param {DS.Model} record\n  */\n  remove: function(record) {\n    var recordArrays = record._recordArrays;\n\n    if (!recordArrays) { return; }\n\n    forEach(recordArrays, function(array) {\n      array.removeRecord(record);\n    });\n  },\n\n  /**\n    This method is invoked if the `filterFunction` property is\n    changed on a `DS.FilteredRecordArray`.\n\n    It essentially re-runs the filter from scratch. This same\n    method is invoked when the filter is created in th first place.\n\n    @method updateFilter\n    @param array\n    @param type\n    @param filter\n  */\n  updateFilter: function(array, type, filter) {\n    var typeMap = this.store.typeMapFor(type),\n        records = typeMap.records, record;\n\n    for (var i=0, l=records.length; i<l; i++) {\n      record = records[i];\n\n      if (!get(record, 'isDeleted') && !get(record, 'isEmpty')) {\n        this.updateRecordArray(array, filter, type, record);\n      }\n    }\n  },\n\n  /**\n    Create a `DS.ManyArray` for a type and list of record references, and index\n    the `ManyArray` under each reference. This allows us to efficiently remove\n    records from `ManyArray`s when they are deleted.\n\n    @method createManyArray\n    @param {Class} type\n    @param {Array} references\n    @return {DS.ManyArray}\n  */\n  createManyArray: function(type, records) {\n    var manyArray = DS.ManyArray.create({\n      type: type,\n      content: records,\n      store: this.store\n    });\n\n    forEach(records, function(record) {\n      var arrays = this.recordArraysForRecord(record);\n      arrays.add(manyArray);\n    }, this);\n\n    return manyArray;\n  },\n\n  /**\n    Register a RecordArray for a given type to be backed by\n    a filter function. This will cause the array to update\n    automatically when records of that type change attribute\n    values or states.\n\n    @method registerFilteredRecordArray\n    @param {DS.RecordArray} array\n    @param {Class} type\n    @param {Function} filter\n  */\n  registerFilteredRecordArray: function(array, type, filter) {\n    var recordArrays = this.filteredRecordArrays.get(type);\n    recordArrays.push(array);\n\n    this.updateFilter(array, type, filter);\n  },\n\n  // Internally, we maintain a map of all unloaded IDs requested by\n  // a ManyArray. As the adapter loads data into the store, the\n  // store notifies any interested ManyArrays. When the ManyArray's\n  // total number of loading records drops to zero, it becomes\n  // `isLoaded` and fires a `didLoad` event.\n  registerWaitingRecordArray: function(record, array) {\n    var loadingRecordArrays = record._loadingRecordArrays || [];\n    loadingRecordArrays.push(array);\n    record._loadingRecordArrays = loadingRecordArrays;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_array_manager");minispade.register('ember-data/system/record_arrays', "(function() {/**\n  @module ember-data\n*/\nminispade.require('ember-data/system/record_arrays/record_array');\nminispade.require('ember-data/system/record_arrays/filtered_record_array');\nminispade.require('ember-data/system/record_arrays/adapter_populated_record_array');\nminispade.require('ember-data/system/record_arrays/many_array');\n\n})();\n//@ sourceURL=ember-data/system/record_arrays");minispade.register('ember-data/system/record_arrays/adapter_populated_record_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  @class AdapterPopulatedRecordArray\n  @namespace DS\n  @extends DS.RecordArray\n*/\nDS.AdapterPopulatedRecordArray = DS.RecordArray.extend({\n  query: null,\n\n  replace: function() {\n    var type = get(this, 'type').toString();\n    throw new Error(\"The result of a server query (on \" + type + \") is immutable.\");\n  },\n\n  load: function(data) {\n    var store = get(this, 'store'),\n        type = get(this, 'type'),\n        records = store.pushMany(type, data);\n\n    this.setProperties({\n      content: Ember.A(records),\n      isLoaded: true\n    });\n\n    // TODO: does triggering didLoad event should be the last action of the runLoop?\n    Ember.run.once(this, 'trigger', 'didLoad');\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/adapter_populated_record_array");minispade.register('ember-data/system/record_arrays/filtered_record_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get;\n\n/**\n  @class FilteredRecordArray\n  @namespace DS\n  @extends DS.RecordArray\n*/\nDS.FilteredRecordArray = DS.RecordArray.extend({\n  filterFunction: null,\n  isLoaded: true,\n\n  replace: function() {\n    var type = get(this, 'type').toString();\n    throw new Error(\"The result of a client-side filter (on \" + type + \") is immutable.\");\n  },\n\n  updateFilter: Ember.observer(function() {\n    var manager = get(this, 'manager');\n    manager.updateFilter(this, get(this, 'type'), get(this, 'filterFunction'));\n  }, 'filterFunction')\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/filtered_record_array");minispade.register('ember-data/system/record_arrays/many_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar map = Ember.EnumerableUtils.map;\n\n/**\n  A ManyArray is a RecordArray that represents the contents of a has-many\n  relationship.\n\n  The ManyArray is instantiated lazily the first time the relationship is\n  requested.\n\n  ### Inverses\n\n  Often, the relationships in Ember Data applications will have\n  an inverse. For example, imagine the following models are\n  defined:\n\n      App.Post = DS.Model.extend({\n        comments: DS.hasMany('App.Comment')\n      });\n\n      App.Comment = DS.Model.extend({\n        post: DS.belongsTo('App.Post')\n      });\n\n  If you created a new instance of `App.Post` and added\n  a `App.Comment` record to its `comments` has-many\n  relationship, you would expect the comment's `post`\n  property to be set to the post that contained\n  the has-many.\n\n  We call the record to which a relationship belongs the\n  relationship's _owner_.\n\n  @class ManyArray\n  @namespace DS\n  @extends DS.RecordArray\n*/\nDS.ManyArray = DS.RecordArray.extend({\n  init: function() {\n    this._super.apply(this, arguments);\n    this._changesToSync = Ember.OrderedSet.create();\n  },\n\n  /**\n    The record to which this relationship belongs.\n\n    @property {DS.Model}\n    @private\n  */\n  owner: null,\n\n  /**\n    `true` if the relationship is polymorphic, `false` otherwise.\n\n    @property {Boolean}\n    @private\n  */\n  isPolymorphic: false,\n\n  // LOADING STATE\n\n  isLoaded: false,\n\n  loadingRecordsCount: function(count) {\n    this.loadingRecordsCount = count;\n  },\n\n  loadedRecord: function() {\n    this.loadingRecordsCount--;\n    if (this.loadingRecordsCount === 0) {\n      set(this, 'isLoaded', true);\n      this.trigger('didLoad');\n    }\n  },\n\n  fetch: function() {\n    var records = get(this, 'content'),\n        store = get(this, 'store'),\n        owner = get(this, 'owner');\n\n    var unloadedRecords = records.filterProperty('isEmpty', true);\n    store.fetchMany(unloadedRecords, owner);\n  },\n\n  // Overrides Ember.Array's replace method to implement\n  replaceContent: function(index, removed, added) {\n    // Map the array of record objects into an array of  client ids.\n    added = map(added, function(record) {\n      Ember.assert(\"You cannot add '\" + record.constructor.typeKey + \"' records to this relationship (only '\" + this.type.typeKey + \"' allowed)\", !this.type || record instanceof this.type);\n      return record;\n    }, this);\n\n    this._super(index, removed, added);\n  },\n\n  arrangedContentDidChange: function() {\n    this.fetch();\n  },\n\n  arrayContentWillChange: function(index, removed, added) {\n    var owner = get(this, 'owner'),\n        name = get(this, 'name');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the first half of code that continues inside\n      // of arrayContentDidChange. It gets or creates a change from\n      // the child object, adds the current owner as the old\n      // parent if this is the first time the object was removed\n      // from a ManyArray, and sets `newParent` to null.\n      //\n      // Later, if the object is added to another ManyArray,\n      // the `arrayContentDidChange` will set `newParent` on\n      // the change.\n      for (var i=index; i<index+removed; i++) {\n        var record = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner, record, get(this, 'store'), {\n          parentType: owner.constructor,\n          changeType: \"remove\",\n          kind: \"hasMany\",\n          key: name\n        });\n\n        this._changesToSync.add(change);\n      }\n    }\n\n    return this._super.apply(this, arguments);\n  },\n\n  arrayContentDidChange: function(index, removed, added) {\n    this._super.apply(this, arguments);\n\n    var owner = get(this, 'owner'),\n        name = get(this, 'name'),\n        store = get(this, 'store');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the second half of code that started in\n      // `arrayContentWillChange`. It gets or creates a change\n      // from the child object, and adds the current owner as\n      // the new parent.\n      for (var i=index; i<index+added; i++) {\n        var record = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner, record, store, {\n          parentType: owner.constructor,\n          changeType: \"add\",\n          kind:\"hasMany\",\n          key: name\n        });\n        change.hasManyName = name;\n\n        this._changesToSync.add(change);\n      }\n\n      // We wait until the array has finished being\n      // mutated before syncing the OneToManyChanges created\n      // in arrayContentWillChange, so that the array\n      // membership test in the sync() logic operates\n      // on the final results.\n      this._changesToSync.forEach(function(change) {\n        change.sync();\n      });\n\n      this._changesToSync.clear();\n    }\n  },\n\n  // Create a child record within the owner\n  createRecord: function(hash) {\n    var owner = get(this, 'owner'),\n        store = get(owner, 'store'),\n        type = get(this, 'type'),\n        record;\n\n    Ember.assert(\"You cannot add '\" + type.typeKey + \"' records to this polymorphic relationship.\", !get(this, 'isPolymorphic'));\n\n    record = store.createRecord.call(store, type, hash);\n    this.pushObject(record);\n\n    return record;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/many_array");minispade.register('ember-data/system/record_arrays/record_array', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  A record array is an array that contains records of a certain type. The record\n  array materializes records as needed when they are retrieved for the first\n  time. You should not create record arrays yourself. Instead, an instance of\n  DS.RecordArray or its subclasses will be returned by your application's store\n  in response to queries.\n\n  @class RecordArray\n  @namespace DS\n  @extends Ember.ArrayProxy\n  @uses Ember.Evented\n*/\n\nDS.RecordArray = Ember.ArrayProxy.extend(Ember.Evented, {\n  /**\n    The model type contained by this record array.\n\n    @property type\n    @type DS.Model\n  */\n  type: null,\n\n  // The array of client ids backing the record array. When a\n  // record is requested from the record array, the record\n  // for the client id at the same index is materialized, if\n  // necessary, by the store.\n  content: null,\n\n  isLoaded: false,\n  isUpdating: false,\n\n  // The store that created this record array.\n  store: null,\n\n  objectAtContent: function(index) {\n    var content = get(this, 'content');\n\n    return content.objectAt(index);\n  },\n\n  update: function() {\n    if (get(this, 'isUpdating')) { return; }\n\n    var store = get(this, 'store'),\n        type = get(this, 'type');\n\n    store.fetchAll(type, this);\n  },\n\n  addRecord: function(record) {\n    get(this, 'content').addObject(record);\n  },\n\n  removeRecord: function(record) {\n    get(this, 'content').removeObject(record);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/record_array");minispade.register('ember-data/system/relationships', "(function() {/**\n  @module ember-data\n*/\nminispade.require(\"ember-data/system/relationships/belongs_to\");\nminispade.require(\"ember-data/system/relationships/has_many\");\nminispade.require(\"ember-data/system/relationships/ext\");\n\n})();\n//@ sourceURL=ember-data/system/relationships");minispade.register('ember-data/system/relationships/belongs_to', "(function() {var get = Ember.get, set = Ember.set,\n    isNone = Ember.isNone;\n\n/**\n  @module ember-data\n*/\n\nfunction asyncBelongsTo(type, options, meta) {\n  return Ember.computed(function(key, value) {\n    var data = get(this, 'data'),\n        store = get(this, 'store');\n\n    if (arguments.length === 2) {\n      Ember.assert(\"You can only add a '\" + type + \"' record to this relationship\", !value || value instanceof store.modelFor(type));\n      return value === undefined ? null : value;\n    }\n\n    return store.fetchRecord(data[key]);\n  }).property('data').meta(meta);\n}\n\nDS.belongsTo = function(type, options) {\n  Ember.assert(\"The first argument DS.belongsTo must be a model type or string, like DS.belongsTo(App.Person)\", !!type && (typeof type === 'string' || DS.Model.detect(type)));\n\n  options = options || {};\n\n  var meta = { type: type, isRelationship: true, options: options, kind: 'belongsTo' };\n\n  if (options.async) {\n    return asyncBelongsTo(type, options, meta);\n  }\n\n  return Ember.computed(function(key, value) {\n    var data = get(this, 'data'),\n        store = get(this, 'store'), belongsTo, typeClass;\n\n    if (typeof type === 'string') {\n      if (type.indexOf(\".\") === -1) {\n        typeClass = store.modelFor(type);\n      } else {\n        typeClass = get(Ember.lookup, type);\n      }\n    } else {\n      typeClass = type;\n    }\n\n    if (arguments.length === 2) {\n      Ember.assert(\"You can only add a '\" + type + \"' record to this relationship\", !value || value instanceof typeClass);\n      return value === undefined ? null : value;\n    }\n\n    belongsTo = data[key];\n\n    if (isNone(belongsTo)) { return null; }\n\n    if (get(belongsTo, 'isEmpty')) {\n      store.fetchRecord(belongsTo);\n    }\n\n    return belongsTo;\n  }).property('data').meta(meta);\n};\n\n/*\n  These observers observe all `belongsTo` relationships on the record. See\n  `relationships/ext` to see how these observers get their dependencies.\n\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopen({\n\n  /**\n    @method belongsToWillChange\n    @private\n    @static\n    @param record\n    @param key\n  */\n  belongsToWillChange: Ember.beforeObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var oldParent = get(record, key),\n          store = get(record, 'store');\n\n      if (oldParent){\n        var change = DS.RelationshipChange.createChange(record, oldParent, store, { key: key, kind: \"belongsTo\", changeType: \"remove\" });\n        change.sync();\n        this._changesToSync[key] = change;\n      }\n    }\n  }),\n\n  /**\n    @method belongsToDidChange\n    @private\n    @static\n    @param record\n    @param key\n  */\n  belongsToDidChange: Ember.immediateObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var newParent = get(record, key);\n      if(newParent){\n        var store = get(record, 'store'),\n            change = DS.RelationshipChange.createChange(record, newParent, store, { key: key, kind: \"belongsTo\", changeType: \"add\" });\n\n        change.sync();\n      }\n    }\n\n    delete this._changesToSync[key];\n  })\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/belongs_to");minispade.register('ember-data/system/relationships/ext', "(function() {var get = Ember.get, set = Ember.set;\n\n/**\n  @module ember-data\n*/\n\n/*\n  This file defines several extensions to the base `DS.Model` class that\n  add support for one-to-many relationships.\n*/\n\n/**\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopen({\n\n  /**\n    This Ember.js hook allows an object to be notified when a property\n    is defined.\n\n    In this case, we use it to be notified when an Ember Data user defines a\n    belongs-to relationship. In that case, we need to set up observers for\n    each one, allowing us to track relationship changes and automatically\n    reflect changes in the inverse has-many array.\n\n    This hook passes the class being set up, as well as the key and value\n    being defined. So, for example, when the user does this:\n\n      DS.Model.extend({\n        parent: DS.belongsTo(App.User)\n      });\n\n    This hook would be called with \"parent\" as the key and the computed\n    property returned by `DS.belongsTo` as the value.\n\n    @method didDefineProperty\n    @param proto\n    @param key\n    @param value\n  */\n  didDefineProperty: function(proto, key, value) {\n    // Check if the value being set is a computed property.\n    if (value instanceof Ember.Descriptor) {\n\n      // If it is, get the metadata for the relationship. This is\n      // populated by the `DS.belongsTo` helper when it is creating\n      // the computed property.\n      var meta = value.meta();\n\n      if (meta.isRelationship && meta.kind === 'belongsTo') {\n        Ember.addObserver(proto, key, null, 'belongsToDidChange');\n        Ember.addBeforeObserver(proto, key, null, 'belongsToWillChange');\n      }\n\n      meta.parentType = proto.constructor;\n    }\n  }\n});\n\n/*\n  These DS.Model extensions add class methods that provide relationship\n  introspection abilities about relationships.\n\n  A note about the computed properties contained here:\n\n  **These properties are effectively sealed once called for the first time.**\n  To avoid repeatedly doing expensive iteration over a model's fields, these\n  values are computed once and then cached for the remainder of the runtime of\n  your application.\n\n  If your application needs to modify a class after its initial definition\n  (for example, using `reopen()` to add additional attributes), make sure you\n  do it before using your model with the store, which uses these properties\n  extensively.\n*/\n\nDS.Model.reopenClass({\n  /**\n    For a given relationship name, returns the model type of the relationship.\n\n    For example, if you define a model like this:\n\n        App.Post = DS.Model.extend({\n          comments: DS.hasMany(App.Comment)\n        });\n\n    Calling `App.Post.typeForRelationship('comments')` will return `App.Comment`.\n\n    @method typeForRelationship\n    @static\n    @param {String} name the name of the relationship\n    @return {subclass of DS.Model} the type of the relationship, or undefined\n  */\n  typeForRelationship: function(name) {\n    var relationship = get(this, 'relationshipsByName').get(name);\n    return relationship && relationship.type;\n  },\n\n  inverseFor: function(name) {\n    var inverseType = this.typeForRelationship(name);\n\n    if (!inverseType) { return null; }\n\n    var options = this.metaForProperty(name).options;\n\n    if (options.inverse === null) { return null; }\n    \n    var inverseName, inverseKind;\n\n    if (options.inverse) {\n      inverseName = options.inverse;\n      inverseKind = Ember.get(inverseType, 'relationshipsByName').get(inverseName).kind;\n    } else {\n      var possibleRelationships = findPossibleInverses(this, inverseType);\n\n      if (possibleRelationships.length === 0) { return null; }\n\n      Ember.assert(\"You defined the '\" + name + \"' relationship on \" + this + \", but multiple possible inverse relationships of type \" + this + \" were found on \" + inverseType + \".\", possibleRelationships.length === 1);\n\n      inverseName = possibleRelationships[0].name;\n      inverseKind = possibleRelationships[0].kind;\n    }\n\n    function findPossibleInverses(type, inverseType, possibleRelationships) {\n      possibleRelationships = possibleRelationships || [];\n\n      var relationshipMap = get(inverseType, 'relationships');\n      if (!relationshipMap) { return; }\n\n      var relationships = relationshipMap.get(type);\n      if (relationships) {\n        possibleRelationships.push.apply(possibleRelationships, relationshipMap.get(type));\n      }\n\n      if (type.superclass) {\n        findPossibleInverses(type.superclass, inverseType, possibleRelationships);\n      }\n\n      return possibleRelationships;\n    }\n\n    return {\n      type: inverseType,\n      name: inverseName,\n      kind: inverseKind\n    };\n  },\n\n  /**\n    The model's relationships as a map, keyed on the type of the\n    relationship. The value of each entry is an array containing a descriptor\n    for each relationship with that type, describing the name of the relationship\n    as well as the type.\n\n    For example, given the following model definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n          posts: DS.hasMany(App.Post)\n        });\n\n    This computed property would return a map describing these\n    relationships, like this:\n\n        var relationships = Ember.get(App.Blog, 'relationships');\n        relationships.get(App.User);\n        //=> [ { name: 'users', kind: 'hasMany' },\n        //     { name: 'owner', kind: 'belongsTo' } ]\n        relationships.get(App.Post);\n        //=> [ { name: 'posts', kind: 'hasMany' } ]\n\n    @property relationships\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  relationships: Ember.computed(function() {\n    var map = new Ember.MapWithDefault({\n      defaultValue: function() { return []; }\n    });\n\n    // Loop through each computed property on the class\n    this.eachComputedProperty(function(name, meta) {\n\n      // If the computed property is a relationship, add\n      // it to the map.\n      if (meta.isRelationship) {\n        if (typeof meta.type === 'string') {\n          meta.type = Ember.get(Ember.lookup, meta.type);\n        }\n\n        var relationshipsForType = map.get(meta.type);\n\n        relationshipsForType.push({ name: name, kind: meta.kind });\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A hash containing lists of the model's relationships, grouped\n    by the relationship kind. For example, given a model with this\n    definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n\n          posts: DS.hasMany(App.Post)\n        });\n\n    This property would contain the following:\n\n       var relationshipNames = Ember.get(App.Blog, 'relationshipNames');\n       relationshipNames.hasMany;\n       //=> ['users', 'posts']\n       relationshipNames.belongsTo;\n       //=> ['owner']\n\n    @property relationshipNames\n    @static\n    @type Object\n    @readOnly\n  */\n  relationshipNames: Ember.computed(function() {\n    var names = { hasMany: [], belongsTo: [] };\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        names[meta.kind].push(name);\n      }\n    });\n\n    return names;\n  }),\n\n  /**\n    An array of types directly related to a model. Each type will be\n    included once, regardless of the number of relationships it has with\n    the model.\n\n    For example, given a model with this definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n          posts: DS.hasMany(App.Post)\n        });\n\n    This property would contain the following:\n\n       var relatedTypes = Ember.get(App.Blog, 'relatedTypes');\n       //=> [ App.User, App.Post ]\n\n    @property relatedTypes\n    @static\n    @type Ember.Array\n    @readOnly\n  */\n  relatedTypes: Ember.computed(function() {\n    var type,\n        types = Ember.A();\n\n    // Loop through each computed property on the class,\n    // and create an array of the unique types involved\n    // in relationships\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        type = meta.type;\n\n        if (typeof type === 'string') {\n          type = get(this, type, false) || get(Ember.lookup, type);\n        }\n\n        Ember.assert(\"You specified a hasMany (\" + meta.type + \") on \" + meta.parentType + \" but \" + meta.type + \" was not found.\",  type);\n\n        if (!types.contains(type)) {\n          Ember.assert(\"Trying to sideload \" + name + \" on \" + this.toString() + \" but the type doesn't exist.\", !!type);\n          types.push(type);\n        }\n      }\n    });\n\n    return types;\n  }),\n\n  /**\n    A map whose keys are the relationships of a model and whose values are\n    relationship descriptors.\n\n    For example, given a model with this\n    definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n\n          posts: DS.hasMany(App.Post)\n        });\n\n    This property would contain the following:\n\n       var relationshipsByName = Ember.get(App.Blog, 'relationshipsByName');\n       relationshipsByName.get('users');\n       //=> { key: 'users', kind: 'hasMany', type: App.User }\n       relationshipsByName.get('owner');\n       //=> { key: 'owner', kind: 'belongsTo', type: App.User }\n\n    @property relationshipsByName\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  relationshipsByName: Ember.computed(function() {\n    var map = Ember.Map.create(), type;\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        meta.key = name;\n        type = meta.type;\n\n        if (typeof type === 'string') {\n          meta.type = this.store.modelFor(type);\n        }\n\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A map whose keys are the fields of the model and whose values are strings\n    describing the kind of the field. A model's fields are the union of all of its\n    attributes and relationships.\n\n    For example:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany(App.User),\n          owner: DS.belongsTo(App.User),\n\n          posts: DS.hasMany(App.Post),\n\n          title: DS.attr('string')\n        });\n\n        var fields = Ember.get(App.Blog, 'fields');\n        fields.forEach(function(field, kind) {\n          console.log(field, kind);\n        });\n\n        // prints:\n        // users, hasMany\n        // owner, belongsTo\n        // posts, hasMany\n        // title, attribute\n\n    @property fields\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  fields: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        map.set(name, meta.kind);\n      } else if (meta.isAttribute) {\n        map.set(name, 'attribute');\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @method eachRelationship\n    @static\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    get(this, 'relationshipsByName').forEach(function(name, relationship) {\n      callback.call(binding, name, relationship);\n    });\n  },\n\n  /**\n    Given a callback, iterates over each of the types related to a model,\n    invoking the callback with the related type's class. Each type will be\n    returned just once, regardless of how many different relationships it has\n    with a model.\n\n    @method eachRelatedType\n    @static\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelatedType: function(callback, binding) {\n    get(this, 'relatedTypes').forEach(function(type) {\n      callback.call(binding, type);\n    });\n  }\n});\n\nDS.Model.reopen({\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @method eachRelationship\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    this.constructor.eachRelationship(callback, binding);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/ext");minispade.register('ember-data/system/relationships/has_many', "(function() {minispade.require(\"ember-data/system/model/model\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set, setProperties = Ember.setProperties;\nvar forEach = Ember.EnumerableUtils.forEach;\n\nfunction asyncHasMany(type, options, meta) {\n  return Ember.computed(function(key, value) {\n    var resolver = Ember.RSVP.defer();\n\n    var relationship = buildRelationship(this, key, options, function(store, data) {\n      var link = data.links && data.links[key];\n\n      if (link) {\n        return store.findHasMany(this, link, meta, resolver);\n      } else {\n        return store.findMany(this, data[key], meta.type, resolver);\n      }\n    });\n\n    var promise = resolver.promise.then(function() {\n      return relationship;\n    });\n\n    return DS.PromiseArray.create({ promise: promise });\n  }).property('data').meta(meta);\n}\n\nfunction buildRelationship(record, key, options, callback) {\n  var rels = record._relationships;\n\n  if (rels[key]) { return rels[key]; }\n\n  var data = get(record, 'data'),\n      store = get(record, 'store');\n\n  var relationship = rels[key] = callback.call(record, store, data);\n\n  return setProperties(relationship, {\n    owner: record, name: key, isPolymorphic: options.polymorphic\n  });\n}\n\nfunction hasRelationship(type, options) {\n  options = options || {};\n\n  var meta = { type: type, isRelationship: true, options: options, kind: 'hasMany' };\n\n  if (options.async) {\n    return asyncHasMany(type, options, meta);\n  }\n\n  return Ember.computed(function(key, value) {\n    return buildRelationship(this, key, options, function(store, data) {\n      var records = data[key];\n      Ember.assert(\"You looked up the '\" + key + \"' relationship on '\" + this + \"' but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async (`DS.attr({ async: true })`)\", Ember.A(records).everyProperty('isEmpty', false));\n      return store.findMany(this, data[key], meta.type);\n    });\n  }).property('data').meta(meta);\n}\n\nDS.hasMany = function(type, options) {\n  Ember.assert(\"The type passed to DS.hasMany must be defined\", !!type);\n  return hasRelationship(type, options);\n};\n\n})();\n//@ sourceURL=ember-data/system/relationships/has_many");minispade.register('ember-data/system/store', "(function() {/*globals Ember*/\n/*jshint eqnull:true*/\nminispade.require(\"ember-data/system/record_arrays\");\nminispade.require(\"ember-data/system/mixins/mappable\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar isNone = Ember.isNone;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar indexOf = Ember.EnumerableUtils.indexOf;\nvar map = Ember.EnumerableUtils.map;\nvar OrderedSet = Ember.OrderedSet;\nvar resolve = Ember.RSVP.resolve;\n\n// Implementors Note:\n//\n//   The variables in this file are consistently named according to the following\n//   scheme:\n//\n//   * +id+ means an identifier managed by an external source, provided inside\n//     the data provided by that source. These are always coerced to be strings\n//     before being used internally.\n//   * +clientId+ means a transient numerical identifier generated at runtime by\n//     the data store. It is important primarily because newly created objects may\n//     not yet have an externally generated id.\n//   * +reference+ means a record reference object, which holds metadata about a\n//     record, even if it has not yet been fully materialized.\n//   * +type+ means a subclass of DS.Model.\n\n// Used by the store to normalize IDs entering the store.  Despite the fact\n// that developers may provide IDs as numbers (e.g., `store.find(Person, 1)`),\n// it is important that internally we use strings, since IDs may be serialized\n// and lose type information.  For example, Ember's router may put a record's\n// ID into the URL, and if we later try to deserialize that URL and find the\n// corresponding record, we will not know if it is a string or a number.\nvar coerceId = function(id) {\n  return id == null ? null : id+'';\n};\n\n/**\n  The store contains all of the data for records loaded from the server.\n  It is also responsible for creating instances of DS.Model that wrap\n  the individual data for a record, so that they can be bound to in your\n  Handlebars templates.\n\n  Define your application's store like this:\n\n       MyApp.Store = DS.Store.extend();\n\n  Most Ember.js applications will only have a single `DS.Store` that is\n  automatically created by their `Ember.Application`.\n\n  You can retrieve models from the store in several ways. To retrieve a record\n  for a specific id, use `DS.Model`'s `find()` method:\n\n       var person = App.Person.find(123);\n\n  If your application has multiple `DS.Store` instances (an unusual case), you can\n  specify which store should be used:\n\n      var person = store.find(App.Person, 123);\n\n  In general, you should retrieve models using the methods on `DS.Model`; you should\n  rarely need to interact with the store directly.\n\n  By default, the store will talk to your backend using a standard REST mechanism.\n  You can customize how the store talks to your backend by specifying a custom adapter:\n\n       MyApp.store = DS.Store.create({\n         adapter: 'MyApp.CustomAdapter'\n       });\n\n  You can learn more about writing a custom adapter by reading the `DS.Adapter`\n  documentation.\n\n  @class Store\n  @namespace DS\n  @extends Ember.Object\n  @uses DS._Mappable\n*/\nDS.Store = Ember.Object.extend(DS._Mappable, {\n\n  /**\n    @method init\n    @private\n  */\n  init: function() {\n    // internal bookkeeping; not observable\n    this.typeMaps = {};\n    this.recordArrayManager = DS.RecordArrayManager.create({\n      store: this\n    });\n    this._relationshipChanges = {};\n    this._pendingSave = [];\n  },\n\n  /**\n    The adapter to use to communicate to a backend server or other persistence layer.\n\n    This can be specified as an instance, class, or string.\n\n    If you want to specify `App.CustomAdapter` as a string, do:\n\n    ```js\n    adapter: 'custom'\n    ```\n\n    @property adapter\n    @default DS.RESTAdapter\n    @type {DS.Adapter|String}\n  */\n  adapter: '_rest',\n\n  /**\n    Returns a JSON representation of the record using a custom\n    type-specific serializer, if one exists.\n\n    The available options are:\n\n    * `includeId`: `true` if the record's ID should be included in\n      the JSON representation\n\n    @method serialize\n    @private\n    @param {DS.Model} record the record to serialize\n    @param {Object} options an options hash\n  */\n  serialize: function(record, options) {\n    return this.serializerFor(record.constructor.typeKey).serialize(record, options);\n  },\n\n  /**\n    This property returns the adapter, after resolving a possible\n    string key.\n\n    If the supplied `adapter` was a class, or a String property\n    path resolved to a class, this property will instantiate the\n    class.\n\n    This property is cacheable, so the same instance of a specified\n    adapter class should be used for the lifetime of the store.\n\n    @property defaultAdapter\n    @private\n    @returns DS.Adapter\n  */\n  defaultAdapter: Ember.computed(function() {\n    var adapter = get(this, 'adapter');\n\n    Ember.assert('You tried to set `adapter` property to an instance of `DS.Adapter`, where it should be a name or a factory', !(adapter instanceof DS.Adapter));\n\n    if (typeof adapter === 'string') {\n      adapter = this.container.lookup('adapter:' + adapter) || this.container.lookup('adapter:application') || this.container.lookup('adapter:_rest');\n    }\n\n    if (DS.Adapter.detect(adapter)) {\n      adapter = adapter.create({ container: this.container });\n    }\n\n    return adapter;\n  }).property('adapter'),\n\n  // .....................\n  // . CREATE NEW RECORD .\n  // .....................\n\n  /**\n    Create a new record in the current store. The properties passed\n    to this method are set on the newly created record.\n\n    To create a new instance of `App.Post`:\n\n    ```js\n    store.createRecord('post', {\n      title: \"Rails is omakase\"\n    });\n    ```\n\n    @method createRecord\n    @param {String} type\n    @param {Object} properties a hash of properties to set on the\n      newly created record.\n    @returns DS.Model\n  */\n  createRecord: function(type, properties) {\n    type = this.modelFor(type);\n\n    properties = properties || {};\n\n    // If the passed properties do not include a primary key,\n    // give the adapter an opportunity to generate one. Typically,\n    // client-side ID generators will use something like uuid.js\n    // to avoid conflicts.\n\n    if (isNone(properties.id)) {\n      properties.id = this._generateId(type);\n    }\n\n    // Coerce ID to a string\n    properties.id = coerceId(properties.id);\n\n    var record = this.buildRecord(type, properties.id);\n\n    // Move the record out of its initial `empty` state into\n    // the `loaded` state.\n    record.loadedData();\n\n    // Set the properties specified on the record.\n    record.setProperties(properties);\n\n    return record;\n  },\n\n  /**\n    If possible, this method asks the adapter to generate an ID for\n    a newly created record.\n\n    @method generateId\n    @param {String} type\n    @returns String if the adapter can generate one, an ID\n  */\n  _generateId: function(type) {\n    var adapter = this.adapterForType(type);\n\n    if (adapter && adapter.generateIdForRecord) {\n      return adapter.generateIdForRecord(this);\n    }\n\n    return null;\n  },\n\n  // .................\n  // . DELETE RECORD .\n  // .................\n\n  /**\n    For symmetry, a record can be deleted via the store.\n\n    @method deleteRecord\n    @param {DS.Model} record\n  */\n  deleteRecord: function(record) {\n    record.deleteRecord();\n  },\n\n  /**\n    For symmetry, a record can be unloaded via the store.\n\n    @method unloadRecord\n    @param {DS.Model} record\n  */\n  unloadRecord: function(record) {\n    record.unloadRecord();\n  },\n\n  // ................\n  // . FIND RECORDS .\n  // ................\n\n  /**\n    This is the main entry point into finding records. The first parameter to\n    this method is the model's name as a string.\n\n    ---\n\n    To find a record by ID, pass the `id` as the second parameter:\n\n        store.find('person', 1);\n\n    The `find` method will always return a **promise** that will be resolved\n    with the record. If the record was already in the store, the promise will\n    be resolved immediately. Otherwise, the store will ask the adapter's `find`\n    method to find the necessary data.\n\n    The `find` method will always resolve its promise with the same object for\n    a given type and `id`.\n\n    ---\n\n    To find all records for a type, call `find` with no additional parameters:\n\n        store.find('person');\n\n    This will ask the adapter's `findAll` method to find the records for the\n    given type, and return a promise that will be resolved once the server\n    returns the values.\n\n    ---\n\n    To find a record by a query, call `find` with a hash as the second\n    parameter:\n\n        store.find(App.Person, { page: 1 });\n\n    This will ask the adapter's `findQuery` method to find the records for\n    the query, and return a promise that will be resolved once the server\n    responds.\n\n    @method find\n    @param {DS.Model} type\n    @param {Object|String|Integer|null} id\n  */\n  find: function(type, id) {\n    if (id === undefined) {\n      return this.findAll(type);\n    }\n\n    // We are passed a query instead of an id.\n    if (Ember.typeOf(id) === 'object') {\n      return this.findQuery(type, id);\n    }\n\n    return this.findById(type, coerceId(id));\n  },\n\n  /**\n    This method returns a record for a given type and id combination.\n\n    @method findById\n    @private\n    @param type\n    @param id\n  */\n  findById: function(type, id) {\n    type = this.modelFor(type);\n\n    var record = this.getById(type, id);\n    if (get(record, 'isEmpty')) {\n      return promiseObject(this.fetchRecord(record));\n    } else {\n      return promiseObject(resolve(record));\n    }\n  },\n\n  /**\n    This method makes a series of requests to the adapter's `find` method\n    and returns a promise that resolves once they are all loaded.\n\n    @method findByIds\n    @param {String} type\n    @param {Array} ids\n    @returns Promise\n  */\n  findByIds: function(type, ids) {\n    var store = this;\n\n    return promiseArray(Ember.RSVP.all(map(ids, function(id) {\n      return store.findById(type, id);\n    })).then(function(array) {\n      return Ember.A(array);\n    }));\n  },\n\n  /**\n    This method is called by `findById` if it discovers that a particular\n    type/id pair hasn't been loaded yet to kick off a request to the\n    adapter.\n\n    @method fetchRecord\n    @private\n    @param {DS.Model} record\n    @returns Promise\n  */\n  fetchRecord: function(record) {\n    var type = record.constructor,\n        id = get(record, 'id'),\n        resolver = Ember.RSVP.defer();\n\n    record.loadingData();\n\n    var adapter = this.adapterForType(type);\n\n    Ember.assert(\"You tried to find a record but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to find a record but your adapter (for \" + type + \") does not implement 'find'\", adapter.find);\n\n    _find(adapter, this, type, id, resolver);\n\n    return resolver.promise;\n  },\n\n  /**\n    Get a record by a given type and ID without triggering a fetch.\n\n    This method will synchronously return the record if it's available.\n    Otherwise, it will return undefined.\n\n    ```js\n    var post = store.getById('post', 1);\n    ```\n\n    @method getById\n    @param type\n    @param id\n  */\n  getById: function(type, id) {\n    type = this.modelFor(type);\n\n    if (this.hasRecordForId(type, id)) {\n      return this.recordForId(type, id);\n    } else {\n      return this.buildRecord(type, id);\n    }\n  },\n\n  /**\n    This method is called by the record's `reload` method. The record's `reload`\n    passes in a resolver for the promise it returns.\n\n    This method calls the adapter's `find` method, which returns a promise. When\n    **that** promise resolves, `reloadRecord` will resolve the promise returned\n    by the record's `reload`.\n\n    @method reloadRecord\n    @private\n    @param {DS.Model} record\n    @param {Resolver} resolver\n  */\n  reloadRecord: function(record, resolver) {\n    var type = record.constructor,\n        adapter = this.adapterForType(type),\n        store = this,\n        id = get(record, 'id');\n\n    Ember.assert(\"You cannot reload a record without an ID\", id);\n    Ember.assert(\"You tried to reload a record but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to reload a record but your adapter does not implement `find`\", adapter.find);\n\n    return _find(adapter, this, type, id, resolver);\n  },\n\n  /**\n    This method takes a list of records, groups the records by type,\n    converts the records into IDs, and then invokes the adapter's `findMany`\n    method.\n\n    The records are grouped by type to invoke `findMany` on adapters\n    for each unique type in records.\n\n    It is used both by a brand new relationship (via the `findMany`\n    method) or when the data underlying an existing relationship\n    changes.\n\n    @method fetchMany\n    @private\n    @param records\n    @param owner\n  */\n  fetchMany: function(records, owner, resolver) {\n    if (!records.length) { return; }\n\n    // Group By Type\n    var recordsByTypeMap = Ember.MapWithDefault.create({\n      defaultValue: function() { return Ember.A(); }\n    });\n\n    forEach(records, function(record) {\n      recordsByTypeMap.get(record.constructor).push(record);\n    });\n\n    forEach(recordsByTypeMap, function(type, records) {\n      var ids = records.mapProperty('id'),\n          adapter = this.adapterForType(type);\n\n      Ember.assert(\"You tried to load many records but you have no adapter (for \" + type + \")\", adapter);\n      Ember.assert(\"You tried to load many records but your adapter does not implement `findMany`\", adapter.findMany);\n\n      _findMany(adapter, this, type, ids, owner, resolver);\n    }, this);\n  },\n\n  /**\n    Returns true if a record for a given type and ID is already loaded.\n\n    @param {String} type\n    @param {String|Integer} id\n    @returns Boolean\n  */\n  hasRecordForId: function(type, id) {\n    id = coerceId(id);\n\n    return !!this.typeMapFor(type).idToRecord[id];\n  },\n\n  /**\n    Returns id record for a given type and ID. If one isn't already loaded,\n    it builds a new record and leaves it in the `empty` state.\n\n    @param {String} type\n    @param {String|Integer} id\n    @returns DS.Model\n  */\n  recordForId: function(type, id) {\n    type = this.modelFor(type);\n\n    id = coerceId(id);\n\n    var record = this.typeMapFor(type).idToRecord[id];\n\n    if (!record) {\n      record = this.buildRecord(type, id);\n    }\n\n    return record;\n  },\n\n  /**\n    @method findMany\n    @private\n    @param {DS.Model} owner\n    @param {Array<DS.Model>} records\n    @param {String} type\n    @param {Resolver} resolver\n    @return DS.ManyArray\n  */\n  findMany: function(owner, records, type, resolver) {\n    type = this.modelFor(type);\n\n    records = Ember.A(records);\n\n    var unloadedRecords = records.filterProperty('isEmpty', true),\n        manyArray = this.recordArrayManager.createManyArray(type, records);\n\n    forEach(unloadedRecords, function(record) {\n      record.loadingData();\n    });\n\n    manyArray.loadingRecordsCount = unloadedRecords.length;\n\n    if (unloadedRecords.length) {\n      forEach(unloadedRecords, function(record) {\n        this.recordArrayManager.registerWaitingRecordArray(record, manyArray);\n      }, this);\n\n      this.fetchMany(unloadedRecords, owner, resolver);\n    } else {\n      manyArray.set('isLoaded', true);\n      Ember.run.once(manyArray, 'trigger', 'didLoad');\n    }\n\n    return manyArray;\n  },\n\n  /**\n    If a relationship was originally populated by the adapter as a link\n    (as opposed to a list of IDs), this method is called when the\n    relationship is fetched.\n\n    The link (which is usually a URL) is passed through unchanged, so the\n    adapter can make whatever request it wants.\n\n    The usual use-case is for the server to register a URL as a link, and\n    then use that URL in the future to make a request for the relationship.\n\n    @private\n    @param {DS.Model} owner\n    @param {any} link\n    @param {String} type\n    @param {Resolver} resolver\n    @return DS.ManyArray\n  */\n  findHasMany: function(owner, link, relationship, resolver) {\n    var adapter = this.adapterForType(owner.constructor);\n\n    Ember.assert(\"You tried to load a hasMany relationship but you have no adapter (for \" + owner.constructor + \")\", adapter);\n    Ember.assert(\"You tried to load a hasMany relationship from a specified `link` in the original payload but your adapter does not implement `findHasMany`\", adapter.findHasMany);\n\n    var records = this.recordArrayManager.createManyArray(relationship.type, Ember.A([]));\n    _findHasMany(adapter, this, owner, link, relationship, resolver);\n    return records;\n  },\n\n  /**\n    This method delegates a query to the adapter. This is the one place where\n    adapter-level semantics are exposed to the application.\n\n    Exposing queries this way seems preferable to creating an abstract query\n    language for all server-side queries, and then require all adapters to\n    implement them.\n\n    This method returns a promise, which is resolved with a `RecordArray`\n    once the server returns.\n\n    @method findQuery\n    @private\n    @param {String} type\n    @param {any} query an opaque query to be used by the adapter\n    @return Promise\n  */\n  findQuery: function(type, query) {\n    type = this.modelFor(type);\n\n    var array = DS.AdapterPopulatedRecordArray.create({\n      type: type,\n      query: query,\n      content: Ember.A(),\n      store: this\n    });\n\n    var adapter = this.adapterForType(type),\n        resolver = Ember.RSVP.defer();\n\n    Ember.assert(\"You tried to load a query but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load a query but your adapter does not implement `findQuery`\", adapter.findQuery);\n\n    _findQuery(adapter, this, type, query, array, resolver);\n\n    return promiseArray(resolver.promise);\n  },\n\n  /**\n    This method returns an array of all records adapter can find.\n    It triggers the adapter's `findAll` method to give it an opportunity to populate\n    the array with records of that type.\n\n    @method findAll\n    @private\n    @param {Class} type\n    @return {DS.AdapterPopulatedRecordArray}\n  */\n  findAll: function(type) {\n    type = this.modelFor(type);\n\n    return this.fetchAll(type, this.all(type));\n  },\n\n  /**\n    @method fetchAll\n    @private\n    @param type\n    @param array\n    @returns Promise\n  */\n  fetchAll: function(type, array) {\n    var adapter = this.adapterForType(type),\n        sinceToken = this.typeMapFor(type).metadata.since,\n        resolver = Ember.RSVP.defer();\n\n    set(array, 'isUpdating', true);\n\n    Ember.assert(\"You tried to load all records but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load all records but your adapter does not implement `findAll`\", adapter.findAll);\n\n    _findAll(adapter, this, type, sinceToken, resolver);\n\n    return promiseArray(resolver.promise);\n  },\n\n  /**\n    @method didUpdateAll\n    @param type\n  */\n  didUpdateAll: function(type) {\n    var findAllCache = this.typeMapFor(type).findAllCache;\n    set(findAllCache, 'isUpdating', false);\n  },\n\n  /**\n    This method returns a filtered array that contains all of the known records\n    for a given type.\n\n    Note that because it's just a filter, it will have any locally\n    created records of the type.\n\n    Also note that multiple calls to `all` for a given type will always\n    return the same RecordArray.\n\n    @method all\n    @param {Class} type\n    @return {DS.RecordArray}\n  */\n  all: function(type) {\n    type = this.modelFor(type);\n\n    var typeMap = this.typeMapFor(type),\n        findAllCache = typeMap.findAllCache;\n\n    if (findAllCache) { return findAllCache; }\n\n    var array = DS.RecordArray.create({\n      type: type,\n      content: Ember.A(),\n      store: this,\n      isLoaded: true\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type);\n\n    typeMap.findAllCache = array;\n    return array;\n  },\n\n  /**\n    Takes a type and filter function, and returns a live RecordArray that\n    remains up to date as new records are loaded into the store or created\n    locally.\n\n    The callback function takes a materialized record, and returns true\n    if the record should be included in the filter and false if it should\n    not.\n\n    The filter function is called once on all records for the type when\n    it is created, and then once on each newly loaded or created record.\n\n    If any of a record's properties change, or if it changes state, the\n    filter function will be invoked again to determine whether it should\n    still be in the array.\n\n    Note that the existence of a filter on a type will trigger immediate\n    materialization of all loaded data for a given type, so you might\n    not want to use filters for a type if you are loading many records\n    into the store, many of which are not active at any given time.\n\n    In this scenario, you might want to consider filtering the raw\n    data before loading it into the store.\n\n    @method filter\n    @param {Class} type\n    @param {Function} filter\n    @return {DS.FilteredRecordArray}\n  */\n  filter: function(type, query, filter) {\n    var promise;\n\n    // allow an optional server query\n    if (arguments.length === 3) {\n      promise = this.findQuery(type, query);\n    } else if (arguments.length === 2) {\n      filter = query;\n    }\n\n    type = this.modelFor(type);\n\n    var array = DS.FilteredRecordArray.create({\n      type: type,\n      content: Ember.A(),\n      store: this,\n      manager: this.recordArrayManager,\n      filterFunction: filter\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type, filter);\n\n    if (promise) {\n      return promise.then(function() { return array; });\n    } else {\n      return array;\n    }\n  },\n\n  /**\n    This method returns if a certain record is already loaded\n    in the store. Use this function to know beforehand if a find()\n    will result in a request or that it will be a cache hit.\n\n    @method recordIsLoaded\n    @param {Class} type\n    @param {string} id\n    @return {boolean}\n  */\n  recordIsLoaded: function(type, id) {\n    if (!this.hasRecordForId(type, id)) { return false; }\n    return !get(this.recordForId(type, id), 'isEmpty');\n  },\n\n  // ............\n  // . UPDATING .\n  // ............\n\n  /**\n    If the adapter updates attributes or acknowledges creation\n    or deletion, the record will notify the store to update its\n    membership in any filters.\n\n    To avoid thrashing, this method is invoked only once per\n    run loop per record.\n\n    @method dataWasUpdated\n    @private\n    @param {Class} type\n    @param {Number|String} clientId\n    @param {DS.Model} record\n  */\n  dataWasUpdated: function(type, record) {\n    // Because data updates are invoked at the end of the run loop,\n    // it is possible that a record might be deleted after its data\n    // has been modified and this method was scheduled to be called.\n    //\n    // If that's the case, the record would have already been removed\n    // from all record arrays; calling updateRecordArrays would just\n    // add it back. If the record is deleted, just bail. It shouldn't\n    // give us any more trouble after this.\n\n    if (get(record, 'isDeleted')) { return; }\n\n    if (get(record, 'isLoaded')) {\n      this.recordArrayManager.recordDidChange(record);\n    }\n  },\n\n  // ..............\n  // . PERSISTING .\n  // ..............\n\n  /**\n    This method is called by `record.save`, and gets passed a\n    resolver for the promise that `record.save` returns.\n\n    It schedules saving to happen at the end of the run loop.\n\n    @method scheduleSave\n    @private\n    @param {DS.Model} record\n    @param {Resolver} resolver\n  */\n  scheduleSave: function(record, resolver) {\n    record.adapterWillCommit();\n    this._pendingSave.push([record, resolver]);\n    once(this, 'flushPendingSave');\n  },\n\n  /**\n    This method is called at the end of the run loop, and\n    flushes any records passed into `scheduleSave`\n\n    @method flushPendingSave\n    @private\n  */\n  flushPendingSave: function() {\n    var pending = this._pendingSave.slice();\n    this._pendingSave = [];\n\n    forEach(pending, function(tuple) {\n      var record = tuple[0], resolver = tuple[1],\n          adapter = this.adapterForType(record.constructor),\n          operation;\n\n      if (get(record, 'isNew')) {\n        operation = 'createRecord';\n      } else if (get(record, 'isDeleted')) {\n        operation = 'deleteRecord';\n      } else {\n        operation = 'updateRecord';\n      }\n\n      _commit(adapter, this, operation, record, resolver);\n    }, this);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is resolved.\n\n    If the data provides a server-generated ID, it will\n    update the record and the store's indexes.\n\n    @method didSaveRecord\n    @private\n    @param {DS.Model} record the in-flight record\n    @param {Object} data optional data (see above)\n  */\n  didSaveRecord: function(record, data) {\n    if (data) {\n      this.updateId(record, data);\n    }\n\n    record.adapterDidCommit(data);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is rejected with a `DS.InvalidError`.\n\n    @method recordWasInvalid\n    @private\n    @param {DS.Model} record\n    @param {Object} errors\n  */\n  recordWasInvalid: function(record, errors) {\n    record.adapterDidInvalidate(errors);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is rejected (with anything other than a `DS.InvalidError`).\n\n    @method recordWasError\n    @private\n    @param {DS.Model} record\n  */\n  recordWasError: function(record) {\n    record.adapterDidError();\n  },\n\n  /**\n    When an adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    resolves with data, this method extracts the ID from the supplied\n    data.\n\n    @method updateId\n    @private\n    @param {DS.Model} record\n    @param {Object} data\n  */\n  updateId: function(record, data) {\n    var oldId = get(record, 'id'),\n        id = coerceId(data.id);\n\n    Ember.assert(\"An adapter cannot assign a new id to a record that already has an id. \" + record + \" had id: \" + oldId + \" and you tried to update it with \" + id + \". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\", oldId === null || id === oldId);\n\n    this.typeMapFor(record.constructor).idToRecord[id] = record;\n\n    set(record, 'id', id);\n  },\n\n  /**\n    Returns a map of IDs to client IDs for a given type.\n\n    @method typeMapFor\n    @private\n    @param type\n  */\n  typeMapFor: function(type) {\n    var typeMaps = get(this, 'typeMaps'),\n        guid = Ember.guidFor(type),\n        typeMap;\n\n    typeMap = typeMaps[guid];\n\n    if (typeMap) { return typeMap; }\n\n    typeMap = {\n      idToRecord: {},\n      records: [],\n      metadata: {}\n    };\n\n    typeMaps[guid] = typeMap;\n\n    return typeMap;\n  },\n\n  // ................\n  // . LOADING DATA .\n  // ................\n\n  /**\n    This internal method is used by `push`.\n\n    @method _load\n    @private\n    @param {DS.Model} type\n    @param data\n    @param prematerialized\n  */\n  _load: function(type, data) {\n    var id = coerceId(data.id),\n        record = this.recordForId(type, id);\n\n    record.setupData(data);\n    this.recordArrayManager.recordDidChange(record);\n\n    return record;\n  },\n\n  /**\n    Returns a model class for a particular key. Used by\n    methods that take a type key (like `find`, `createRecord`,\n    etc.)\n\n    @param {String} key\n    @returns {subclass of DS.Model}\n  */\n  modelFor: function(key) {\n    if (typeof key !== 'string') {\n      return key;\n    }\n\n    var factory = this.container.lookupFactory('model:'+key);\n\n    Ember.assert(\"No model was found for '\" + key + \"'\", factory);\n\n    factory.store = this;\n    factory.typeKey = key;\n\n    return factory;\n  },\n\n  /**\n    Push some data for a given type into the store.\n\n    This method expects normalized data:\n\n    * The ID is a key named `id` (an ID is mandatory)\n    * The names of attributes are the ones you used in\n      your model's `DS.attr`s.\n    * Your relationships must be:\n      * represented as IDs or Arrays of IDs\n      * represented as model instances\n      * represented as URLs, under the `links` key\n\n    For this model:\n\n    ```js\n    App.Person = DS.Model.extend({\n      firstName: DS.attr(),\n      lastName: DS.attr(),\n\n      children: DS.hasMany('person')\n    });\n    ```\n\n    To represent the children as IDs:\n\n    ```js\n    {\n      id: 1,\n      firstName: \"Tom\",\n      lastName: \"Dale\",\n      children: [1, 2, 3]\n    }\n    ```\n\n    To represent the children relationship as a URL:\n\n    ```js\n    {\n      id: 1,\n      firstName: \"Tom\",\n      lastName: \"Dale\",\n      links: {\n        children: \"/people/1/children\"\n      }\n    }\n    ```\n\n    If you're streaming data or implementing an adapter,\n    make sure that you have converted the incoming data\n    into this form.\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records.\n\n    @method push\n    @param {String} type\n    @param {Object} data\n    @returns DS.Model the record that was created or\n      updated.\n  */\n  push: function(type, data) {\n    var serializer = this.serializerFor(type);\n    type = this.modelFor(type);\n\n    data = serializer.deserialize(type, data);\n\n    this._load(type, data);\n\n    return this.recordForId(type, data.id);\n  },\n\n  /**\n    If you have an Array of normalized data to push,\n    you can call `pushMany` with the Array, and it will\n    call `push` repeatedly for you.\n\n    @method pushMany\n    @param {String} type\n    @param {Array} datas\n    @return {Array<DS.Model>}\n  */\n  pushMany: function(type, datas) {\n    return map(datas, function(data) {\n      return this.push(type, data);\n    }, this);\n  },\n\n  /**\n    Build a brand new record for a given type, ID, and\n    initial data.\n\n    @method buildRecord\n    @private\n    @param {subclass of DS.Model} type\n    @param {String} id\n    @param {Object} data\n    @returns DS.Model\n  */\n  buildRecord: function(type, id, data) {\n    var typeMap = this.typeMapFor(type),\n        idToRecord = typeMap.idToRecord;\n\n    Ember.assert('The id ' + id + ' has already been used with another record of type ' + type.toString() + '.', !id || !idToRecord[id]);\n\n    var record = type._create({\n      id: id,\n      store: this,\n    });\n\n    if (data) {\n      record.setupData(data);\n    }\n\n    // if we're creating an item, this process will be done\n    // later, once the object has been persisted.\n    if (id) {\n      idToRecord[id] = record;\n    }\n\n    typeMap.records.push(record);\n\n    return record;\n  },\n\n  // ...............\n  // . DESTRUCTION .\n  // ...............\n\n  /**\n    When a record is destroyed, this un-indexes it and\n    removes it from any record arrays so it can be GCed.\n\n    @method dematerializeRecord\n    @private\n    @param {DS.Model} record\n  */\n  dematerializeRecord: function(record) {\n    var type = record.constructor,\n        typeMap = this.typeMapFor(type),\n        id = get(record, 'id');\n\n    record.updateRecordArrays();\n\n    if (id) {\n      delete typeMap.idToRecord[id];\n    }\n\n    var loc = indexOf(typeMap.records, record);\n    typeMap.records.splice(loc, 1);\n  },\n\n  // ........................\n  // . RELATIONSHIP CHANGES .\n  // ........................\n\n  addRelationshipChangeFor: function(childRecord, childKey, parentRecord, parentKey, change) {\n    var clientId = childRecord.clientId,\n        parentClientId = parentRecord ? parentRecord : parentRecord;\n    var key = childKey + parentKey;\n    var changes = this._relationshipChanges;\n    if (!(clientId in changes)) {\n      changes[clientId] = {};\n    }\n    if (!(parentClientId in changes[clientId])) {\n      changes[clientId][parentClientId] = {};\n    }\n    if (!(key in changes[clientId][parentClientId])) {\n      changes[clientId][parentClientId][key] = {};\n    }\n    changes[clientId][parentClientId][key][change.changeType] = change;\n  },\n\n  removeRelationshipChangeFor: function(clientRecord, childKey, parentRecord, parentKey, type) {\n    var clientId = clientRecord.clientId,\n        parentClientId = parentRecord ? parentRecord.clientId : parentRecord;\n    var changes = this._relationshipChanges;\n    var key = childKey + parentKey;\n    if (!(clientId in changes) || !(parentClientId in changes[clientId]) || !(key in changes[clientId][parentClientId])){\n      return;\n    }\n    delete changes[clientId][parentClientId][key][type];\n  },\n\n  relationshipChangePairsFor: function(record){\n    var toReturn = [];\n\n    if( !record ) { return toReturn; }\n\n    //TODO(Igor) What about the other side\n    var changesObject = this._relationshipChanges[record.clientId];\n    for (var objKey in changesObject){\n      if(changesObject.hasOwnProperty(objKey)){\n        for (var changeKey in changesObject[objKey]){\n          if(changesObject[objKey].hasOwnProperty(changeKey)){\n            toReturn.push(changesObject[objKey][changeKey]);\n          }\n        }\n      }\n    }\n    return toReturn;\n  },\n\n  // ......................\n  // . PER-TYPE ADAPTERS\n  // ......................\n\n  /**\n    Returns the adapter for a given type.\n\n    @method adapterForType\n    @private\n    @param {subclass of DS.Model} type\n    @returns DS.Adapter\n  */\n  adapterForType: function(type) {\n    var container = this.container, adapter;\n\n    if (container) {\n      adapter = container.lookup('adapter:' + type.typeKey) || container.lookup('adapter:application');\n    }\n\n    return adapter || get(this, 'defaultAdapter');\n  },\n\n  // ..............................\n  // . RECORD CHANGE NOTIFICATION .\n  // ..............................\n\n  /**\n    Returns an instance of the serializer for a given type. For\n    example, `serializerFor('person')` will return an instance of\n    `App.PersonSerializer`.\n\n    If no `App.PersonSerializer` is found, this method will look\n    for an `App.ApplicationSerializer` (the default serializer for\n    your entire application).\n\n    If no `App.ApplicationSerializer` is found, it will fall back\n    to an instance of `DS.JSONSerializer`.\n\n    @method serializerFor\n    @private\n    @param {String} type the record to serialize\n  */\n  serializerFor: function(type) {\n    var container = this.container;\n\n    return container.lookup('serializer:'+type) ||\n           container.lookup('serializer:application') ||\n           container.lookup('serializer:_default');\n  }\n});\n\n// Delegation to the adapter and promise management\n\nDS.PromiseArray = Ember.ArrayProxy.extend(Ember.PromiseProxyMixin);\nDS.PromiseObject = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);\n\nfunction promiseObject(promise) {\n  return DS.PromiseObject.create({ promise: promise });\n}\n\nfunction promiseArray(promise) {\n  return DS.PromiseArray.create({ promise: promise });\n}\n\nfunction isThenable(object) {\n  return object && typeof object.then === 'function';\n}\n\nfunction serializerFor(adapter, type) {\n  var serializer = adapter.serializer,\n      defaultSerializer = adapter.defaultSerializer,\n      container = adapter.container;\n\n  if (container && serializer === undefined) {\n    serializer = container.lookup('serializer:'+type.typeKey) ||\n                 container.lookup('serializer:application') ||\n                 container.lookup('serializer:' + defaultSerializer || 'serializer:_default');\n  }\n\n  if (serializer === null || serializer === undefined) {\n    serializer = {\n      extract: function(store, type, payload) { return payload; }\n    };\n  }\n\n  return serializer;\n}\n\nfunction _find(adapter, store, type, id, resolver) {\n  var promise = adapter.find(store, type, id),\n      serializer = serializerFor(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    Ember.assert(\"You made a request for a \" + type.typeKey + \" with id \" + id + \", but the adapter's response did not have any data\", payload);\n    payload = serializer.extract(store, type, payload, id, 'find');\n\n    return store.push(type, payload);\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findMany(adapter, store, type, ids, owner, resolver) {\n  var promise = adapter.findMany(store, type, ids, owner),\n      serializer = serializerFor(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findMany');\n\n    store.pushMany(type, payload);\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findHasMany(adapter, store, record, link, relationship, resolver) {\n  var promise = adapter.findHasMany(store, record, link, relationship),\n      serializer = serializerFor(adapter, relationship.type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, relationship.type, payload, null, 'findHasMany');\n\n    var records = store.pushMany(relationship.type, payload);\n    record.updateHasMany(relationship.key, records);\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findAll(adapter, store, type, sinceToken, resolver) {\n  var promise = adapter.findAll(store, type, sinceToken),\n      serializer = serializerFor(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findAll');\n\n    store.pushMany(type, payload);\n    store.didUpdateAll(type);\n    return store.all(type);\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findQuery(adapter, store, type, query, recordArray, resolver) {\n  var promise = adapter.findQuery(store, type, query, recordArray),\n      serializer = serializerFor(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findAll');\n\n    recordArray.load(payload);\n    return recordArray;\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _commit(adapter, store, operation, record, resolver) {\n  var type = record.constructor,\n      promise = adapter[operation](store, type, record),\n      serializer = serializerFor(adapter, type);\n\n  Ember.assert(\"Your adapter's '\" + operation + \"' method must return a promise, but it returned \" + promise, isThenable(promise));\n\n  return promise.then(function(payload) {\n    payload = serializer.extract(store, type, payload, get(record, 'id'), operation);\n    store.didSaveRecord(record, payload);\n    return record;\n  }, function(reason) {\n    if (reason instanceof DS.InvalidError) {\n      store.recordWasInvalid(record, reason.errors);\n    } else {\n      store.recordWasError(record, reason);\n    }\n\n    throw reason;\n  }).then(resolver.resolve, resolver.reject);\n}\n\n})();\n//@ sourceURL=ember-data/system/store");minispade.register('ember-data/transforms/base', "(function() {DS.Transform = Ember.Object.extend({\n\n  serialize: Ember.required(),\n  \n  deserialize: Ember.required()\n\n});\n})();\n//@ sourceURL=ember-data/transforms/base");minispade.register('ember-data/transforms/boolean', "(function() {\nDS.BooleanTransform = DS.Transform.extend({\n  deserialize: function(serialized) {\n    var type = typeof serialized;\n\n    if (type === \"boolean\") {\n      return serialized;\n    } else if (type === \"string\") {\n      return serialized.match(/^true$|^t$|^1$/i) !== null;\n    } else if (type === \"number\") {\n      return serialized === 1;\n    } else {\n      return false;\n    }\n  },\n\n  serialize: function(deserialized) {\n    return Boolean(deserialized);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/transforms/boolean");minispade.register('ember-data/transforms/date', "(function() {DS.DateTransform = DS.Transform.extend({\n\n  deserialize: function(serialized) {\n    var type = typeof serialized;\n\n    if (type === \"string\") {\n      return new Date(Ember.Date.parse(serialized));\n    } else if (type === \"number\") {\n      return new Date(serialized);\n    } else if (serialized === null || serialized === undefined) {\n      // if the value is not present in the data,\n      // return undefined, not null.\n      return serialized;\n    } else {\n      return null;\n    }\n  },\n\n  serialize: function(date) {\n    if (date instanceof Date) {\n      var days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n      var months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"SDS.\", \"Oct\", \"Nov\", \"Dec\"];\n\n      var pad = function(num) {\n        return num < 10 ? \"0\"+num : \"\"+num;\n      };\n\n      var utcYear = date.getUTCFullYear(),\n          utcMonth = date.getUTCMonth(),\n          utcDayOfMonth = date.getUTCDate(),\n          utcDay = date.getUTCDay(),\n          utcHours = date.getUTCHours(),\n          utcMinutes = date.getUTCMinutes(),\n          utcSeconds = date.getUTCSeconds();\n\n\n      var dayOfWeek = days[utcDay];\n      var dayOfMonth = pad(utcDayOfMonth);\n      var month = months[utcMonth];\n\n      return dayOfWeek + \", \" + dayOfMonth + \" \" + month + \" \" + utcYear + \" \" +\n             pad(utcHours) + \":\" + pad(utcMinutes) + \":\" + pad(utcSeconds) + \" GMT\";\n    } else {\n      return null;\n    }\n  } \n\n});\n})();\n//@ sourceURL=ember-data/transforms/date");minispade.register('ember-data/transforms/index', "(function() {minispade.require('ember-data/transforms/base');\nminispade.require('ember-data/transforms/boolean');\nminispade.require('ember-data/transforms/date');\nminispade.require('ember-data/transforms/number');\nminispade.require('ember-data/transforms/string');\n})();\n//@ sourceURL=ember-data/transforms/index");minispade.register('ember-data/transforms/number', "(function() {var empty = Ember.isEmpty;\n\nDS.NumberTransform = DS.Transform.extend({\n\n  deserialize: function(serialized) {\n    return empty(serialized) ? null : Number(serialized);\n  },\n\n  serialize: function(deserialized) {\n    return empty(deserialized) ? null : Number(deserialized);\n  }\n});\n})();\n//@ sourceURL=ember-data/transforms/number");minispade.register('ember-data/transforms/string', "(function() {var none = Ember.isNone, empty = Ember.isEmpty;\n\nDS.StringTransform = DS.Transform.extend({\n\n  deserialize: function(serialized) {\n    return none(serialized) ? null : String(serialized);\n  },\n\n  serialize: function(deserialized) {\n    return none(deserialized) ? null : String(deserialized);\n  }\n\n});\n})();\n//@ sourceURL=ember-data/transforms/string");minispade.register('ember-inflector/ext/string', "(function() {minispade.require('ember-inflector/system/string');\r\n\r\nif (Ember.EXTEND_PROTOTYPES) {\r\n  /**\r\n    See {{#crossLink \"Ember.String/pluralize\"}}{{/crossLink}}\r\n\r\n    @method pluralize\r\n    @for String\r\n  */\r\n  String.prototype.pluralize = function() {\r\n    return Ember.String.pluralize(this);\r\n  };\r\n\r\n  /**\r\n    See {{#crossLink \"Ember.String/singularize\"}}{{/crossLink}}\r\n\r\n    @method singularize\r\n    @for String\r\n  */\r\n  String.prototype.singularize = function() {\r\n    return Ember.String.singularize(this);\r\n  };\r\n}\r\n\n})();\n//@ sourceURL=ember-inflector/ext/string");minispade.register('ember-inflector', "(function() {minispade.require('ember-inflector/system');\n\n})();\n//@ sourceURL=ember-inflector");minispade.register('ember-inflector/system', "(function() {minispade.require('ember-inflector/system/string');\r\nminispade.require('ember-inflector/system/inflector');\r\nminispade.require('ember-inflector/system/inflections');\r\nminispade.require('ember-inflector/ext/string');\r\n\r\nEmber.Inflector.inflector = new Ember.Inflector(Ember.Inflector.defaultRules);\r\n\n})();\n//@ sourceURL=ember-inflector/system");minispade.register('ember-inflector/system/inflections', "(function() {Ember.Inflector.defaultRules = {\n  plurals: [\n    [/$/, 's'],\n    [/s$/i, 's'],\n    [/^(ax|test)is$/i, '$1es'],\n    [/(octop|vir)us$/i, '$1i'],\n    [/(octop|vir)i$/i, '$1i'],\n    [/(alias|status)$/i, '$1es'],\n    [/(bu)s$/i, '$1ses'],\n    [/(buffal|tomat)o$/i, '$1oes'],\n    [/([ti])um$/i, '$1a'],\n    [/([ti])a$/i, '$1a'],\n    [/sis$/i, 'ses'],\n    [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'],\n    [/(hive)$/i, '$1s'],\n    [/([^aeiouy]|qu)y$/i, '$1ies'],\n    [/(x|ch|ss|sh)$/i, '$1es'],\n    [/(matr|vert|ind)(?:ix|ex)$/i, '$1ices'],\n    [/^(m|l)ouse$/i, '$1ice'],\n    [/^(m|l)ice$/i, '$1ice'],\n    [/^(ox)$/i, '$1en'],\n    [/^(oxen)$/i, '$1'],\n    [/(quiz)$/i, '$1zes']\n  ],\n\n  singular: [\n    [/s$/i, ''],\n    [/(ss)$/i, '$1'],\n    [/(n)ews$/i, '$1ews'],\n    [/([ti])a$/i, '$1um'],\n    [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i, '$1sis'],\n    [/(^analy)(sis|ses)$/i, '$1sis'],\n    [/([^f])ves$/i, '$1fe'],\n    [/(hive)s$/i, '$1'],\n    [/(tive)s$/i, '$1'],\n    [/([lr])ves$/i, '$1f'],\n    [/([^aeiouy]|qu)ies$/i, '$1y'],\n    [/(s)eries$/i, '$1eries'],\n    [/(m)ovies$/i, '$1ovie'],\n    [/(x|ch|ss|sh)es$/i, '$1'],\n    [/^(m|l)ice$/i, '$1ouse'],\n    [/(bus)(es)?$/i, '$1'],\n    [/(o)es$/i, '$1'],\n    [/(shoe)s$/i, '$1'],\n    [/(cris|test)(is|es)$/i, '$1is'],\n    [/^(a)x[ie]s$/i, '$1xis'],\n    [/(octop|vir)(us|i)$/i, '$1us'],\n    [/(alias|status)(es)?$/i, '$1'],\n    [/^(ox)en/i, '$1'],\n    [/(vert|ind)ices$/i, '$1ex'],\n    [/(matr)ices$/i, '$1ix'],\n    [/(quiz)zes$/i, '$1'],\n    [/(database)s$/i, '$1']\n  ],\n\n  irregularPairs: [\n    ['person', 'people'],\n    ['man', 'men'],\n    ['child', 'children'],\n    ['sex', 'sexes'],\n    ['move', 'moves'],\n    ['cow', 'kine'],\n    ['zombie', 'zombies']\n  ],\n\n  uncountable: [\n    'equipment',\n    'information',\n    'rice',\n    'money',\n    'species',\n    'series',\n    'fish',\n    'sheep',\n    'jeans',\n    'police'\n  ]\n};\n\n})();\n//@ sourceURL=ember-inflector/system/inflections");minispade.register('ember-inflector/system/inflector', "(function() {var BLANK_REGEX = /^\\s*$/;\n\nfunction loadUncountable(rules, uncountable) {\n  for (var i = 0, length = uncountable.length; i < length; i++) {\n    rules.uncountable[uncountable[i]] = true;\n  }\n}\n\nfunction loadIrregular(rules, irregularPairs) {\n  var pair;\n\n  for (var i = 0, length = irregularPairs.length; i < length; i++) {\n    pair = irregularPairs[i];\n\n    rules.irregular[pair[0]] = pair[1];\n    rules.irregularInverse[pair[1]] = pair[0];\n  }\n}\n\nfunction Inflector(ruleSet) {\n  ruleSet = ruleSet || {};\n  ruleSet.uncountable = ruleSet.uncountable || {};\n  ruleSet.irregularPairs= ruleSet.irregularPairs|| {};\n\n  var rules = this.rules = {\n    plurals:  ruleSet.plurals || [],\n    singular: ruleSet.singular || [],\n    irregular: {},\n    irregularInverse: {},\n    uncountable: {}\n  };\n\n  loadUncountable(rules, ruleSet.uncountable);\n  loadIrregular(rules, ruleSet.irregularPairs);\n}\n\nInflector.prototype = {\n  pluralize: function(word) {\n    return this.inflect(word, this.rules.plurals);\n  },\n\n  singularize: function(word) {\n    return this.inflect(word, this.rules.singular);\n  },\n\n  inflect: function(word, typeRules) {\n    var inflection, substitution, result, lowercase, isBlank,\n    isUncountable, isIrregular, isIrregularInverse, rule;\n\n    isBlank = BLANK_REGEX.test(word);\n\n    if (isBlank) {\n      return word;\n    }\n\n    lowercase = word.toLowerCase();\n\n    isUncountable = this.rules.uncountable[lowercase];\n\n    if (isUncountable) {\n      return word;\n    }\n\n    isIrregular = this.rules.irregular[lowercase];\n\n    if (isIrregular) {\n      return isIrregular;\n    }\n\n    isIrregularInverse = this.rules.irregularInverse[lowercase];\n\n    if (isIrregularInverse) {\n      return isIrregularInverse;\n    }\n\n    for (var i = typeRules.length, min = 0; i > min; i--) {\n       inflection = typeRules[i-1];\n       rule = inflection[0];\n\n      if (rule.test(word)) {\n        break;\n      }\n    }\n\n    inflection = inflection || [];\n\n    rule = inflection[0];\n    substitution = inflection[1];\n\n    result = word.replace(rule, substitution);\n\n    return result;\n  }\n};\n\nEmber.Inflector = Inflector;\n\n})();\n//@ sourceURL=ember-inflector/system/inflector");minispade.register('ember-inflector/system/string', "(function() {Ember.String.pluralize = function(word) {\n  return Ember.Inflector.inflector.pluralize(word);\n};\n\nEmber.String.singularize = function(word) {\n  return Ember.Inflector.inflector.singularize(word);\n};\n\n})();\n//@ sourceURL=ember-inflector/system/string");